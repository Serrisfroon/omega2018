<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//This object will replace the need for most primary shots, solus shots, and formation shots

//Initialize bullet attributes

for(i = 0; i &lt;=2000; i += 1)
{
 //This bullet index is free
 bulletfree[i] = true;
 //The bullet type is also the sprite
 bullettype[i] = spr_needle;
 //The bullet's coordinates
 bulletx[i] = 0;
 bullety[i] = 0;
 bulletgraze[i] = 0;
 //The bullet's vspeed and hspeed
 bullethspeed[i] = 0;
 bulletvspeed[i] = 0;
 //The bullet's direction. Used for drawing at the right angle
 bulletdirection[i] = 0;
 //The bullet's blend atribute. It shows what team it belongs to
 bulletblend[i] = c_red;
 //The bullet's life. Each step, it is lowered by one. At 0, this index is freed.
 bulletlife[i] = 0;
 //The bullet's damage. Stored to make loops much easier
 bulletdamage[i] = 0;
 //The bullet's death object. When a bullet has a collision, this object is created.
 bulletend[i] = obj_needle_hit;
 //The bullet's multiplayer id. This will trace the bullet to the player who shot it.
 bulletmid[i] = -1;
 //The bullet's name. Stored for ease of use
 bulletname[i] = "Needle";
 //The bullet's mask radius. Used for collision checking with ships
 bulletmask[i] = 5;
}
//Keeps track of the highest bullet index
bulletmax = 0;

//Create a psuedo-map of the room of all wall block locations
//Initialize the wall check for each 32x32 area of the map. Set it to false.
for(i = 0; i &lt;= ceil(room_width/32); i += 1)
{
 for(q = 0; q &lt;= ceil(room_height/32); q += 1)
 {
  wallposition[i, q] = false;
 }
}
//Set the wall check to true where a wall exists
with(obj_wall)
{
 obj_bulletcontrol.wallposition[x/32, y/32] = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Update all bullets
for(i = 1; i &lt;= bulletmax; i += 1)
{
    //Skip this loop if the index is free
    if(bulletfree[i] = true) continue;
 
    //Update the bullet's position
    bulletx[i] += bullethspeed[i];
    bullety[i] += bulletvspeed[i];
 
    //If this bullet's life is over, free the index and continue to the next loop
    //Also check if the bullet has left the room's boundaries
    if(bulletname[i] = "Horizon " || bulletname[i] = "Horizon")
    {
        if(bulletlife[i] &lt;= 0)
        {
            bulletfree[i] = true; 
            if(bulletgraze[i] = 1)
            {
                obj_ship.energy += 4;
                if(obj_ship.energy &gt; 100)
                    obj_ship.energy = 100;
                obj_ship.heat += 2;
                if(obj_ship.heat &gt; 50)
                    obj_ship.heat = 50;
                repeat(3)
                    effect_create_below(ef_spark, bulletx[i]-7+random(14), bullety[i]-7+random(14), 0, c_aqua);
                sfx_play(snd_graze, bulletx[i], bullety[i]);

                bulletgraze[i] = 0;
            }
               
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
            //Reduce until a new max is found
                for(q = i; q &gt; 0; q -= 1)
                {
                    if(bulletfree[q] = false) break;
                    bulletmax -= 1;
                }
            continue;
        } 
    }
    else
        if(bulletlife[i] &lt;= 0 || bulletx[i] &lt;= 0 || bulletx[i] &gt;= room_width || bullety[i] &lt;= 0 || bullety[i] &gt;= room_height)
        {
            bulletfree[i] = true;
            if(bulletgraze[i] = 1)
            {
                obj_ship.energy += 4;
                if(obj_ship.energy &gt; 100)
                    obj_ship.energy = 100;
                obj_ship.heat += 2;
                if(obj_ship.heat &gt; 50)
                    obj_ship.heat = 50;
                repeat(3)
                    effect_create_below(ef_spark, bulletx[i]-7+random(14), bullety[i]-7+random(14), 0, c_aqua);
                sfx_play(snd_graze, bulletx[i], bullety[i]);
                bulletgraze[i] = 0;
            }
            //Create a stasis field if it is a stasis bullet
            if(bullettype[i] = spr_whip || bullettype[i] = spr_snake_body || bullettype[i] = spr_stasis)
            {         
                ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
                ending.direction = bulletdirection[i];
                ending.image_angle = ending.direction;
                ending.mid = bulletmid[i];
                if(bullettype[i] = spr_snake_body)
                {
                    ending.image_blend = bulletblend[i];
                    ending.image_angle = ending.direction;    
                }
            }
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
                //Reduce until a new max is found
                for(q = i; q &gt; 0; q -= 1)
                {
                    if(bulletfree[q] = false) break;
                    bulletmax -= 1;
                }
            continue;
        }
    //Check according to blend, which tells team
    switch(bulletblend[i])
    {
        //Check enemies if this is an allied bullet
        case global.allycolor:
            //Find the closest enemy to the bullet
            possihit = instance_nearest(bulletx[i], bullety[i], prnt_allenemy);
            //Break the switch statement if there are no allys
            if(possihit = noone) break;
            //Check if the nearest enemy is close to a collision
            if(abs(possihit.x-bulletx[i]) &gt; 30 || abs(possihit.y-bullety[i]) &gt; 30) break;

            //Check if there is a collision
            if(!collision_circle(bulletx[i], bullety[i], bulletmask[i], possihit, 1, 0)) break;
            sfx_play(snd_hit, bulletx[i], bullety[i]);
            //Take damage
            if(bullettype[i] = spr_pierce)
                possihit.armor -= 3;
            possihit.shield -= bulletdamage[i];
            if(possihit.shield &lt; 0)
            {
                if(possihit.sprite_index = spr_turretbase)
                {
                    if(point_distance(global.playership[bulletmid[i]].x, global.playership[bulletmid[i]].y, possihit.x, possihit.y) &lt;= 400)
                        bulletdamage[i] = 5;
                    else
                        bulletdamage[i] = 0;
                        
                    possihit.shield = 0;
                    if(possihit.reset = 0 &amp;&amp; bulletdamage[i] = 5)
                    {
                        possihit.armor -= bulletdamage[i];
                        possihit.reset = 1;
                        possihit.alarm[0] = 10;
                    }
                }
                else
                {   
                    possihit.shield = 0;
                    possihit.armor -= bulletdamage[i];
                }
            }
        
            //Update smoking
            if(possihit.sprite_index != spr_turretbase &amp;&amp; room = rm_practice)
                possihit.smoke = floor(possihit.armor/(possihit.maxarmor/10));

            //If there is shield left, create effect
            if(possihit.shieldup = 1)
            {
                hurt = instance_create(0, 0, obj_hit);
                hurt.hitdir = point_direction(possihit.x, possihit.y, bulletx[i]-bullethspeed[i], bullety[i]-bulletvspeed[i]);
                hurt.hurting = possihit;
            }
            bulletfree[i] = true;
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
            //Reduce until a new max is found
                for(q = i; q &gt; 0; q -= 1)
                {
                    if(bulletfree[q] = false) break;
                    bulletmax -= 1;
                }
            ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
            ending.direction = bulletdirection[i];
            ending.mid = bulletmid[i];
            if(bullettype[i] = spr_snake_body)
            {
                ending.image_blend = bulletblend[i];
                ending.image_angle = ending.direction;    
            }
        break;
        //Check allies if this is an enemy bullet
        case global.enemycolor:
            //Find the closest enemy to the bullet
            possihit = instance_nearest(bulletx[i], bullety[i], prnt_ally);
            //Break the switch statement if there are no allys
            if(possihit = noone || possihit = obj_deadship || possihit = obj_ship_placeholder) break;
            //Check if the nearest enemy is close to a collision
            //Also check if the closest ally is actually an error check
            //Check if the nearest enemy is close to a collision
            if(abs(possihit.x-bulletx[i]) &gt; 30 || abs(possihit.y-bullety[i]) &gt; 30) break;
            //Check if there is a collision
            if(!collision_circle(bulletx[i], bullety[i], bulletmask[i], possihit, 1, 0)) break;
            switch(possihit.mid)
            {
                case global.mymid:
                    sfx_play(snd_hit, bulletx[i], bullety[i]);
                    //Intercept turrets
                    if(possihit.sprite_index = spr_turretbase)
                    {
                        if(point_distance(global.playership[bulletmid[i]].x, global.playership[bulletmid[i]].y, possihit.x, possihit.y) &lt;= 400)
                            bulletdamage[i] = 5;
                        else
                            bulletdamage[i] = 0;
                        
                        if(possihit.reset = 0 &amp;&amp; bulletdamage[i] = 5)
                        {
                            possihit.armor -= bulletdamage[i];
                            possihit.reset = 1;
                            possihit.alarm[0] = 10;
                        }
                        break;
                    }
                    //Check if there's a nearby paladin turret
                    var shielded, shielddown;
                    shielded = 1;
                    if(instance_exists(obj_turret))
                        if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
                            shielded = 2;
                    if(possihit.invincible = 1 &amp;&amp; possihit.beserk = 0)
                    {
                            shielddown = 1;
                            if(possihit.shield = 0)
                                shielddown = 0;

                        //Take damage
                        //Take pierce damage
                        if(bullettype[i] = spr_pierce)
                        {
                            possihit.armor -= 3;
                            global.damagetaken[global.mymid] += 3*possihit.threshold/shielded;
                            global.damagedealt[bulletmid[i]] += 3*possihit.threshold/shielded;                        
                        }
                        //If burst, slash, or whip, apply threshold damage
                        if((bullettype[i] = spr_burst || bullettype[i] = spr_slash || bullettype[i] = spr_whip || bulletname[i] = "Formation"))
                        {
                            //Check if under shock effect
                            if(possihit.shocked = false)
                                possihit.shield -= bulletdamage[i]*possihit.threshold/shielded;
                            else
                            {
                                possihit.shield -= bulletdamage[i]*possihit.threshold/2;
                                possihit.armor -= bulletdamage[i]*possihit.threshold/2;
                            }
                            global.damagetaken[global.mymid] += bulletdamage[i]*possihit.threshold/shielded;
                            global.damagedealt[bulletmid[i]] += bulletdamage[i]*possihit.threshold/shielded;
                  
                            switch(bullettype[i])
                            {
                                case spr_burst:
                                case spr_slash:
                                case spr_whip:
                                case spr_formation:
                                case spr_trigger_shot:
                                    possihit.threshold -= 0.08;
                                    possihit.alarm[9] = 60;
                                break;
                            }    
                            if(possihit.threshold &lt; 0.1)
                                possihit.threshold = 0.1;   
                        } 
                        //Otherwise, calculate damage normally
                        else
                        {
                            //Check if under shock effect
                            if(possihit.shocked = false)
                                possihit.shield -= bulletdamage[i]/shielded;
                            else
                            {
                                possihit.shield -= bulletdamage[i]/2;
                                possihit.armor -= bulletdamage[i]/2;
                            }
                        }
                        //If there is no more shield, transfer damage to armor
                        if(possihit.shield &lt; 0) 
                        {
                            possihit.armor += possihit.shield;
                            possihit.shield = 0;
                            if(shielddown = 1)
                                obj_mod.sendping = 0;

                        }
                    }
                    //If there is shield left, create effect
                    if(possihit.shield &gt; 0)
                    {
                        hurt = instance_create(0, 0, obj_hit);
                        hurt.hitdir = point_direction(possihit.x, possihit.y, bulletx[i]-bullethspeed[i], bullety[i]-bulletvspeed[i]);
                        hurt.hurting = possihit;
                    }
                    //Update smoking
                    possihit.smoke = floor(possihit.armor/(possihit.maxarmor/10));
         
                    //Reset shield regen time
                        possihit.alarm[4] = possihit.regentime;

                    //Check if your ship has been defeated
                    if(possihit.armor &lt;= 0 &amp;&amp; possihit.beserk = 0)
                    {
                        if(!instance_exists(obj_practicemod))
                        {
                            //Take note of the player that defeated you
                            possihit.defeatmid = bulletmid[i];
                            //Make a defeat message
                            if(global.ships &gt; 1)
                                random_message(global.othername[bulletmid[i]], global.name, bulletname[i]);
                            else
                                obj_ship.message = global.othername[bulletmid[i]]+" ELIMINATED "+global.name+".("+bulletname[i]+")";
                        }
                        if(global.shipselect != 2)
                        {
                            //Destroy this object
                            with(possihit)
                            instance_destroy();
                        }
                        else
                        {
                            possihit.armor = 0;
                            possihit.shield = 0;
                            possihit.beserk = 1;
                            possihit.energygain = 0.8;
                            possihit.energy = 100;
                            possihit.heat = 50;
                            possihit.cooldown = 1;
                            obj_mod.sendping = 0;
                            possihit.beserkeffect = instance_create(x, y, obj_beserkeffect);
                            possihit.alarm[11] = 300;
                        }
                    }
                break;
                default:
                    sfx_play(snd_hit, bulletx[i], bullety[i]);
                    //Intercept turrets
                    if(possihit.sprite_index = spr_turretbase)
                    {
                        if(point_distance(global.playership[bulletmid[i]].x, global.playership[bulletmid[i]].y, possihit.x, possihit.y) &lt;= 400)
                            bulletdamage[i] = 5;
                        else
                            bulletdamage[i] = 0;
                        if(possihit.reset = 0 &amp;&amp; bulletdamage[i] = 5)
                        {
                            possihit.armor -= bulletdamage[i];
                            possihit.reset = 1;
                            possihit.alarm[0] = 10;
                        }
                        break;
                    }   
                    
                    //Take damage
                    if(bullettype[i] = spr_pierce)
                        possihit.armor -= 3;
                    possihit.armor -= bulletdamage[i];
                    //If there is shield left, create effect
                    if(possihit.shieldup = 1)
                    {
                        hurt = instance_create(0, 0, obj_hit);
                        hurt.hitdir = point_direction(possihit.x, possihit.y, bulletx[i]-bullethspeed[i], bullety[i]-bulletvspeed[i]);
                        hurt.hurting = possihit;
                    }
                break;
            }        
            bulletfree[i] = true;
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
            //Reduce until a new max is found
            for(q = i; q &gt; 0; q -= 1)
            {
             if(bulletfree[q] = false) break;
             bulletmax -= 1;
            }
            ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
            ending.direction = bulletdirection[i];
            ending.mid = bulletmid[i];
            if(bullettype[i] = spr_snake_body)
            {
             ending.image_blend = bulletblend[i];
             ending.image_angle = ending.direction;    
            }
        break;
    }


    //Check barrier collisions
    switch(bulletblend[i])
    {
        case global.allycolor:
            if(instance_number(obj_barrier_enemy) &lt; 1) break;
            //Find the closest enemy to the bullet
            possihit = instance_nearest(bulletx[i], bullety[i], obj_barrier_enemy);
            //Check if the nearest enemy is close to a collision
            if(abs(possihit.x-bulletx[i]) &gt; 250 || abs(possihit.y-bullety[i]) &gt; 250) break;
            //Check if there is a collision
            if(!collision_circle(bulletx[i], bullety[i], 5, possihit, 1, 0)) break;
            //Free this index
            bulletfree[i] = true;
            if(possihit.sprite_index = spr_solus)
                possihit.owner.absorb += 0.20;
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
                //Reduce until a new max is found
                for(q = i; q &gt; 0; q -= 1)
                {
                    if(bulletfree[q] = false) break;
                    bulletmax -= 1;
                }
            ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
            ending.direction = bulletdirection[i];
            ending.mid = bulletmid[i];
            if(bullettype[i] = spr_snake_body)
            {
                ending.image_blend = bulletblend[i];
                ending.image_angle = ending.direction;    
            }
        break;
        case global.enemycolor:
            if(instance_number(obj_barrier) &lt; 1) break;
            //Find the closest enemy to the bullet
            possihit = instance_nearest(bulletx[i], bullety[i], obj_barrier);
            //Check if the nearest enemy is close to a collision
            if(abs(possihit.x-bulletx[i]) &gt; 250 || abs(possihit.y-bullety[i]) &gt; 250) break;
            //Check if there is a collision
            if(!collision_circle(bulletx[i], bullety[i], 5, possihit, 1, 0)) break;
            //Free this index
            bulletfree[i] = true;
            if(bulletgraze[i] = 1)
            {
                obj_ship.energy += 4;
                if(obj_ship.energy &gt; 100)
                    obj_ship.energy = 100;
                obj_ship.heat += 2;
                if(obj_ship.heat &gt; 50)
                    obj_ship.heat = 50;
                repeat(3)
                    effect_create_below(ef_spark, bulletx[i]-7+random(14), bullety[i]-7+random(14), 0, c_aqua);
                sfx_play(snd_graze, bulletx[i], bullety[i]);
                bulletgraze[i] = 0;
            }
            if(possihit.sprite_index = spr_solus)
                possihit.owner.absorb += 0.20;
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
                //Reduce until a new max is found
                for(q = i; q &gt; 0; q -= 1)
                {
                    if(bulletfree[q] = false) break;
                    bulletmax -= 1;
                }
            ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
            ending.direction = bulletdirection[i];
            ending.mid = bulletmid[i];
            if(bullettype[i] = spr_snake_body)
            {
                ending.image_blend = bulletblend[i];
                ending.image_angle = ending.direction;    
            }
        break;
    }
    //Lower the bullet's life
    bulletlife[i] -= 1;
 
 
    //Wall collision
    if(bulletname[i] = "Horizon " || ( ( bulletx[i] &lt;= 0 || bulletx[i] &gt;= room_width || bullety[i] &lt;= 0 || bullety[i] &gt;= room_height ) &amp;&amp; bulletname[i] = "Horizon" ) ) continue;
    if(wallposition[floor(bulletx[i]/32), floor(bullety[i]/32)] = false) continue;
    //Free this index
    bulletfree[i] = true;
    if(bulletgraze[i] = 1)
    {
        obj_ship.energy += 4;
        if(obj_ship.energy &gt; 100)
            obj_ship.energy = 100;
        obj_ship.heat += 2;
        if(obj_ship.heat &gt; 50)
            obj_ship.heat = 50;
        repeat(3)
            effect_create_below(ef_spark, bulletx[i]-7+random(14), bullety[i]-7+random(14), 0, c_aqua);
        sfx_play(snd_graze, bulletx[i], bullety[i]);
        bulletgraze[i] = 0;
    }
    //Reduce the bullet max if this is the last bullet
    if(bulletmax = i)
    //Reduce until a new max is found
        for(q = i; q &gt; 0; q -= 1)
        {
            if(bulletfree[q] = false) break;
            bulletmax -= 1;
        }
    ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
    ending.direction = bulletdirection[i];
    ending.mid = bulletmid[i];
}





</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Draw the bullets
for(i = 1; i &lt;= bulletmax; i += 1)
{
    if(bulletfree[i] = true) continue;
    draw_sprite_ext(bullettype[i], -1, bulletx[i], bullety[i], 1, 1, bulletdirection[i], bulletblend[i], 1);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
