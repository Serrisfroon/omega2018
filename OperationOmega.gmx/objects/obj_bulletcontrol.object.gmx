<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//This object will replace the need for most primary shots, solus shots, and formation shots
bloom=surface_create(room_width/2, room_height/2);
bloom2=surface_create(room_width/4, room_height/4);
bloom3=surface_create(room_width/8, room_height/8);
bloom4=surface_create(room_width/16, room_height/16);
bloom5=surface_create(room_width/32, room_height/32);
surface_set_target(bloom);
draw_clear(c_black);
surface_reset_target();

surface_set_target(bloom2);
draw_clear(c_black);
surface_reset_target();

surface_set_target(bloom3);
draw_clear(c_black);
surface_reset_target();

surface_set_target(bloom4);
draw_clear(c_black);
surface_reset_target();

surface_set_target(bloom5);
draw_clear(c_black);
surface_reset_target();



nova_count[0] = 0;
nova_count[1] = 0;
nova_count[2] = 0;
nova_count[3] = 0;
nova_count[4] = 0;
nova_count[5] = 0;
nova_count[6] = 0;
nova_count[7] = 0;
nova_count[8] = 0;

//Initialize bullet attributes

for(i = 0; i &lt;=2000; i += 1)
{
 //This bullet index is free
 bulletfree[i] = true;
 //The bullet type is also the sprite
 bullettype[i] = spr_needle;
 //The bullet's coordinates
 bulletx[i] = 0;
 bullety[i] = 0;
 bulletgraze[i] = 0;
 //The bullet's vspeed and hspeed
 bullethspeed[i] = 0;
 bulletvspeed[i] = 0;
 //The bullet's direction. Used for drawing at the right angle
 bulletdirection[i] = 0;
 //The bullet's blend atribute. It shows what team it belongs to
 bulletblend[i] = c_red;
 //The bullet's life. Each step, it is lowered by one. At 0, this index is freed.
 bulletlife[i] = 0;
 //The bullet's damage. Stored to make loops much easier
 bulletdamage[i] = 0;
 //The bullet's death object. When a bullet has a collision, this object is created.
 bulletend[i] = obj_generic_hit;
 //The bullet's multiplayer id. This will trace the bullet to the player who shot it.
 bulletmid[i] = -1;
 //The bullet's name. Stored for ease of use
 bulletname[i] = "Needle";
 //The bullet's mask radius. Used for collision checking with ships
 bulletmask[i] = 5;
}
//Keeps track of the highest bullet index
bulletmax = 0;

//Create a psuedo-map of the room of all wall block locations
//Initialize the wall check for each 32x32 area of the map. Set it to false.
for(i = 0; i &lt;= ceil(room_width/32); i += 1)
{
 for(q = 0; q &lt;= ceil(room_height/32); q += 1)
 {
  wallposition[i, q] = false;
 }
}
//Set the wall check to true where a wall exists
with(obj_wall)
{
 obj_bulletcontrol.wallposition[x/32, y/32] = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Update all bullets
for(i = 1; i &lt;= bulletmax; i += 1)
{
    //Skip this loop if the index is free
    if(bulletfree[i] = true) continue;
 
    //Update the bullet's position
    bulletx[i] += bullethspeed[i];
    bullety[i] += bulletvspeed[i];
 
    //If this bullet's life is over, free the index and continue to the next loop
    //Also check if the bullet has left the room's boundaries
    if(bulletname[i] = "Horizon " || bulletname[i] = "Horizon")
    {
        if(bulletlife[i] &lt;= 0)
        {
            bulletfree[i] = true; 
               
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
            //Reduce until a new max is found
                for(q = i; q &gt; 0; q -= 1)
                {
                    if(bulletfree[q] = false) break;
                    bulletmax -= 1;
                }
            continue;
        } 
    }
    else
        if(bulletlife[i] &lt;= 0 || bulletx[i] &lt;= 0 || bulletx[i] &gt;= room_width || bullety[i] &lt;= 0 || bullety[i] &gt;= room_height)
        {
            bulletfree[i] = true;
            switch(bullettype[i])
            {
                case spr_whip:
                case spr_snake_body:
                    var ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
                    ending.direction = bulletdirection[i];
                    ending.image_angle = ending.direction;
                    ending.mid = bulletmid[i];
                    ending.image_speed = 0;
                    if(bulletblend[i] = c_red)
                        ending.image_index = 0;
                    else
                        ending.image_index = 1;                    
                    ending.image_angle = ending.direction;                    
                break;
                case spr_stasis:
                    ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
                    ending.direction = bulletdirection[i];
                    ending.image_angle = ending.direction;
                    ending.mid = bulletmid[i];                
                break;
                case spr_cryos:
                    ending = instance_create(bulletx[i], bullety[i], obj_cryos_fade);
                    ending.mid = bulletmid[i];                
                break;
                case spr_nova:
                    if(bulletname[i] = "Nova")
                        if(bulletlife[i] &lt;= 0)
                        {
                            mid = bulletmid[i];
                            bullet_create(bulletx[i], bullety[i], "Nova ", bulletdirection[i], bulletmid[i], 0);      
                                break;
                        }          
                    if(bulletname[i] = "Nova ")
                        if(bullethspeed[i] = 0)
                            if(bulletvspeed[i] = 0)
                                nova_count[bulletmid[i]] -= 1;
                default:
                    ending = instance_create(bulletx[i], bullety[i], obj_generic_fade);
                    ending.direction = bulletdirection[i];
                    ending.hspeed = bullethspeed[i];
                    ending.vspeed = bulletvspeed[i];
                    ending.sprite_index = bullettype[i];
                    ending.mid = bulletmid[i];
                break;
            }
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
                //Reduce until a new max is found
                for(q = i; q &gt; 0; q -= 1)
                {
                    if(bulletfree[q] = false) break;
                    bulletmax -= 1;
                }
            continue;
        }
    //Check according to blend, which tells team
    switch(bulletblend[i])
    {
        //Check enemies if this is an allied bullet
        case global.allycolor:
            //Find the closest enemy to the bullet
            possihit = instance_nearest(bulletx[i], bullety[i], obj_dummy_enemy);
            //Break the switch statement if there are no allys
            if(possihit = noone) break;
            //Check if the nearest enemy is close to a collision
            if(abs(possihit.x-bulletx[i]) &gt; bulletmask[i] || abs(possihit.y-bullety[i]) &gt; bulletmask[i]) break;
            
            sfx_play(snd_hit, bulletx[i], bullety[i]);
            //Handle Cryos slow
            if(bullettype[i] = spr_cryos)
                possihit.speed = max(0, possihit.speed-7);
            //Take damage
            possihit.shield -= bulletdamage[i];
            if(possihit.shield &lt; 0)
            { 
                possihit.shield = 0;
                possihit.armor -= bulletdamage[i];
            }
        
            //Update smoking
            if(possihit.sprite_index != spr_turretbase &amp;&amp; room = rm_practice)
                possihit.smoke = floor(possihit.armor/(possihit.armor_maximum/10));
                            
            //If there is shield left, create effect
            if(possihit.shieldup = 1)
            {
                hurt = instance_create(0, 0, obj_hit);
                hurt.hitdir = point_direction(possihit.x, possihit.y, bulletx[i]-bullethspeed[i], bullety[i]-bulletvspeed[i]);
                hurt.hurting = possihit;
            }
            //Make the hit ship flash
            hurt = instance_create(0, 0, obj_ship_flash);
            hurt.hurting = possihit;  
            hurt.ship_image = global.selected_ship[possihit.mid]-1;
            
            bulletfree[i] = true;
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
            //Reduce until a new max is found
                for(q = i; q &gt; 0; q -= 1)
                {
                    if(bulletfree[q] = false) break;
                    bulletmax -= 1;
                }
            ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
            ending.direction = bulletdirection[i];
            ending.mid = bulletmid[i];
            switch(bullettype[i])
            {
                case spr_snake_body:
                case spr_whip:
                    ending.image_speed = 0;
                    if(bulletblend[i] = c_red)
                        ending.image_index = 0;
                    else
                        ending.image_index = 1;                    
                    ending.image_angle = ending.direction;                        
                break;
                case spr_cryos:
                    ending.target_mid = possihit.mid;
                    ending.x = possihit.x;
                    ending.y = possihit.y;
                break;
                case spr_nova:
                    if(bulletname[i] = "Nova ")
                        if(bullethspeed[i] = 0)
                            if(bulletvspeed[i] = 0)
                                nova_count[bulletmid[i]] -= 1;
                break;
            }
        break;
        //Check allies if this is an enemy bullet
        case global.enemycolor:
            //Find the closest ally to the bullet
            possihit = instance_nearest(bulletx[i], bullety[i], obj_dummy_ally);
            //Check if the player is close than the nearest ally
            if(possihit = noone)
                possihit = obj_player;            
            else
                if(point_distance(bulletx[i], bullety[i], obj_player.x, obj_player.y) &lt; point_distance(bulletx[i], bullety[i], possihit.x, possihit.y))
                    possihit = obj_player;
            //Check if the nearest enemy is close to a collision
            //Also check if the closest ally is actually an error check
            //Check if the nearest enemy is close to a collision
            if(abs(possihit.x-bulletx[i]) &gt;  bulletmask[i] || abs(possihit.y-bullety[i]) &gt;  bulletmask[i]) break;
            
            switch(possihit.mid)
            {
                case global.mymid:
                    sfx_play(snd_hit, bulletx[i], bullety[i]);
                    //Handle Cryos Slowdown
                    if(bullettype[i] = spr_cryos)
                        possihit.speed = max(0, possihit.speed-7);

                    //Check if there's a nearby paladin turret
                    var shielded, shielddown;
                    shielded = 1;
                    var drone_active = false;
                    with(obj_paladindrone) 
                    {
                        if(mid = global.mymid)
                        {
                            var my_drone = id;
                            drone_active = true;
                        }
                    }
                    if(possihit.invincible = 1)
                    {
                        shielddown = 1;
                        if(possihit.shield = 0)
                            shielddown = 0;

                        if(drone_active = false)
                        {
                            //Take damage
                            //Take pierce damage
                            if(bullettype[i] = spr_pierce)
                            {
                                possihit.armor -= 3;
                            }
                            //Goliath Hyper Rush damage reduction
                            if(possihit.sprite_index = spr_goliath || possihit.sprite_index = spr_goliath_enemy)
                                if(possihit.ship_ability_active_flag = true)
                                {
                                    bulletdamage[i] *= 0.4;
                                }
                            //Damage calculation and application. Handled differently depending on the bullet type
                            switch(bullettype[i])
                            {
                                case spr_burst:
                                case spr_slash:
                                case spr_whip:
                                case spr_formation:
                                case spr_trigger_shot:
                                case spr_cryos:
                                    //Calculate the damage while applying threshold multiplier and apply it
                                    //Check if under shock effect
                                    if(possihit.ship_status_shocked = false)
                                        possihit.shield -= bulletdamage[i]*possihit.threshold/shielded;
                                    else
                                    {
                                        possihit.shield -= bulletdamage[i]*possihit.threshold/2;
                                        possihit.armor -= bulletdamage[i]*possihit.threshold/2;
                                    }
                                    
                                    //Lower the damage ratio and set the time until it resets to 1:1
                                    possihit.threshold -= 0.08;
                                    if(possihit.threshold &lt; 0.1)
                                        possihit.threshold = 0.1;   
                                    possihit.alarm[9] = THRESHOLD_TIMEOUT;
                                break;
                                default:
                                    //Calculate the damage done and apply it
                                    //Check if under shock effect
                                    if(possihit.ship_status_shocked = false)
                                        possihit.shield -= bulletdamage[i]/shielded;
                                    else
                                    {
                                        possihit.shield -= bulletdamage[i]/2;
                                        possihit.armor -= bulletdamage[i]/2;
                                    }
                                break;                                    
                            }    
                        }
                        else
                        {
                            //Take damage
                            //Take pierce damage
                            if(bullettype[i] = spr_pierce)
                            {
                                possihit.shield -= 3;
                            }
                            //Goliath Hyper Rush damage reduction
                            if(possihit.sprite_index = spr_goliath || possihit.sprite_index = spr_goliath_enemy)
                                if(possihit.ship_ability_active_flag = true)
                                {
                                    bulletdamage[i] *= 0.4;
                                }
                            //Damage calculation and application. Handled differently depending on the bullet type
                            switch(bullettype[i])
                            {
                                case spr_burst:
                                case spr_slash:
                                case spr_whip:
                                case spr_formation:
                                case spr_trigger_shot:
                                case spr_cryos:
                                    //Calculate the damage while applying threshold multiplier and apply it
                                    //Check if under shock effect
                                    if(possihit.ship_status_shocked = false)
                                        my_drone.shield -= bulletdamage[i]*possihit.threshold/shielded;
                                    else
                                    {
                                        my_drone.shield -= bulletdamage[i]*possihit.threshold/2;
                                        possihit.shield -= bulletdamage[i]*possihit.threshold/2;
                                    }
                                    
                                    //Lower the damage ratio and set the time until it resets to 1:1
                                    possihit.threshold -= 0.08;
                                    if(possihit.threshold &lt; 0.1)
                                        possihit.threshold = 0.1;   
                                    possihit.alarm[9] = THRESHOLD_TIMEOUT;
                                break;
                                default:
                                    //Calculate the damage done and apply it
                                    //Check if under shock effect
                                    if(possihit.ship_status_shocked = false)
                                        my_drone.shield -= bulletdamage[i]/shielded;
                                    else
                                    {
                                        possihit.shield -= bulletdamage[i]/2;
                                        my_drone.shield -= bulletdamage[i]/2;
                                    }                            
                                break;                                    
                            }    

                            
                            //Destroy the drone if its shield is used up
                            if(my_drone.shield &lt;= 0)
                            {
                                possihit.shield += my_drone.shield;
                                with(my_drone)
                                    instance_destroy();
                            }
                        }
                        
                        //If there is no more shield, transfer damage to armor
                        if(possihit.shield &lt; 0) 
                        {
                            possihit.armor += possihit.shield;
                            possihit.shield = 0;
                            if(shielddown = 1)
                                obj_mod.ping_send_timer = 0;

                        }
                    }
                    //If there is shield left, create effect
                    if(possihit.shield &gt; 0)
                    {
                        hurt = instance_create(0, 0, obj_hit);
                        hurt.hitdir = point_direction(possihit.x, possihit.y, bulletx[i]-bullethspeed[i], bullety[i]-bulletvspeed[i]);
                        hurt.hurting = possihit;
                    }
                    //Update smoking
                    possihit.smoke = floor(possihit.armor/(possihit.armor_maximum/10));
                    
                    //Shake the screen
                    screen_shake(bulletdamage[i]);
                 
                    //Reset shield regen time
                        possihit.alarm[4] = possihit.regentime;

                    //Check if your ship has been defeated
                    if(possihit.armor &lt;= 0)
                    {
                            //Take note of the player that defeated you
                        possihit.defeatmid = bulletmid[i];
                        //Make a defeat message
                        if(global.ships &gt; 1)
                            random_message(global.othername[bulletmid[i]], global.name, bulletname[i]);
                        else
                            obj_player.message = global.othername[bulletmid[i]]+" ELIMINATED "+global.name+".("+bulletname[i]+")";
                        //Destroy this object
                        with(possihit)
                            event_perform(ev_other, ev_user2);;
                    }
                break;
                default:
                    sfx_play(snd_hit, bulletx[i], bullety[i]);
                                        
                    //Handle Cryos Slowdown
                    if(bullettype[i] = spr_cryos)
                        possihit.speed = max(0, possihit.speed-7);
                    possihit.armor -= bulletdamage[i];
                    //If there is shield left, create effect
                    if(possihit.shieldup = 1)
                    {
                        hurt = instance_create(0, 0, obj_hit);
                        hurt.hitdir = point_direction(possihit.x, possihit.y, bulletx[i]-bullethspeed[i], bullety[i]-bulletvspeed[i]);
                        hurt.hurting = possihit;
                    }
                    //Make the hit ship flash
                    hurt = instance_create(0, 0, obj_ship_flash);
                    hurt.hurting = possihit;  
                    hurt.ship_image = global.selected_ship[possihit.mid]-1;
                break;
            }        
            bulletfree[i] = true;
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
            //Reduce until a new max is found
            for(q = i; q &gt; 0; q -= 1)
            {
             if(bulletfree[q] = false) break;
             bulletmax -= 1;
            }
            ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
            ending.direction = bulletdirection[i];
            ending.mid = bulletmid[i];
            switch(bullettype[i])
            {
                case spr_snake_body:
                case spr_whip:
                    ending.image_speed = 0;
                    if(bulletblend[i] = c_red)
                        ending.image_index = 0;
                    else
                        ending.image_index = 1;                    
                    ending.image_angle = ending.direction;                        
                break;
                case spr_cryos:
                    ending.target_mid = possihit.mid;
                    ending.x = possihit.x;
                    ending.y = possihit.y;
                break;
                case spr_nova:
                    if(bulletname[i] = "Nova ")
                        if(bullethspeed[i] = 0)
                            if(bulletvspeed[i] = 0)
                                nova_count[bulletmid[i]] -= 1;
                break;
            }
        break;
    }


    //Check barrier collisions
    switch(bulletblend[i])
    {
        case global.allycolor:
            if(instance_number(obj_barrier_enemy) &lt; 1) break;
            //Find the closest enemy to the bullet
            possihit = instance_nearest(bulletx[i], bullety[i], obj_barrier_enemy);
            //Check if the nearest enemy is close to a collision
            if(abs(possihit.x-bulletx[i]) &gt; 250 || abs(possihit.y-bullety[i]) &gt; 250) break;
            //Check if there is a collision
            if(!collision_circle(bulletx[i], bullety[i], 5, possihit, 1, 0)) break;
            //Free this index
            bulletfree[i] = true;
            if(possihit.sprite_index = spr_solus)
                possihit.owner.absorb += 0.20;
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
                //Reduce until a new max is found
                for(q = i; q &gt; 0; q -= 1)
                {
                    if(bulletfree[q] = false) break;
                    bulletmax -= 1;
                }
            ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
            ending.direction = bulletdirection[i];
            ending.mid = bulletmid[i];
            switch(bullettype[i])
            {
                case spr_snake_body:
                case spr_whip:
                    ending.image_speed = 0;
                    if(bulletblend[i] = c_red)
                        ending.image_index = 0;
                    else
                        ending.image_index = 1;                    
                    ending.image_angle = ending.direction;                        
                break;
                case spr_cryos:
                    ending.target_mid = possihit.mid;
                    ending.x = possihit.x;
                    ending.y = possihit.y;
                break;
                case spr_nova:
                    if(bulletname[i] = "Nova ")
                        if(bullethspeed[i] = 0)
                            if(bulletvspeed[i] = 0)
                                nova_count[bulletmid[i]] -= 1;
                break;
            }
        break;
        case global.enemycolor:
            if(instance_number(obj_barrier) &lt; 1) break;
            //Find the closest enemy to the bullet
            possihit = instance_nearest(bulletx[i], bullety[i], obj_barrier);
            //Check if the nearest enemy is close to a collision
            if(abs(possihit.x-bulletx[i]) &gt; 250 || abs(possihit.y-bullety[i]) &gt; 250) break;
            //Check if there is a collision
            if(!collision_circle(bulletx[i], bullety[i], 5, possihit, 1, 0)) break;
            //Free this index
            bulletfree[i] = true;
            if(possihit.sprite_index = spr_solus)
                possihit.owner.absorb += 0.20;
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
                //Reduce until a new max is found
                for(q = i; q &gt; 0; q -= 1)
                {
                    if(bulletfree[q] = false) break;
                    bulletmax -= 1;
                }
            ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
            ending.direction = bulletdirection[i];
            ending.mid = bulletmid[i];
            switch(bullettype[i])
            {
                case spr_snake_body:
                case spr_whip:
                    ending.image_speed = 0;
                    if(bulletblend[i] = c_red)
                        ending.image_index = 0;
                    else
                        ending.image_index = 1;                    
                    ending.image_angle = ending.direction;                        
                break;
                case spr_cryos:
                    ending.target_mid = possihit.mid;
                    ending.x = possihit.x;
                    ending.y = possihit.y;
                break;
                case spr_nova:
                    if(bulletname[i] = "Nova ")
                        if(bullethspeed[i] = 0)
                            if(bulletvspeed[i] = 0)
                                nova_count[bulletmid[i]] -= 1;
               break;
            }
        break;
    }
    //Lower the bullet's life
    bulletlife[i] -= 1;
 
 
    //Wall collision
    if(bulletname[i] = "Horizon " || ( ( bulletx[i] &lt;= 0 || bulletx[i] &gt;= room_width || bullety[i] &lt;= 0 || bullety[i] &gt;= room_height ) &amp;&amp; bulletname[i] = "Horizon" ) ) continue;
    if(wallposition[floor(bulletx[i]/32), floor(bullety[i]/32)] = false) continue;
    //Free this index
    bulletfree[i] = true;
    //Reduce the bullet max if this is the last bullet
    if(bulletmax = i)
    //Reduce until a new max is found
        for(q = i; q &gt; 0; q -= 1)
        {
            if(bulletfree[q] = false) break;
            bulletmax -= 1;
        }
    ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
    ending.direction = bulletdirection[i];
    ending.mid = bulletmid[i];
            switch(bullettype[i])
            {
                case spr_snake_body:
                case spr_whip:
                    ending.image_speed = 0;
                    if(bulletblend[i] = c_red)
                        ending.image_index = 0;
                    else
                        ending.image_index = 1;                    
                    ending.image_angle = ending.direction;                        
                break;
                case spr_cryos:
                    ending.target_mid = 9;
                break;
                case spr_nova:
                    if(bulletname[i] = "Nova ")
                        if(bullethspeed[i] = 0)
                            if(bulletvspeed[i] = 0)
                                nova_count[bulletmid[i]] -= 1;
                break;
            }
}





</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!surface_exists(bloom))
{
    bloom=surface_create(room_width/2, room_height/2);
    surface_set_target(bloom);
    draw_clear(c_black);
    surface_reset_target();
}
if(!surface_exists(bloom2))
{    
    bloom2=surface_create(room_width/4, room_height/4);
    surface_set_target(bloom2);
    draw_clear(c_black);
    surface_reset_target();
}
if(!surface_exists(bloom3))
{
    bloom3=surface_create(room_width/8, room_height/8);
    surface_set_target(bloom3);
    draw_clear(c_black);
    surface_reset_target();
}
if(!surface_exists(bloom4))
{
    bloom4=surface_create(room_width/16, room_height/16);
    surface_set_target(bloom4);
    draw_clear(c_black);
    surface_reset_target();
}
if(!surface_exists(bloom5))
{
    bloom5=surface_create(room_width/32, room_height/32);
    surface_set_target(bloom5);
    draw_clear(c_black);
    surface_reset_target();
}    
// Draws Lamp and then wall to the bloom surfaces
surface_set_target(bloom);
d3d_set_projection_ortho(0,0,room_width,room_height,0);
draw_set_color(c_black);
draw_set_alpha(0.8);
draw_rectangle(0,0,room_width,room_height,0); // Clear the surface to clear the "trails" effect
draw_set_alpha(1);

//Draw the bullets
for(i = 1; i &lt;= bulletmax; i += 1)
{
    if(bulletfree[i] = true) continue;
    switch(bullettype[i])
    {
        case spr_cryos:
            draw_sprite_ext(bullettype[i], bulletsingle[i], bulletx[i], bullety[i], 1, 1, bulletdirection[i]+bulletlife[i]*4, c_white, 1);    
        break;
        case spr_nova:
            draw_sprite_ext(bullettype[i], bulletsingle[i], bulletx[i], bullety[i], 1, 1, bulletdirection[i]+(1200-bulletlife[i])*4, c_white, 1);    
        break;
        default:
            draw_sprite_ext(bullettype[i], bulletsingle[i], bulletx[i], bullety[i], 1, 1, bulletdirection[i], c_white, 1);    
        break;
    }
}
with(prnt_enemyenergy)
    draw_sprite_ext(sprite_index, image_index, x, y, image_xscale, image_yscale, image_angle, c_white,image_alpha);
with(prnt_allyenergy)
    draw_sprite_ext(sprite_index, image_index, x, y, image_xscale, image_yscale, image_angle, c_white,image_alpha);
with(prnt_bloom_attack)
    draw_sprite_ext(sprite_index, image_index, x, y, image_xscale, image_yscale, image_angle, c_white,image_alpha);
with(obj_generic_fade)
    draw_sprite_ext(sprite_index, image_index, x, y, image_xscale, image_yscale, image_angle, c_white,image_alpha);
    
surface_reset_target();

surface_set_target(bloom2);
draw_surface_ext(bloom,0,0,0.5,0.5,0,c_white,1);
surface_reset_target();

surface_set_target(bloom3);
draw_surface_ext(bloom2,0,0,0.5,0.5,0,c_white,1);
surface_reset_target();

surface_set_target(bloom4);
draw_surface_ext(bloom3,0,0,0.5,0.5,0,c_white,1);
surface_reset_target();

surface_set_target(bloom5);
draw_surface_ext(bloom4,0,0,0.5,0.5,0,c_white,1);
surface_reset_target();


//Draw the bullets
for(i = 1; i &lt;= bulletmax; i += 1)
{
    if(bulletfree[i] = true) continue;
    switch(bullettype[i])
    {
        case spr_cryos:
            draw_sprite_ext(bullettype[i], bulletsingle[i], bulletx[i], bullety[i], 1, 1, bulletdirection[i]+bulletlife[i]*4, c_white, 1);    
        break;
        case spr_nova:
            draw_sprite_ext(bullettype[i], bulletsingle[i], bulletx[i], bullety[i], 1, 1, bulletdirection[i]+(1200-bulletlife[i])*4, c_white, 1);    
        break;
        default:
            draw_sprite_ext(bullettype[i], bulletsingle[i], bulletx[i], bullety[i], 1, 1, bulletdirection[i], c_white, 1);    
        break;
    }
}
with(prnt_enemyenergy)
    draw_self();
with(prnt_allyenergy)
    draw_self();

draw_set_blend_mode(bm_add);
draw_surface_general(bloom, view_xview[0]/2, view_yview[0]/2, view_wview[0]/2, view_hview[0]/2, view_xview[0], view_yview[0], 2, 2, 0, c_white, c_white, c_white, c_white, 0.5);
draw_surface_general(bloom2, view_xview[0]/4, view_yview[0]/4, view_wview[0]/4, view_hview[0]/4, view_xview[0], view_yview[0], 4, 4, 0, c_white, c_white, c_white, c_white, 0.5);
draw_surface_general(bloom3, view_xview[0]/8, view_yview[0]/8, view_wview[0]/8, view_hview[0]/8, view_xview[0], view_yview[0], 8, 8, 0, c_white, c_white, c_white, c_white, 0.5);
draw_surface_general(bloom4, view_xview[0]/16, view_yview[0]/16, view_wview[0]/16, view_hview[0]/16, view_xview[0], view_yview[0], 16, 16, 0, c_white, c_white, c_white, c_white, 0.5);
draw_surface_general(bloom5, view_xview[0]/32, view_yview[0]/32, view_wview[0]/32, view_hview[0]/32, view_xview[0], view_yview[0], 32, 32, 0, c_white, c_white, c_white, c_white, 0.5);
draw_set_blend_mode(bm_normal);


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
