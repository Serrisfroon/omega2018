<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//This object will replace the need for most primary shots, solus shots, and formation shots
bloom=surface_create(room_width/2, room_height/2);
bloom2=surface_create(room_width/4, room_height/4);
bloom3=surface_create(room_width/8, room_height/8);
bloom4=surface_create(room_width/16, room_height/16);
bloom5=surface_create(room_width/32, room_height/32);
surface_set_target(bloom);
draw_clear(c_black);
surface_reset_target();

surface_set_target(bloom2);
draw_clear(c_black);
surface_reset_target();

surface_set_target(bloom3);
draw_clear(c_black);
surface_reset_target();

surface_set_target(bloom4);
draw_clear(c_black);
surface_reset_target();

surface_set_target(bloom5);
draw_clear(c_black);
surface_reset_target();





//Initialize bullet attributes

for(i = 0; i &lt;=2000; i += 1)
{
 //This bullet index is free
 bulletfree[i] = true;
 //The bullet type is also the sprite
 bullettype[i] = spr_needle;
 //The bullet's coordinates
 bulletx[i] = 0;
 bullety[i] = 0;
 bulletgraze[i] = 0;
 //The bullet's vspeed and hspeed
 bullethspeed[i] = 0;
 bulletvspeed[i] = 0;
 //The bullet's direction. Used for drawing at the right angle
 bulletdirection[i] = 0;
 //The bullet's blend atribute. It shows what team it belongs to
 bulletblend[i] = c_red;
 //The bullet's life. Each step, it is lowered by one. At 0, this index is freed.
 bulletlife[i] = 0;
 //The bullet's damage. Stored to make loops much easier
 bulletdamage[i] = 0;
 //The bullet's death object. When a bullet has a collision, this object is created.
 bulletend[i] = obj_generic_hit;
 //The bullet's multiplayer id. This will trace the bullet to the player who shot it.
 bulletmid[i] = -1;
 //The bullet's name. Stored for ease of use
 bulletname[i] = "Needle";
 //The bullet's mask radius. Used for collision checking with ships
 bulletmask[i] = 5;
}
//Keeps track of the highest bullet index
bulletmax = 0;

//Create a psuedo-map of the room of all wall block locations
//Initialize the wall check for each 32x32 area of the map. Set it to false.
for(i = 0; i &lt;= ceil(room_width/32); i += 1)
{
 for(q = 0; q &lt;= ceil(room_height/32); q += 1)
 {
  wallposition[i, q] = false;
 }
}
//Set the wall check to true where a wall exists
with(obj_wall)
{
 obj_bulletcontrol.wallposition[x/32, y/32] = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Update all bullets
for(i = 1; i &lt;= bulletmax; i += 1)
{
    //Skip this loop if the index is free
    if(bulletfree[i] = true) continue;
 
    //Update the bullet's position
    bulletx[i] += bullethspeed[i];
    bullety[i] += bulletvspeed[i];
 
    //If this bullet's life is over, free the index and continue to the next loop
    //Also check if the bullet has left the room's boundaries
    if(bulletname[i] = "Horizon " || bulletname[i] = "Horizon")
    {
        if(bulletlife[i] &lt;= 0)
        {
            bulletfree[i] = true; 
               
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
            //Reduce until a new max is found
                for(q = i; q &gt; 0; q -= 1)
                {
                    if(bulletfree[q] = false) break;
                    bulletmax -= 1;
                }
            continue;
        } 
    }
    else
        if(bulletlife[i] &lt;= 0 || bulletx[i] &lt;= 0 || bulletx[i] &gt;= room_width || bullety[i] &lt;= 0 || bullety[i] &gt;= room_height)
        {
            bulletfree[i] = true;

            //Create a stasis field if it is a stasis bullet
            if(bullettype[i] = spr_whip || bullettype[i] = spr_snake_body || bullettype[i] = spr_stasis)
            {         
                ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
                ending.direction = bulletdirection[i];
                ending.image_angle = ending.direction;
                ending.mid = bulletmid[i];
                if(bullettype[i] = spr_snake_body || bullettype[i] = spr_whip)
                {
                    ending.image_speed = 0;
                    if(bulletblend[i] = c_red)
                        ending.image_index = 0;
                    else
                        ending.image_index = 1;                    
                    ending.image_angle = ending.direction;    
                }
            }
            else
            {
                ending = instance_create(bulletx[i], bullety[i], obj_generic_fade);
                ending.direction = bulletdirection[i];
                ending.hspeed = bullethspeed[i];
                ending.vspeed = bulletvspeed[i];
                ending.sprite_index = bullettype[i];
                ending.mid = bulletmid[i];
            }
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
                //Reduce until a new max is found
                for(q = i; q &gt; 0; q -= 1)
                {
                    if(bulletfree[q] = false) break;
                    bulletmax -= 1;
                }
            continue;
        }
    //Check according to blend, which tells team
    switch(bulletblend[i])
    {
        //Check enemies if this is an allied bullet
        case global.allycolor:
            //Find the closest enemy to the bullet
            possihit = instance_nearest(bulletx[i], bullety[i], prnt_allenemy);
            //Break the switch statement if there are no allys
            if(possihit = noone) break;
            if(possihit.object_index = obj_ship_placeholder || possihit.object_index = obj_teleport || possihit.object_index = obj_deadship) break;
            //Check if the nearest enemy is close to a collision
            if(abs(possihit.x-bulletx[i]) &gt; bulletmask[i] || abs(possihit.y-bullety[i]) &gt; bulletmask[i]) break;
            
            sfx_play(snd_hit, bulletx[i], bullety[i]);
            //Take damage
            if(bullettype[i] = spr_pierce)
                possihit.armor -= 3;
            possihit.shield -= bulletdamage[i];
            if(possihit.shield &lt; 0)
            {
                if(possihit.sprite_index = spr_turretbase)
                {
                    if(point_distance(global.playership[bulletmid[i]].x, global.playership[bulletmid[i]].y, possihit.x, possihit.y) &lt;= 400)
                        bulletdamage[i] = 5;
                    else
                        bulletdamage[i] = 0;
                        
                    possihit.shield = 0;
                    if(possihit.reset = 0 &amp;&amp; bulletdamage[i] = 5)
                    {
                        possihit.armor -= bulletdamage[i];
                        possihit.reset = 1;
                        possihit.alarm[0] = 10;
                    }
                }
                else
                {   
                    possihit.shield = 0;
                    possihit.armor -= bulletdamage[i];
                }
            }
        
            //Update smoking
            if(possihit.sprite_index != spr_turretbase &amp;&amp; room = rm_practice)
                possihit.smoke = floor(possihit.armor/(possihit.maxarmor/10));

            //If there is shield left, create effect
            if(possihit.shieldup = 1)
            {
                hurt = instance_create(0, 0, obj_hit);
                hurt.hitdir = point_direction(possihit.x, possihit.y, bulletx[i]-bullethspeed[i], bullety[i]-bulletvspeed[i]);
                hurt.hurting = possihit;
            }
            bulletfree[i] = true;
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
            //Reduce until a new max is found
                for(q = i; q &gt; 0; q -= 1)
                {
                    if(bulletfree[q] = false) break;
                    bulletmax -= 1;
                }
            ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
            ending.direction = bulletdirection[i];
            ending.mid = bulletmid[i];
            if(bullettype[i] = spr_snake_body || bullettype[i] = spr_whip)
            {
                ending.image_speed = 0;
                if(bulletblend[i] = c_red)
                    ending.image_index = 0;
                else
                    ending.image_index = 1;                    
                ending.image_angle = ending.direction;    
            }
        break;
        //Check allies if this is an enemy bullet
        case global.enemycolor:
            //Find the closest enemy to the bullet
            possihit = instance_nearest(bulletx[i], bullety[i], prnt_ally);
            //Break the switch statement if there are no allys
            if(possihit = noone) break;
            if(possihit.object_index = obj_ship_placeholder || possihit.object_index = obj_teleport || possihit.object_index = obj_deadship) break;
            //Check if the nearest enemy is close to a collision
            //Also check if the closest ally is actually an error check
            //Check if the nearest enemy is close to a collision
            if(abs(possihit.x-bulletx[i]) &gt;  bulletmask[i] || abs(possihit.y-bullety[i]) &gt;  bulletmask[i]) break;
            
            switch(possihit.mid)
            {
                case global.mymid:
                    sfx_play(snd_hit, bulletx[i], bullety[i]);
                    //Intercept turrets
                    if(possihit.sprite_index = spr_turretbase)
                    {
                        if(point_distance(global.playership[bulletmid[i]].x, global.playership[bulletmid[i]].y, possihit.x, possihit.y) &lt;= 400)
                            bulletdamage[i] = 5;
                        else
                            bulletdamage[i] = 0;
                        
                        if(possihit.reset = 0 &amp;&amp; bulletdamage[i] = 5)
                        {
                            possihit.armor -= bulletdamage[i];
                            possihit.reset = 1;
                            possihit.alarm[0] = 10;
                        }
                        break;
                    }
                    //Check if there's a nearby paladin turret
                    var shielded, shielddown;
                    shielded = 1;
                    if(instance_exists(obj_turret))
                        if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
                            shielded = 2;
                    if(possihit.invincible = 1 &amp;&amp; possihit.beserk = 0)
                    {
                            shielddown = 1;
                            if(possihit.shield = 0)
                                shielddown = 0;

                        //Take damage
                        //Take pierce damage
                        if(bullettype[i] = spr_pierce)
                        {
                            possihit.armor -= 3;
                            global.damagetaken[global.mymid] += 3;
                            global.damagedealt[bulletmid[i]] += 3;                        
                        }
                        //Goliath Hyper Rush damage reduction
                        if(possihit.sprite_index = spr_goliath || possihit.sprite_index = spr_goliath_enemy)
                            if(possihit.ship_ability_active_flag = true)
                            {
                                bulletdamage[i] *= 0.4;
                            }
                        //If burst, slash, or whip, apply threshold damage
                        if((bullettype[i] = spr_burst || bullettype[i] = spr_slash || bullettype[i] = spr_whip || bulletname[i] = "Formation"))
                        {
                            //Check if under shock effect
                            if(possihit.ship_status_shocked = false)
                                possihit.shield -= bulletdamage[i]*possihit.threshold/shielded;
                            else
                            {
                                possihit.shield -= bulletdamage[i]*possihit.threshold/2;
                                possihit.armor -= bulletdamage[i]*possihit.threshold/2;
                            }
                            global.damagetaken[global.mymid] += bulletdamage[i]*possihit.threshold/shielded;
                            global.damagedealt[bulletmid[i]] += bulletdamage[i]*possihit.threshold/shielded;
                  
                            switch(bullettype[i])
                            {
                                case spr_burst:
                                case spr_slash:
                                case spr_whip:
                                case spr_formation:
                                case spr_trigger_shot:
                                    possihit.threshold -= 0.08;
                                    possihit.alarm[9] = 60;
                                break;
                            }    
                            if(possihit.threshold &lt; 0.1)
                                possihit.threshold = 0.1;   
                        } 
                        //Otherwise, calculate damage normally
                        else
                        {
                            //Check if under shock effect
                            if(possihit.ship_status_shocked = false)
                                possihit.shield -= bulletdamage[i]/shielded;
                            else
                            {
                                possihit.shield -= bulletdamage[i]/2;
                                possihit.armor -= bulletdamage[i]/2;
                            }
                        }
                        //If there is no more shield, transfer damage to armor
                        if(possihit.shield &lt; 0) 
                        {
                            possihit.armor += possihit.shield;
                            possihit.shield = 0;
                            if(shielddown = 1)
                                obj_mod.sendping = 0;

                        }
                    }
                    //If there is shield left, create effect
                    if(possihit.shield &gt; 0)
                    {
                        hurt = instance_create(0, 0, obj_hit);
                        hurt.hitdir = point_direction(possihit.x, possihit.y, bulletx[i]-bullethspeed[i], bullety[i]-bulletvspeed[i]);
                        hurt.hurting = possihit;
                    }
                    //Update smoking
                    possihit.smoke = floor(possihit.armor/(possihit.maxarmor/10));
         
                    //Reset shield regen time
                        possihit.alarm[4] = possihit.regentime;

                    //Check if your ship has been defeated
                    if(possihit.armor &lt;= 0 &amp;&amp; possihit.beserk = 0)
                    {
                        if(!instance_exists(obj_practicemod))
                        {
                            //Take note of the player that defeated you
                            possihit.defeatmid = bulletmid[i];
                            //Make a defeat message
                            if(global.ships &gt; 1)
                                random_message(global.othername[bulletmid[i]], global.name, bulletname[i]);
                            else
                                obj_ship.message = global.othername[bulletmid[i]]+" ELIMINATED "+global.name+".("+bulletname[i]+")";
                        }
                        if(global.shipselect != 2)
                        {
                            //Destroy this object
                            with(possihit)
                            instance_destroy();
                        }
                        else
                        {
                            possihit.armor = 0;
                            possihit.shield = 0;
                            possihit.beserk = 1;
                            possihit.energygain = 0.8;
                            possihit.energy = 100;
                            possihit.cooldown = 1;
                            obj_mod.sendping = 0;
                            possihit.beserkeffect = instance_create(x, y, obj_beserkeffect);
                            possihit.alarm[11] = 300;
                        }
                    }
                break;
                default:
                    sfx_play(snd_hit, bulletx[i], bullety[i]);
                    //Intercept turrets
                    if(possihit.sprite_index = spr_turretbase)
                    {
                        if(point_distance(global.playership[bulletmid[i]].x, global.playership[bulletmid[i]].y, possihit.x, possihit.y) &lt;= 400)
                            bulletdamage[i] = 5;
                        else
                            bulletdamage[i] = 0;
                        if(possihit.reset = 0 &amp;&amp; bulletdamage[i] = 5)
                        {
                            possihit.armor -= bulletdamage[i];
                            possihit.reset = 1;
                            possihit.alarm[0] = 10;
                        }
                        break;
                    }   
                    
                    //Take damage
                    if(bullettype[i] = spr_pierce)
                        possihit.armor -= 3;
                    possihit.armor -= bulletdamage[i];
                    //If there is shield left, create effect
                    if(possihit.shieldup = 1)
                    {
                        hurt = instance_create(0, 0, obj_hit);
                        hurt.hitdir = point_direction(possihit.x, possihit.y, bulletx[i]-bullethspeed[i], bullety[i]-bulletvspeed[i]);
                        hurt.hurting = possihit;
                    }
                break;
            }        
            bulletfree[i] = true;
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
            //Reduce until a new max is found
            for(q = i; q &gt; 0; q -= 1)
            {
             if(bulletfree[q] = false) break;
             bulletmax -= 1;
            }
            ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
            ending.direction = bulletdirection[i];
            ending.mid = bulletmid[i];
            if(bullettype[i] = spr_snake_body || bullettype[i] = spr_whip)
            {
                ending.image_speed = 0;
                if(bulletblend[i] = c_red)
                    ending.image_index = 0;
                else
                    ending.image_index = 1;                    
                ending.image_angle = ending.direction;    
            }
        break;
    }


    //Check barrier collisions
    switch(bulletblend[i])
    {
        case global.allycolor:
            if(instance_number(obj_barrier_enemy) &lt; 1) break;
            //Find the closest enemy to the bullet
            possihit = instance_nearest(bulletx[i], bullety[i], obj_barrier_enemy);
            //Check if the nearest enemy is close to a collision
            if(abs(possihit.x-bulletx[i]) &gt; 250 || abs(possihit.y-bullety[i]) &gt; 250) break;
            //Check if there is a collision
            if(!collision_circle(bulletx[i], bullety[i], 5, possihit, 1, 0)) break;
            //Free this index
            bulletfree[i] = true;
            if(possihit.sprite_index = spr_solus)
                possihit.owner.absorb += 0.20;
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
                //Reduce until a new max is found
                for(q = i; q &gt; 0; q -= 1)
                {
                    if(bulletfree[q] = false) break;
                    bulletmax -= 1;
                }
            ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
            ending.direction = bulletdirection[i];
            ending.mid = bulletmid[i];
            if(bullettype[i] = spr_snake_body || bullettype[i] = spr_whip)
            {
                ending.image_speed = 0;
                if(bulletblend[i] = c_red)
                    ending.image_index = 0;
                else
                    ending.image_index = 1;                    
                ending.image_angle = ending.direction;    
            }
        break;
        case global.enemycolor:
            if(instance_number(obj_barrier) &lt; 1) break;
            //Find the closest enemy to the bullet
            possihit = instance_nearest(bulletx[i], bullety[i], obj_barrier);
            //Check if the nearest enemy is close to a collision
            if(abs(possihit.x-bulletx[i]) &gt; 250 || abs(possihit.y-bullety[i]) &gt; 250) break;
            //Check if there is a collision
            if(!collision_circle(bulletx[i], bullety[i], 5, possihit, 1, 0)) break;
            //Free this index
            bulletfree[i] = true;
            if(bulletgraze[i] = 1)
            {
                obj_ship.energy += 4;
                if(obj_ship.energy &gt; 100)
                    obj_ship.energy = 100;
                repeat(3)
                    effect_create_below(ef_spark, bulletx[i]-7+random(14), bullety[i]-7+random(14), 0, c_aqua);
                sfx_play(snd_graze, bulletx[i], bullety[i]);
                bulletgraze[i] = 0;
            }
            if(possihit.sprite_index = spr_solus)
                possihit.owner.absorb += 0.20;
            //Reduce the bullet max if this is the last bullet
            if(bulletmax = i)
                //Reduce until a new max is found
                for(q = i; q &gt; 0; q -= 1)
                {
                    if(bulletfree[q] = false) break;
                    bulletmax -= 1;
                }
            ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
            ending.direction = bulletdirection[i];
            ending.mid = bulletmid[i];
            if(bullettype[i] = spr_snake_body || bullettype[i] = spr_whip)
            {
                ending.image_speed = 0;
                if(bulletblend[i] = c_red)
                    ending.image_index = 0;
                else
                    ending.image_index = 1;                    
                ending.image_angle = ending.direction;    
            }
        break;
    }
    //Lower the bullet's life
    bulletlife[i] -= 1;
 
 
    //Wall collision
    if(bulletname[i] = "Horizon " || ( ( bulletx[i] &lt;= 0 || bulletx[i] &gt;= room_width || bullety[i] &lt;= 0 || bullety[i] &gt;= room_height ) &amp;&amp; bulletname[i] = "Horizon" ) ) continue;
    if(wallposition[floor(bulletx[i]/32), floor(bullety[i]/32)] = false) continue;
    //Free this index
    bulletfree[i] = true;
    //Reduce the bullet max if this is the last bullet
    if(bulletmax = i)
    //Reduce until a new max is found
        for(q = i; q &gt; 0; q -= 1)
        {
            if(bulletfree[q] = false) break;
            bulletmax -= 1;
        }
    ending = instance_create(bulletx[i], bullety[i], bulletend[i]);
    ending.direction = bulletdirection[i];
    ending.mid = bulletmid[i];
}





</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!surface_exists(bloom))
{
    bloom=surface_create(room_width/2, room_height/2);
    surface_set_target(bloom);
    draw_clear(c_black);
    surface_reset_target();
}
if(!surface_exists(bloom2))
{    
    bloom2=surface_create(room_width/4, room_height/4);
    surface_set_target(bloom2);
    draw_clear(c_black);
    surface_reset_target();
}
if(!surface_exists(bloom3))
{
    bloom3=surface_create(room_width/8, room_height/8);
    surface_set_target(bloom3);
    draw_clear(c_black);
    surface_reset_target();
}
if(!surface_exists(bloom4))
{
    bloom4=surface_create(room_width/16, room_height/16);
    surface_set_target(bloom4);
    draw_clear(c_black);
    surface_reset_target();
}
if(!surface_exists(bloom5))
{
    bloom5=surface_create(room_width/32, room_height/32);
    surface_set_target(bloom5);
    draw_clear(c_black);
    surface_reset_target();
}    
// Draws Lamp and then wall to the bloom surfaces
surface_set_target(bloom);
d3d_set_projection_ortho(0,0,room_width,room_height,0);
draw_set_color(c_black);
draw_set_alpha(0.8);
draw_rectangle(0,0,room_width,room_height,0); // Clear the surface to clear the "trails" effect
draw_set_alpha(1);

//Draw the bullets
for(i = 1; i &lt;= bulletmax; i += 1)
{
    if(bulletfree[i] = true) continue;
    draw_sprite_ext(bullettype[i], bulletsingle[i], bulletx[i], bullety[i], 1, 1, bulletdirection[i], c_white, 1);
}
with(prnt_enemyenergy)
    draw_sprite_ext(sprite_index, image_index, x, y, image_xscale, image_yscale, image_angle, c_white,image_alpha);
with(prnt_allyenergy)
    draw_sprite_ext(sprite_index, image_index, x, y, image_xscale, image_yscale, image_angle, c_white,image_alpha);
with(obj_generic_fade)
    draw_sprite_ext(sprite_index, image_index, x, y, image_xscale, image_yscale, image_angle, c_white,image_alpha);
    
surface_reset_target();

surface_set_target(bloom2);
draw_surface_ext(bloom,0,0,0.5,0.5,0,c_white,1);
surface_reset_target();

surface_set_target(bloom3);
draw_surface_ext(bloom2,0,0,0.5,0.5,0,c_white,1);
surface_reset_target();

surface_set_target(bloom4);
draw_surface_ext(bloom3,0,0,0.5,0.5,0,c_white,1);
surface_reset_target();

surface_set_target(bloom5);
draw_surface_ext(bloom4,0,0,0.5,0.5,0,c_white,1);
surface_reset_target();


//Draw the bullets
for(i = 1; i &lt;= bulletmax; i += 1)
{
    if(bulletfree[i] = true) continue;
    draw_sprite_ext(bullettype[i], bulletsingle[i], bulletx[i], bullety[i], 1, 1, bulletdirection[i], c_white, 1);
}
with(prnt_enemyenergy)
    draw_self();
with(prnt_allyenergy)
    draw_self();

draw_set_blend_mode(bm_add);
draw_surface_general(bloom, view_xview[0]/2, view_yview[0]/2, view_wview[0]/2, view_hview[0]/2, view_xview[0], view_yview[0], 2, 2, 0, c_white, c_white, c_white, c_white, 0.5);
draw_surface_general(bloom2, view_xview[0]/4, view_yview[0]/4, view_wview[0]/4, view_hview[0]/4, view_xview[0], view_yview[0], 4, 4, 0, c_white, c_white, c_white, c_white, 0.5);
draw_surface_general(bloom3, view_xview[0]/8, view_yview[0]/8, view_wview[0]/8, view_hview[0]/8, view_xview[0], view_yview[0], 8, 8, 0, c_white, c_white, c_white, c_white, 0.5);
draw_surface_general(bloom4, view_xview[0]/16, view_yview[0]/16, view_wview[0]/16, view_hview[0]/16, view_xview[0], view_yview[0], 16, 16, 0, c_white, c_white, c_white, c_white, 0.5);
draw_surface_general(bloom5, view_xview[0]/32, view_yview[0]/32, view_wview[0]/32, view_hview[0]/32, view_xview[0], view_yview[0], 32, 32, 0, c_white, c_white, c_white, c_white, 0.5);
draw_set_blend_mode(bm_normal);


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
