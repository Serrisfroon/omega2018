<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_shipmask</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>targeted_enemy = -1;
player_object = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Exit camera control is the player is not active
if(player_object = -1)
    exit;

//Hold the player coordinates locally
var player_x = player_object.x;
var player_y = player_object.y;
//Find the enemy nearest to the player and measure the distance to it
var nearest_enemy = instance_nearest(mouse_x, mouse_y, obj_dummy_enemy);

//If the nearest enemy is different than the target, change the target
if(targeted_enemy != nearest_enemy)
{
    //Set the new target flag to true
    var new_target = true;
    //Calculate the distance to the enemy
    var distance_to_enemy = point_distance(player_x, player_y, nearest_enemy.x, nearest_enemy.y);
}
else
{
    //Set the new target flag to false
    var new_target = false;
    //Calculate the distance to the enemy
    var distance_to_enemy = point_distance(player_x, player_y, targeted_enemy.x, targeted_enemy.y);
}


//Check if the enemy is close enough to lock on
if(distance_to_enemy &lt; 900)
{  
    //Handle the camera to track the player, the target, and the mouse

    //If this is a new target, update the target variable and make an effect
    if(new_target = true)
    {
        targeted_enemy = nearest_enemy;                         //Update the targeted enemy
        obj_mod.targeted_object = targeted_enemy;               //Send the target to obj_mod
        
        //Destroy any lockon effect and create a new one
        with(obj_lockoncursor)
            instance_destroy();
        newlockon = instance_create(0, 0, obj_lockoncursor);    
        newlockon.target = targeted_enemy;
        newlockon.direction = obj_mod.cursor_rotation[2];
    }
    
    obj_mod.distance_to_target = floor(distance_to_enemy/33);         //Send the distance to the target to obj_mod

    
    //Calculate the difference in x and y values between the target and the player
    var ship_difference_x = nearest_enemy.x-player_x;
    var ship_difference_y = nearest_enemy.y-player_y;
     
    //Set the camera base coordinates to be halfway between the player and the target
    var camera_x = player_x + ship_difference_x/2;
    var camera_y = player_y + ship_difference_y/2;
    
    //Calculate the change needed in camera size
    //The view needs to contain both the target and the ship, and have 400 pixels extra space
    var camera_width_change = view_wview[0] - abs(ship_difference_x) - 400;
    var camera_height_change = view_hview[0] - abs(ship_difference_y) - 400;
    
    //Increase the camera size if the view is too small horizontally
    if(camera_width_change &lt; 0 || camera_height_change &lt; 0)
    {
        view_wview[0] += 8;
        view_hview[0] += 5;
    }
    else
    {
        //Decrease the camera size if it's more than 100 pixels too large horizontally
        if(camera_width_change &gt; 100 || camera_height_change &gt; 100)
        {
            if(view_wview[0] &gt; 1200)
            {
                view_wview[0] -= 8;
                view_hview[0] -= 5;
            }
        }
    }     
}
else
{
    //Handle the camera to track the player and the mouse
    
    //Reset the targeted enemy and the distance to the enemy
    targeted_enemy = -1;
    obj_mod.targeted_object = -1;
    distance_to_enemy = 900;
    
    //Set the camera base coordinates to the player's
    var camera_x = player_x;
    var camera_y = player_y;
    
    //Decrease the camera size if it's too large horizontally
    if(view_wview[0] &gt; 1200)
    {
        view_wview[0] -= 8;
        view_hview[0] -= 5;
    }
}

//Calculate the direction and distance to the mouse
var direction_to_mouse = point_direction(x, y, mouse_x, mouse_y);
var distance_to_mouse = point_distance(x, y, mouse_x, mouse_y);

//Calculate the position of the camera to pan to
var camera_pan_x = camera_x + lengthdir_x(min(96, distance_to_mouse), direction_to_mouse);
var camera_pan_y = camera_y + lengthdir_y(min(96, distance_to_mouse), direction_to_mouse);

//Pan the camera towards that position
x += (camera_pan_x-x)/25;
y += (camera_pan_y-y)/25;

//Set the view position to be at the camera's position, but stay inside the room
view_xview = clamp(x - (view_wview/2), 0, room_width-view_wview);
view_yview = clamp(y - (view_hview/2), 0, room_height-view_hview);


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
