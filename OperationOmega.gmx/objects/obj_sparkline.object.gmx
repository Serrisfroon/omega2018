<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_sparkline</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1</depth>
  <persistent>0</persistent>
  <parentName>prnt_allyenergy</parentName>
  <maskName>spr_empty</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>speed = 17;                     //Set the speed
sfx_play(snd_sparkline, x, y);  //Play a sound effect for the attack
//Initialize variables
target_x = 0;                   //The x value of the target point
target_y = 0;                   //The y value of the target point
mid = 0;                        //The mid of this attack-tells who the attack belongs to
node_order = 0;                 //The number (1 to 3) of this node
hitbox_check = -1;              //The target object for the attack
function_stage = -1;            //Controls the action within the step event and draw event
alarm[0] = 1;                   //Set the time until auto-destroy timers are set

//Set attack variable values
attack_damage = 10;             //Set the damage for the attack
attack_burst = 0;               //Set the bonus damage of the attack that ignores shield
attack_threshold = 0;           //Set the threshold reduction per hit
attack_shake = 6;               //Set the screen shake intensity of the attack
attack_name = "Sparkline";      //Set the name of the attack
image_speed = 0;
alarm[2] = 8;
image_index = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Shift other nodes' order down if this node is still being tracked by the player
if(global.playership[mid].sparkline_node[node_order] = id)
    //Perform action depending on which node this is
    switch(node_order)    
    {
        case 1:     //If this is the first node, move the second and third nodes down.
            global.playership[mid].sparkline_node[1] = global.playership[mid].sparkline_node[2];    
            global.playership[mid].sparkline_node[2] = global.playership[mid].sparkline_node[3];    
            global.playership[mid].sparkline_node[3] = -1;  //Reset the third node because one doesn't exist     
        break;
        case 2:     //If this is the second node, move the third node down
            global.playership[mid].sparkline_node[2] = global.playership[mid].sparkline_node[3];    
            global.playership[mid].sparkline_node[3] = -1;  //Reset the third node because one doesn't exist
        break;
        case 3:     //If this is the third node, just reset it
            global.playership[mid].sparkline_node[3] = -1;  //Reset the third node because one doesn't exist
        break;
    }
    
//create an effect
switch(image_index)
{
    case 0:
        part_type_colour2(obj_partsystem_top.ring_particle, 8421631,255);
        part_particles_create(obj_partsystem_top.system, x, y, obj_partsystem_top.ring_particle, 3);
        
        part_type_colour2(obj_partsystem_top.flare_particle, 8421631,255);
        part_type_scale(obj_partsystem_top.flare_particle, 2, 2);
        part_particles_create(obj_partsystem_top.system, x, y, obj_partsystem_top.flare_particle, 3);
        part_type_scale(obj_partsystem_top.flare_particle, 1, 1);   
        
        part_type_speed(obj_partsystem.basic_part[0],1.68,2.40,-0.04,0);
        part_type_direction(obj_partsystem.basic_part[0],0,359,0,0);
        part_particles_create(obj_partsystem.system, x, y, obj_partsystem.basic_part[0], 8); 
    break;
    case 1:
        part_type_colour2(obj_partsystem_top.ring_particle, 816760767,16711680);
        part_particles_create(obj_partsystem_top.system, x, y, obj_partsystem_top.ring_particle, 3);
        
        part_type_colour2(obj_partsystem_top.flare_particle, 816760767,16711680);
        part_type_scale(obj_partsystem_top.flare_particle, 2, 2);
        part_particles_create(obj_partsystem_top.system, x, y, obj_partsystem_top.flare_particle, 3);
        part_type_scale(obj_partsystem_top.flare_particle, 1, 1);   
        
        part_type_speed(obj_partsystem.basic_part[1],1.68,2.40,-0.04,0);
        part_type_direction(obj_partsystem.basic_part[1],0,359,0,0);
        part_particles_create(obj_partsystem.system, x, y, obj_partsystem.basic_part[1], 8); 
    break;
}

repeat(2)
{
    spark = instance_create(x-15+random(30), y-15+random(30), obj_sparkline_spark);
    spark.connect = -1;
    spark.direction = random(360);
    spark.speed = 2+random(3);
    
    spark2 = instance_create(x-15+random(30), y-15+random(30), obj_sparkline_spark);
    spark2.connect = spark;
    spark2.direction = random(360);
    spark2.speed = 2+random(3);
}
spark = instance_create(x-15+random(30), y-15+random(30), obj_sparkline_spark);
spark.connect = spark2;
spark.direction = random(360);
spark.speed = 2+random(3);

switch(node_order)
{
    case 1:
        if(global.playership[mid].sparkline_node[2] = id)
        {
            global.playership[mid].sparkline_node[1] = global.playership[mid].sparkline_node[2];
            global.playership[mid].sparkline_node[2] = global.playership[mid].sparkline_node[3];
            global.playership[mid].sparkline_node[3] = -1;
        }
    
    break;
    case 2:
        if(global.playership[mid].sparkline_node[2] = id)
        {
            global.playership[mid].sparkline_node[2] = global.playership[mid].sparkline_node[3];
            global.playership[mid].sparkline_node[3] = -1;
        }
    break;
    case 3:
        if(global.playership[mid].sparkline_node[3] = id)
            global.playership[mid].sparkline_node[3] = -1;    
    break;
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>alarm[2] = 12;
if(speed &gt; 0)
    exit;
part_particles_create(obj_partsystem.system, x, y, obj_partsystem.sparkline_sparks, 3);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>203</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_kill_object</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Set the auto-destroy time and update other existing nodes' auto-destroy time
if(global.playership[mid].sparkline_node[1] != -1)
    global.playership[mid].sparkline_node[1].alarm[1] = 660;
if(global.playership[mid].sparkline_node[2] != -1)
    global.playership[mid].sparkline_node[2].alarm[1] = 659;
if(global.playership[mid].sparkline_node[3] != -1)
    global.playership[mid].sparkline_node[3].alarm[1] = 658;
function_stage = 0;
image_index = global.team[mid]-1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Destroy this node if it goes outside the room
if(x &lt; 0 || x &gt; room_width || y &lt; 0 || y &gt; room_height)
{
    instance_destroy();
    exit;
}
//Destroy this node if it hits a wall
if(obj_bulletcontrol.wallposition[floor(x/32), floor(y/32)] = true)
    instance_destroy();

//Perform action based on the function stage
switch(function_stage)
{
    case 0:     //The node was just created and needs to go to its target point
        //Check if the target point has been reached
        if(point_distance(x, y, target_x, target_y) &lt;= 18)
        {
            speed = 0;              //Stop moving
            function_stage = 1;     //Move to the next function stage
        }
    break;
    case 1:     //The node has reached its target point
        //Perform action based on which node this is
        switch(node_order)
        {
            //The first node does nothing
            case 2:     //The second node creates a tripline between the first node and itself
                //The second node does nothing if there is a third node
                if(global.playership[mid].sparkline_node[3] != -1)
                    break;
                    
                //Assign the global variable value to a local variable for faster lookup
                var first_node = global.playership[mid].sparkline_node[1];
                    
                //Check to see if an enemy has hit the tripline
                hitbox_check = collision_line(x, y, first_node.x, first_node.y, obj_dummy_enemy, 1, 1);
                if(hitbox_check != noone)
                {
                    function_stage = 2;                       //Move to the next function stage
                    first_node.function_stage = 2;            //Move this first node to the next function stage as well
                    first_node.hitbox_check = hitbox_check;   //Tell the first node which enemy hit the tripline
                    
                    //Reset the first and second nodes for their respective player
                    global.playership[mid].sparkline_node[1] = -1;
                    global.playership[mid].sparkline_node[2] = -1;
                }
            break;
            case 3:     //The third node creates a triangle with the other two points that closes in on any enemy inside
                //Initialize the needed variables for trigonometry calculations
                var triangle_side, incenter_x, incenter_y;
                
                //Assign the global variables value to local variable for faster lookup
                var first_node = global.playership[mid].sparkline_node[1];
                var second_node = global.playership[mid].sparkline_node[2];
                
                //Calculate the lengths of the triangle sides
                triangle_side[1] = point_distance(x, y, first_node.x, first_node.y);
                triangle_side[2] = point_distance(first_node.x, first_node.y, second_node.x, second_node.y);
                triangle_side[3] = point_distance(x, y, second_node.x, second_node.y);
                
                //Find the incenter of the triangle made
                incenter_x = ((triangle_side[1]*x)+(triangle_side[2]*first_node.x)+(triangle_side[3]*second_node.x))/
                                    (triangle_side[1]+triangle_side[2]+triangle_side[3]);
                incenter_y = ((triangle_side[1]*y)+(triangle_side[2]*first_node.y)+(triangle_side[3]*second_node.y))/
                                    (triangle_side[1]+triangle_side[2]+triangle_side[3]);
                                    
                //Find the enemy closest to the incenter
                var nearest_enemy = instance_nearest(incenter_x, incenter_y, obj_dummy_enemy);
                //Find out if the enemy is inside the triangle and target it if so
                if(point_in_triangle(nearest_enemy.x, nearest_enemy.y, x, y, first_node.x, first_node.y, second_node.x, second_node.y))
                    hitbox_check = nearest_enemy;
                else
                    //Create a target at the incenter if there is no enemy
                    hitbox_check = instance_create(incenter_x, incenter_y, obj_nodetarget);
                 
                 //Tell the other two nodes what to target
                 first_node.hitbox_check = hitbox_check;
                 second_node.hitbox_check = hitbox_check;
                 //Move all nodes to the next function stage
                 first_node.function_stage = 2;
                 second_node.function_stage = 2;
                 function_stage = 2;
                 //Reset all nodes for their respective player
                 global.playership[mid].sparkline_node[1] = -1;
                 global.playership[mid].sparkline_node[2] = -1;
                 global.playership[mid].sparkline_node[3] = -1;
            break;
        }    
    break;
    case 2:     //The node has detected a target and is homing in on it
        speed = 17;                                                         //Set the speed of the node
        mask_index = sprite_index;                                          //Allow collisions to happen with this node
        direction = point_direction(x, y, hitbox_check.x, hitbox_check.y);  //Move this node toward the target
    break;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_nodetarget">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Destroy this node if this is the target
if(other.id = hitbox_check)
    instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Draw electricity if the node is beyond the initial shot out
if(function_stage &gt; 0)
    //Perform action depending on which node this is
    switch(node_order)
    {
        //The first node doesn't draw anything
        case 2:     //The second node draws electricity linking to the first node
            //Don't draw anything if a third node exists
            if(global.playership[mid].sparkline_node[3] != -1)
                break;
            //Assign the global variable value to a local variable for faster lookup
            var first_node = global.playership[mid].sparkline_node[1];
            //Draw the electricity
            draw_electricity(x, y, first_node.x, first_node.y, c_blue, 3, 3, 6, true)
        break;
        case 3:     //The third node draws electricity connecting all nodes together, forming a triangle
            //Assign the global variables value to local variables for faster lookup
            var first_node = global.playership[mid].sparkline_node[1];
            var second_node = global.playership[mid].sparkline_node[2];   
            //Draw each side of the triangle with electricity         
            draw_electricity(x, y, first_node.x, first_node.y, c_blue, 3, 3, 6, true);
            draw_electricity(x, y, second_node.x, second_node.y, c_blue, 3, 3, 6, true);
            draw_electricity(second_node.x, second_node.y, first_node.x, first_node.y, c_blue, 3, 3, 6, true);      
        break;
    }

//Draw the image. It's drawn after the sparkline image to remain on top
//draw_sprite_ext(spr_sparkline, color_image, x, y, 1, 1, 0, c_white, 1);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>8,8</point>
    <point>8,8</point>
  </PhysicsShapePoints>
</object>
