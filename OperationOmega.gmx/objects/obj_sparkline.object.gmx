<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_sparkline</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1</depth>
  <persistent>0</persistent>
  <parentName>prnt_allyattack</parentName>
  <maskName>spr_empty</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Set the speed
speed = 17;

sfx_play(snd_sparkline, x, y);

target_x = 0;
target_y = 0;
mid = 0;
node_order = 0;
hitbox_check = -1;
function_stage = -1;
alarm[0] = 1;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Shift other nodes' order down if this node is still being tracked by the player
if(global.playership[mid].sparkline_node[node_order] = id)
    //Perform action depending on which node this is
    switch(node_order)    
    {
        case 1:     //If this is the first node, move the second and third nodes down.
            global.playership[mid].sparkline_node[1] = global.playership[mid].sparkline_node[2];    
            global.playership[mid].sparkline_node[2] = global.playership[mid].sparkline_node[3];    
            global.playership[mid].sparkline_node[3] = -1;  //Reset the third node because one doesn't exist     
        break;
        case 2:     //If this is the second node, move the third node down
            global.playership[mid].sparkline_node[2] = global.playership[mid].sparkline_node[3];    
            global.playership[mid].sparkline_node[3] = -1;  //Reset the third node because one doesn't exist
        break;
        case 3:     //If this is the third node, just reset it
            global.playership[mid].sparkline_node[3] = -1;  //Reset the third node because one doesn't exist
        break;
    }
    
//create an effect
effect_create_above(ef_ring, x, y, 0, c_aqua);
effect_create_above(ef_flare, x, y, 1, c_aqua);
part_type_color1(obj_partsystem.primarypart, c_aqua);
part_type_speed(obj_partsystem.primarypart,1.68,2.40,-0.04,0);
part_type_direction(obj_partsystem.primarypart,0,359,0,0);
part_particles_create(obj_partsystem.system, x, y, obj_partsystem.primarypart, 8);

repeat(2)
{
    spark = instance_create(x-15+random(30), y-15+random(30), obj_sparkline_spark);
    spark.connect = -1;
    spark.direction = random(360);
    spark.speed = 2+random(3);
    
    spark2 = instance_create(x-15+random(30), y-15+random(30), obj_sparkline_spark);
    spark2.connect = spark;
    spark2.direction = random(360);
    spark2.speed = 2+random(3);
}
spark = instance_create(x-15+random(30), y-15+random(30), obj_sparkline_spark);
spark.connect = spark2;
spark.direction = random(360);
spark.speed = 2+random(3);



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>203</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_kill_object</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Set the auto-destroy time and update other existing nodes' auto-destroy time
if(global.playership[mid].sparkline_node[1] != -1)
    global.playership[mid].sparkline_node[1].alarm[1] = 660;
if(global.playership[mid].sparkline_node[2] != -1)
    global.playership[mid].sparkline_node[2].alarm[1] = 659;
if(global.playership[mid].sparkline_node[3] != -1)
    global.playership[mid].sparkline_node[3].alarm[1] = 658;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Destroy this node if it goes outside the room
if(x &lt; 0 || x &gt; room_width || y &lt; 0 || y &gt; room_height)
{
    instance_destroy();
    exit;
}
//Destroy this node if it hits a wall
if(obj_bulletcontrol.wallposition[floor(x/32), floor(y/32)] = true)
    instance_destroy();

//Perform action based on the function stage
switch(function_stage)
{
    case 0:     //The node was just created and needs to go to its target point
        //Check if the target point has been reached
        if(point_distance(x, y, target_x, target_y) &lt;= 17 &amp;&amp; speed = 17)
        {
            speed = 0;              //Stop moving
            function_stage = 1;     //Move to the next function stage
        }
    break;
    case 1:     //The node has reached its target point
        //Perform action based on which node this is
        switch(node_order)
        {
            //The first node does nothing
            case 2:     //The second node creates a tripline between the first node and itself
                //The second node does nothing if there is a third node
                if(global.playership[mid].sparkline_node[3] != -1)
                    break;
                    
                //Check to see if an enemy has hit the tripline
                hitbox_check = collision_line(x, y, global.playership[mid].sparkline_node[1].x, global.playership[mid].sparkline_node[1].y, prnt_enemy, 1, 1);
                if(hitbox_check != -1)
                {
                    function_stage = 2;                                                     //Move to the next function stage
                    global.playership[mid].sparkline_node[1].function_stage = 2;            //Move this first node to the next function stage as well
                    global.playership[mid].sparkline_node[1].hitbox_check = hitbox_check;   //Tell the first node which enemy hit the tripline
                    
                    //Reset the first and second nodes for their respective player
                    global.playership[mid].sparkline_node[1] = -1;
                    global.playership[mid].sparkline_node[2] = -1;
                }
            break;
            case 3:     //The third node creates a triangle with the other two points that closes in on any enemy inside
                //Initialize the needed variables for trigonometry calculations
                var triangle_side, incenter_x, incenter_y;
                
                //Calculate the lengths of the triangle sides
                triangle_side[1] = point_distance(x, y, global.playership[mid].sparkline_node[1].x, global.playership[mid].sparkline_node[1].y);
                triangle_side[2] = point_distance(global.playership[mid].sparkline_node[1].x, global.playership[mid].sparkline_node[1].y, global.playership[mid].sparkline_node[2].x, global.playership[mid].sparkline_node[2].y);
                triangle_side[3] = point_distance(x, y, global.playership[mid].sparkline_node[2].x, global.playership[mid].sparkline_node[2].y);
                
                //Find the incenter of the triangle made
                incenter_x = ((triangle_side[1]*x)+(triangle_side[2]*global.playership[mid].sparkline_node[1].x)+(triangle_side[3]*global.playership[mid].sparkline_node[2].x))/
                                    (triangle_side[1]+triangle_side[2]+triangle_side[3]);
                incenter_y = ((triangle_side[1]*y)+(triangle_side[2]*global.playership[mid].sparkline_node[1].y)+(triangle_side[3]*global.playership[mid].sparkline_node[2].y))/
                                    (triangle_side[1]+triangle_side[2]+triangle_side[3]);
                                    
                //Find the enemy closest to the incenter
                var nearest_enemy = instance_nearest(incenter_x, incenter_y, prnt_enemy);
                //Find out if the enemy is inside the triangle and target it if so
                if(point_in_triangle(nearest_enemy.x, nearest_enemy.y, x, y, global.playership[mid].sparkline_node[1].x, global.playership[mid].sparkline_node[1].y, global.playership[mid].sparkline_node[2].x, global.playership[mid].sparkline_node[2].y))
                    hitbox_check = nearest_enemy;
                else
                    //Create a target at the incenter if there is no enemy
                    hitbox_check = instance_create(incenter_x, incenter_y, obj_nodetarget);
                 
                 //Tell the other two nodes what to target
                 global.playership[mid].sparkline_node[1].hitbox_check = hitbox_check;
                 global.playership[mid].sparkline_node[2].hitbox_check = hitbox_check;
                 //Move all nodes to the next function stage
                 global.playership[mid].sparkline_node[1].function_stage = 2;
                 global.playership[mid].sparkline_node[2].function_stage = 2;
                 global.playership[mid].sparkline_node[3].function_stage = 2;
                 //Reset all nodes for their respective player
                 global.playership[mid].sparkline_node[1] = -1;
                 global.playership[mid].sparkline_node[2] = -1;
                 global.playership[mid].sparkline_node[3] = -1;
            break;
        }    
    break;
    case 2:     //The node has detected a target and is homing in on it
        speed = 17;                                                         //Set the speed of the node
        mask_index = sprite_index;                                          //Allow collisions to happen with this node
        direction = point_direction(x, y, hitbox_check.x, hitbox_check.y);  //Move this node toward the target
    break;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_nodetarget">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Destroy this node if this is the target
if(other.id = hitbox_check)
 instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check if a second sparkline node exists
if(instance_exists(second) &amp;&amp; second != -1)
{
 if((speed = 0 &amp;&amp; second.speed = 0) || stage = 1)
 {
    var pointdist, pointdir;
    draw_electricity(x, y, second.x, second.y, c_blue, 3, 3, 6, true)//3-random(6) is equall in either way
    
    if(irandom(3) = 1)
    {
        pointdist = irandom(point_distance(x, y, second.x, second.y));
        pointdir = point_direction(x, y, second.x, second.y);
        part_particles_create(obj_partsystem.system, x+lengthdir_x(pointdist, pointdir), y+lengthdir_y(pointdist, pointdir), obj_partsystem.elecspark, 1);
    }
 }
}
//Draw the image. It's drawn after the sparkline image to remain on top
draw_sprite_ext(spr_sparkline, -1, x, y, 1, 1, 0, global.allycolor, 1);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>8,8</point>
    <point>8,8</point>
  </PhysicsShapePoints>
</object>
