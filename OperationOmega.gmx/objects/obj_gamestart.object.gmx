<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-20</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//This object creates host-client specific objects for the game
//It also creates dummies for every other player

//Initialize the flag that tells whether or not this map is in space
global.spacemap = 0;

//Create a starfield on maps in space
if(room != rm_katrinbase &amp;&amp; room != rm_victabase &amp;&amp; room != rm_victatundra &amp;&amp; room != rm_katrincoast)
{
    global.starback[0] = create_starfield(1000, 0.5, 28);
    global.starback[1] = create_starfield(1000, 0.45, 45);
    global.starback[2] = create_starfield(1000, 0.4, 90);
    background_index[5] = global.starback[2];
    background_index[6] = global.starback[1];
    global.spacemap = 1;
}


previous_countdown_second = 6;      //Holds the value of the previous countdown 
packet_received = 0;                //Holds the value of the packet most recently received
players_ready = 1;                  //Holds the number of players that are ready to start


//Initialize random background movement to simulate space
back_extrahspeed = -1 + random(2);      //Holds the value of the random background hspeed
back_extravspeed = -1 + random(2);      //Holds the value of the random background vspeed

//Add tiles to complete the background depending on the map
switch(room)
{
    case rm_victatundra:
        //Increase the random background movement for the snow
        back_extrahspeed = -8 + random(16);
        back_extravspeed = -8 + random(16);
        tile_add(global.backpiece_1, 0, 0, 2460, 2265, 0, 2265, 100001);
        tile_add(global.backpiece_2, 0, 0, 2460, 2265, 2460, 0, 100001);
        tile_add(global.backpiece_3, 0, 0, 2460, 2265, 2460, 2265, 100001);    
    break;
    case rm_barricade:
    case rm_katrinbase:
    case rm_katrincoast:
    case rm_victabase:
    case rm_spacedepot:
        tile_add(global.backpiece_1, 0, 0, 2000, 2000, 0, 2000, 100001);
        tile_add(global.backpiece_2, 0, 0, 2000, 2000, 2000, 0, 100001);
        tile_add(global.backpiece_3, 0, 0, 2000, 2000, 2000, 2000, 100001);        
    break;
    case rm_combatzone:
        tile_add(global.backpiece_1, 0, 0, 1500, 1500, 0, 1500, 100001);
        tile_add(global.backpiece_2, 0, 0, 1500, 1500, 1500, 0, 100001);
        tile_add(global.backpiece_3, 0, 0, 1500, 1500, 1500, 1500, 100001);
    break;
    case rm_orbitstation:
        tile_add(global.backpiece_1, 0, 0, 1100, 1100, 656, 1749, 100001);
        tile_add(global.backpiece_2, 0, 0, 1100, 1100, 1749, 656, 100001);
        tile_add(global.backpiece_3, 0, 0, 1100, 1100, 1749, 1749, 100001);   
    break;
}

//Add the background speed to the different background layers accordingly
background_hspeed[2]=back_extrahspeed/3;
background_hspeed[3]=back_extrahspeed/4;
background_hspeed[4]=back_extrahspeed/5;
background_vspeed[2]=back_extravspeed/3;
background_vspeed[3]=back_extravspeed/4;
background_vspeed[4]=back_extravspeed/5;
 
//Set the team colors depending on your mid
if(global.team[global.mymid] = 1)
{
    global.allycolor = c_red;
    global.enemycolor = c_blue;
}
else
{
    global.allycolor = c_blue;
    global.enemycolor = c_red;
}

//Initialize score window values
for(i = 0; i &lt; 8; i += 1)
{
    global.primaryRNG[i] = 1;    //Also initialize the RNG seed for each player
    global.playerfps[i] = 60;
    global.ping[i] = 0;
    global.kills[i] = 0;
    global.deaths[i] = 0;
    global.assists[i] = 0;
    global.damagetaken[i] = 0;
    global.damagedealt[i] = 0;
}
//Also Initialize the variables that track the impact walls have
global.walldamage = 0;
global.walldeaths = 0;


//If stock, set the score equal to the team's total stock
//Matchvariable will be the stock each player gets
if(global.matchtype = "stock")
{
    global.redscore = global.redteam*global.matchvariable;
    global.bluescore = global.blueteam*global.matchvariable;
}
else
{
    //Otherwise, just set the team score to 0, as it will track kills
    global.redscore = 0;
    global.bluescore = 0;
}


//Set time until the match automatically begins
alarm[0] = 2700;
//Set the time until clients send their ready status to the host
alarm[1] = 70;

//Initialize the variable that holds the alpha value of the white fide-in
transition_fade_in = 1;

packet = 0;

//Set the view size and position
view_hview[0] = 750;
view_wview[0] = 1200;
view_xview[0] = room_width/2 - view_wview[0]/2;
view_yview[0] = room_height/2 - view_hview[0]/2;

//Calculate the values for displaying player tiles during the countdown

//Initialize the team total variables
var red_team_total = 0;
var blue_team_total = 0;

//Loop through all players to add them to the team totals
for(i = 0; i &lt; 8; i++)
{
    //Ignore inactive player slots
    if(global.activated[i] &lt;= 0) continue;
    if(global.team[i] = 1)
        red_team_total += 1;
    else
        blue_team_total += 1;
}
//Set the starting y value and distance between player slots for the red team
switch(red_team_total)
{
    case 1:
        red_slot_start_y = 70;
        red_slot_distance_between_slots = 32;
    break;
    case 2:
        red_slot_start_y = 38;
        red_slot_distance_between_slots = 65;
    break;
    case 3:
        red_slot_start_y = 27;
        red_slot_distance_between_slots = 43;
    break;
    case 4:
        red_slot_start_y = 22;
        red_slot_distance_between_slots = 32;
    break;
}
//Set the starting y value and distance between player slots for the blue team
switch(blue_team_total)
{
    case 1:
        blue_slot_start_y = 70;
        blue_slot_distance_between_slots = 32;
    break;
    case 2:
        blue_slot_start_y = 38;
        blue_slot_distance_between_slots = 65;
    break;
    case 3:
        blue_slot_start_y = 27;
        blue_slot_distance_between_slots = 43;
    break;
    case 4:
        blue_slot_start_y = 22;
        blue_slot_distance_between_slots = 32;
    break;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(global.master = false)
{
    writebyte(50, 0);
    sendmessage(global.host, 0, 0, 0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//If on the Satellita map, move the background to keep the planet centered
if(room = rm_satellite)
{  
    //Handle the x coordinate        
    background_x[0] += (global.spawnx[global.mymid]-(room_width/2))/2;
    //Change the planet's position as well
    background_x[1] = background_x[0];
    //Handle the y coordinate        
    background_y[0] += (global.spawny[global.mymid]-(room_height/2))/2;
    //Change the planet's position as well
    background_y[1] = background_y[0];
}
//Do the same for Barricade
if(room = rm_barricade)
{  
    //Handle the x coordinate        
    background_x[0] += (global.spawnx[global.mymid]-(room_width/2))/2;
    //Change the planet's position as well
    background_x[1] = background_x[0]+800;
    //Handle the y coordinate        
    background_y[0] += (global.spawny[global.mymid]-(room_height/2))/2;
    //Change the planet's position as well
    background_y[1] = background_y[0]+800;
}

//Create objects for the host
if(global.master = true)
{
    //Create the controller and the player
    tele = instance_create(global.myspawnx, global.myspawny, obj_teleport);
    tele.mid = global.mymid;
    tele.activate_all = true;
    view_object = tele;
    (instance_create(-1000, -1000, obj_player)).ship_disabled = true;
    global.activated[global.mymid] = 2;
    instance_create(0, 0, obj_bulletcontrol);
    instance_create(0, 0, obj_partsystem);
    instance_create(0, 0, obj_starfield_mod);
    //Create a ship for each additional player
    for(i = 0; i &lt;= 7; i += 1)
    {
        //Check if this player is in game
        if(global.activated[i] = 1)
        {
            pass_mid = i;
            pass_current_primary = global.playerprimary[i];
            pass_current_ship = global.selected_ship[i];
            //Create an ally if this player is on your team
            if(global.team[i] = global.team[global.mymid])
            {
                global.playership[i] = instance_create(6500, 6500, obj_dummy_ally);
                global.playership[i].ally = true;
                global.playership[i].thisname = global.othername[i];
            }
            //Create an enemy if this player is not on your team
            else
            {
                global.playership[i] = instance_create(6500, 6500, obj_dummy_enemy);
                global.playership[i].ally = false;
                global.playership[i].thisname = global.othername[i];
            }
            global.activated[i] = 2;
        }
    }
    instance_create(0, 0, obj_mod);
}
//Create objects for the client
else
{
    //Create the controller and the player
    tele = instance_create(global.myspawnx, global.myspawny, obj_teleport);
    tele.mid = global.mymid;
    tele.activate_all = true;
    view_object = tele;
    global.activated[global.mymid] = 2;
    (instance_create(-1000, -1000, obj_player)).ship_disabled = true;
    instance_create(0, 0, obj_bulletcontrol);
    instance_create(0, 0, obj_partsystem);
    instance_create(0, 0, obj_starfield_mod);
    //Create a ship for each additional player
    for(i = 0; i &lt;= 7; i += 1)
    {
        //Check if this player is in game
        if((global.activated[i] = 1 || i = 0) &amp;&amp; i != global.mymid)
        {
            pass_mid = i;
            pass_current_primary = global.playerprimary[i];
            pass_current_ship = global.selected_ship[i];
            //Create an ally if this player is on your team
            if(global.team[i] = global.team[global.mymid])
            {
                global.playership[i] = instance_create(6500, 6500, obj_dummy_ally);
                global.playership[i].ally = true;
                global.playership[i].thisname = global.othername[i];
            }
            //Create an enemy if this player is not on your team
            else
            {
                global.playership[i] = instance_create(6500, 6500, obj_dummy_enemy);
                global.playership[i].ally = false;
                global.playership[i].thisname = global.othername[i];
            }
            global.activated[i] = 2;
        }
    }
    instance_create(0, 0, obj_mod_client);
}
//Initialize match type
switch(global.matchtype)
{
 case "stock":
      global.ships = global.matchvariable;
      obj_mod.shipspace = 65/global.matchvariable;
 break;
 case "death":
      global.time = date_current_datetime();
      global.endtime = date_inc_second(global.time, global.matchvariable*60);
      global.ships = 2;
 break;
}
//Reset warning color
global.matchcolor = c_black;

//Transfer extra background speeds
obj_mod.back_extrahspeed = back_extrahspeed;
obj_mod.back_extravspeed = back_extravspeed;

//Destroy this object because it's no longer needed
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check for packets from other players
//The only packet that will be sent and received at this point is to signify that the player is ready,
//  or that all players are ready.

//Check if you are the host
if(global.master = true)
    //Loop indefinitely until there are no more messages to process
    while(true)
    {
        //Initilialize the variable that holds the size of the packet
        var size = 0;
        //Loop through all players
        for(i = 0; i &lt; ds_list_size(global.clients); i += 1)
        {
            //Check for a message from the current player
            size = receivemessage(client_port(i), 0, 0);
            //If a message was received, break the loop
            if(size &gt; 0) break;
        }
        //If there was no message received, break the loop
        if(size &lt;= 0) break;
        //Read the packet
        packet = readbyte(0);
        players_ready += 1;                       //Add to the count of players who are ready
        //Check if all players are ready
        if(players_ready = global.playercount)
        {
            //Send a message to all players to have them start the countdown
            clearbuffer(0);
            writebyte(50, 0);
            client_sendall(0, 0);
            //Start the countdown
            alarm[0] = 300;
        }
    }
else
    //Make sure no packets have been received yet
    if(packet = 0)
        //Loop indefinitely until there are no more messages to process
        while(true)
        {
            //Initilialize the variable that holds the size of the packet
            var size = 0;
            //Check for a message from the host
            size = receivemessage(global.host, 0, 0);
            //Check if the host disconnected
            if(size == 0)
            {
                show_message("The host has disconnected.");
                closesocket(global.udpsock);
                dllfree();
                if(global.public_game = true)
                    room_goto(rm_public_game);
                else
                    room_goto(rm_private_game);
                exit;
            }
            //If there was no message received, break the loop
            if(size &lt; 0) 
            {
                break;
            }
            //Read the information received and start the countdown
            packet = readbyte(0);
            alarm[0] = 300;
        }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(transition_fade_in &gt; 0)
    transition_fade_in -= 0.0125;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_background_tiled_ext(global.starback[0], 0, 0, 1, 1, c_white, 1);
//Set the scaling value
scaling = view_hview[0]/480;
//Set the coordinates of the team boxes
var red_team_x = view_xview[0]+50*scaling
var red_team_y = view_yview[0]+50*scaling
var blue_team_x = view_xview[0]+view_wview[0]-245*scaling
var blue_team_y = view_yview[0]+view_hview[0]-213*scaling

//Draw the team boxes
draw_sprite_ext(spr_matchbox, 0, red_team_x, red_team_y, scaling, scaling, 0, c_white, 1);
draw_sprite_ext(spr_matchbox, 1, blue_team_x, blue_team_y, scaling, scaling, 0, c_white, 1);

var red_team = 0;
var blue_team = 0;
for(i = 0; i &lt; 8; i++)
{
    if(global.activated[i] &lt;= 0) continue;
    if(global.team[i] = 1)
    {
        draw_sprite_ext(spr_match_slots, global.selected_ship[i]+((global.team[i]-1)*3)-1, red_team_x+28*scaling, red_team_y+(red_slot_start_y+red_slot_distance_between_slots*red_team)*scaling, scaling, scaling, 0, c_white, 1);
        draw_text_bordered(red_team_x+38*scaling, red_team_y+(red_slot_start_y+red_slot_distance_between_slots*red_team+1)*scaling, global.othername[i], scaling, 1, c_black, c_red);
        red_team++;
    }
    else
    {
        draw_sprite_ext(spr_match_slots, global.selected_ship[i]+((global.team[i]-1)*3)-1, blue_team_x+28*scaling, blue_team_y+(blue_slot_start_y+blue_slot_distance_between_slots*blue_team)*scaling, scaling, scaling, 0, c_white, 1);    
        draw_text_bordered(blue_team_x+38*scaling, blue_team_y+(blue_slot_start_y+blue_slot_distance_between_slots*blue_team+1)*scaling, global.othername[i], scaling, 1, c_black, c_blue);
        blue_team++;
    }
}
//draw_text(room_width/2-240+70, room_height/2-158+35, global.matchtype+': '+string(global.matchvariable));
//draw_text(room_width/2-240+400, room_height/2-158+35, global.shortlevel);

//Hold the value of the seconds left until the game starts
var countdown_second = ceil(alarm[0]/60);
//Check if the countdown is at 5 seconds or less and still occurring
if(countdown_second &lt; 6 &amp;&amp; alarm[0] != -1)
{
    //Play a sound if the countdown has lowered
    if(countdown_second != previous_countdown_second)
        audio_play_sound(snd_changeweapon, 1, 0);
    //Set the previous countdown to the current one
    previous_countdown_second = countdown_second;
    //Draw the countdown
    draw_sprite_ext(spr_matchstart_text, countdown_second, room_width/2, room_height/2, scaling, scaling, 0, c_white, 1);
}


draw_set_alpha(transition_fade_in)
draw_set_color(c_white);
draw_rectangle(view_xview[0]-10, view_yview[0]-10, view_xview[0]+view_wview[0]+10, view_yview[0]+view_hview[0]+10, 0);
draw_set_color(c_black);
draw_set_alpha(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
