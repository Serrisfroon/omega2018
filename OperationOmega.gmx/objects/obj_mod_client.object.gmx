<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>obj_mod</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>switch(sendping)
{
 case 0:
      clearbuffer(0);
      packet_label_write(1, global.mymid);
      if(obj_ship.armor &gt; 0)
       writebyte(status_compress(obj_ship.smoke, obj_ship.ship_status_hacked, obj_ship.ship_status_shocked), 0);
      else
       writebyte(0, 0);
      writebyte(floor(global.ping[global.mymid]/20), 0);
      writebyte(fps, 0);
      pinged = 0;
      sendmessage(global.host, "", 0, 0);   
      sendping = 120;   
 break;
 default:
         sendping -= 1;
 break;
}

if((obj_ship.armor &lt;= 0) || instance_number(obj_teleport) &gt; 0) exit;

switch(refreshing)
{
 case 0:
      refreshing = 5;
      clearpack();
      packet_label_write(0, global.mymid);
      crush(round(obj_ship.direction*10), 3600, 0);
      crush(round(obj_ship.facedir*10), 3600, 0);
      crush(round(obj_ship.x*10), 65000, 0);
      crush(round(obj_ship.y*10), 65000, 0);      
      crush(round(obj_ship.speed*100), 2500, 0);
      crush(prediction_compress(0, obj_ship.predictturn, obj_ship.predictspeed, obj_ship.multiplayer_primary_fire_flag), 72, 0);
      if(obj_ship.multiplayer_primary_fire_flag = true)
      {
       refreshing = 3;
       crush(round(obj_ship.newdir*10), 3600, 0);
       switch(global.primary)
       {
        case 4:
            //Find out which ship you are targetting
            if(obj_mod.foundtarget &lt;= -1)
             testtarget = 8;
            else
            {
             testtarget = -1;
             while(true)
             {
              testtarget+=1;
             if(testtarget != global.mymid)
               if(global.playership[testtarget] = obj_mod.foundtarget)
               break;
             }
            }
            crush(testtarget, 8, 0);
        break;
        case 6:
             crush(min(100, round(point_distance(obj_ship.x, obj_ship.y, mouse_x, mouse_y)/10)), 100, 0);
        break;
        case 7:
             if(foundtarget != -1)
              crush(foundtarget.mid, 10, 0);
             else
              crush(10, 10, 0);
        break;
       }
      }
      //Send to the host
      //sendmessage(global.host, 0, 0, 0);   
        bufferpack();
        sendmessage(global.host, "", 0, 0);
 break;
 default:
    refreshing -= 1;
 break;   
}

if(obj_ship.snapdir != oldsnap)
{
    clearbuffer(0);
    packet_label_write(13, global.mymid);
    writebyte(obj_ship.snapdir+100, 0);
    sendmessage(global.host, "", 0, 0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//This part of the step event deals with plaer communications
//This is the host object, so it must relay messages to other
//players

//Start an infinite while loop. It will be broken when there are no new messages
//from the host. All other clients will relay messages to you through the host.
while(true)
 {
  //Initialize variables
  var size;
  size = 0;
  //Check for a tcp message
  size = receivemessage(global.host, 0, 0);
  //If there was no response, the host disconnected
  if(size == 0 || disconnectcheck &gt;= 300)
  {
   //Inform the player
   show_message("The host has disconnected.");
    if(global.musictoggle = 0)
    {
        audio_stop_sound(music_quasar);
        audio_play_sound(music_quasar, 1, 1);
    }
   //Close the udp socket and stop 39dll
   closesocket(global.udpsock);
   closesocket(global.host);
   dllfree();
   //Return to the appropriate room
   if(global.public_game = true)
    room_goto(rm_public_game);
   else
    room_goto(rm_private_game);   
   exit;
  }
  //If there was no message, break the loop
  if(size &lt; 0) 
  {
   disconnectcheck += 1;
   break;
  }
  disconnectcheck = 0;
  //Read the label byte to find the packet id and the player who sent it
  lollabel = readbyte(0);
  packet_label_read(lollabel);
  
  //Check to make sure some freak error didn't occur that made the host
  //send your actions back to you to read
  if((dummy != global.mymid || packet = 1) &amp;&amp; dummy &gt;= 0)
  
  //Perform the correct acton depending on what packet has been sent
  switch(packet)
  {
  
   //The player sends its refresh packet
   case 0:
        uncrushbegin();
        for(i = 0; i &lt; 8; i += 1)
        {
         if(i != 0) 
         {
          //Ignore this cycle if the player slot is not activated
          if(global.activated[i] &lt;= 0) continue;
          //Read the cycle if it is your player slot, and put it into a junk variable.
          if(i = global.mymid)
          {
           holdvar = uncrush(3600, 0);
           holdvar = uncrush(3600, 0);
           holdvar = uncrush(65000, 0);
           holdvar = uncrush(65000, 0);
           holdvar = uncrush(2500, 0);
           holdvar = uncrush(72, 0);
           //Check if the compressed prediction holds shooting as 1
           if(holdvar &gt; 36)
           {
            holdvar = uncrush(3600, 0);
            switch(global.primary)
            {          
             case 4:
                  holdvar = uncrush(8, 0);
             break;
             case 6:
                  holdvar = uncrush(100, 0);
             break;
             case 7:
                  holdvar = uncrush(10, 0);
             break;
            }
           }
           continue;
          }
         }             
         if(global.playership[i] = obj_dud) continue;
        global.playership[i].direction = uncrush(3600, 0)/10;
        global.playership[i].facedir = uncrush(3600, 0)/10;
        global.playership[i].x = uncrush(65000, 0)/10;
        global.playership[i].y = uncrush(65000, 0)/10;
        global.playership[i].speed = uncrush(2500, 0)/100;
         dummy = i;
         decomp = uncrush(72, 0);
         prediction_decompress(decomp);
         if(global.playership[i].multiplayer_primary_fire_flag = true)
         {
          global.playership[i].newdir = uncrush(3600, 0)/10;
          switch(global.playerprimary[i])
          {          
           case 4:
                global.playership[i].flankcurve = uncrush(8, 0);
           break;
           case 6:
                global.playership[i].crossfiredist = uncrush(100, 0)*10;
           break;
           case 7:
                global.playership[i].siphontarget = uncrush(10, 0);
           break;
          }
         }
        }
   break;
   
   //The player sends its ping packet
   case 1:
        if(dummy = global.mymid)
        {
         //Find your ms ping. Take the pined variable(added every step, 60/sec
         //Multiply by 16.67(60*16.67 ~ 1000), take the floor to remove decimal
         global.ping[global.mymid] = floor((obj_mod.pinged)*16.67);
         break;
        }
        lolstatuses = readbyte(0);
        status_decompress(lolstatuses);
        if(global.playership[dummy].ship_status_hacked = true)
        {
         global.playership[dummy].thisturn = 0;
         global.playership[dummy].turning = 0;
         global.playership[dummy].speeding = 2;
        }
        global.ping[dummy] = readbyte(0)*20;
        global.playerfps[dummy] = readbyte(0);
   break;
   
   //The player uses a secondary weapon
   case 2:
        receive_secondary();
   break;
   
   //The player is defeated
   case 3:
        defeatmid = readbyte(0);
        anotherspawn[dummy] = readbyte(0);
        with(obj_turret)
            if(mid = obj_mod.dummy)
                instance_destroy();
        with(obj_turret_enemy)
            if(mid = obj_mod.dummy)
                instance_destroy();
        //Update score
        if(defeatmid != 20)
         global.kills[defeatmid] += 1;
        global.deaths[dummy] += 1;
        switch(global.matchtype)
        {
         case "stock":
              //Reduce your team's score by 1
              switch(global.team[dummy])
              {
               case 1:
                    global.redscore -= 1;
               break;
               case 2:
                    global.bluescore -= 1;
               break;
              }
         break;
         case "death":
              //Increase other team's score by 1
              switch(global.team[dummy])
              {
               case 1:
                    global.bluescore += 1;
               break;
               case 2:
                    global.redscore += 1;
               break;
              }
         break;
        }
        //Create a defeated ship in the player's place
        defeat = instance_create(global.playership[dummy].x, global.playership[dummy].y, obj_deadother);
        defeat.direction = global.playership[dummy].direction;
        defeat.speed = global.playership[dummy].speed+1;
        defeat.sprite_index = global.playership[dummy].sprite_index;
        defeat.dummy = dummy;
        if(global.playership[dummy] = view_object[0])
         view_object[0] = defeat;
        //Send a defeat notice to chat
        switch(readbyte(0))
        {
         case 1:         
              newcolor = c_maroon;
         break;
         case 2:
              newcolor = c_navy;
         break;
        }
        chatline_add(readstring(0), newcolor);
        if(obj_mod.announcing = 0 &amp;&amp; defeatmid != 20)
        {
         obj_mod.announcing  = 1;
         obj_mod.announcement = global.othername[defeatmid]+" defeated "+global.othername[dummy];
         obj_mod.announcement_color = newcolor;
        }
        //Reset targetting if currently targetting this ship
        if(foundtarget = global.playership[dummy])
        {
         foundtarget = -1;
         targetdist = point_distance(obj_ship.x, obj_ship.y, -10000, -10000);
        }
        //Destroy the designated ship
        with(global.playership[dummy])
         instance_destroy();
        //Create an object to intercept late info
        global.playership[dummy] = instance_create(0, 0, obj_dud);         
   break;
   
   //A player is eliminated in a stock match
   case 4:
        //Send it to your chat
        if(global.team[dummy] = 1)
         newcolor = c_red;
        else
         newcolor = c_blue;
        chatline_add(global.othername[dummy]+" has been eliminated.", newcolor);
   break;
   
   //The stock match is over
   case 5:
        //Send it to your chat
        switch(readbyte(0))
        {
         case 1:         
              newcolor = c_maroon;
              if(global.team[global.mymid] = 1)
              {
               obj_mod.announcement = "Operation Failed";
               obj_mod.announcement_color = c_navy;
               global.outcome = 1;
              }
              else
              {
               obj_mod.announcement = "Operation Successful";
               obj_mod.announcement_color = c_navy;
               global.outcome = 0;
              }
         break;
         case 2:
              newcolor = c_navy;
              if(global.team[global.mymid] = 1)
              {
               obj_mod.announcement = "Operation Successful";
               obj_mod.announcement_color = c_maroon;
               global.outcome = 0;
              }
              else
              {
               obj_mod.announcement = "Operation Failed";
               obj_mod.announcement_color = c_maroon;
               global.outcome = 1;
              }
         break;
        }
        obj_mod.announcing  = 1;
        obj_mod.announcealpha = 0;
        
        chatline_add(readstring(0), newcolor);
        switch(readbyte(0))
        {
         case 1:         
              newcolor = c_maroon;
         break;
         case 2:
              newcolor = c_navy;
         break;
        }
        chatline_add(readstring(0), newcolor);
        //Set time until returning to waiting room
        alarm[2] = 180;
   break;
      
   //Prediction Packet
   case 6:
        decomp = readbyte(0);
        prediction_decompress(decomp);
   break;  
   
   //Chat Message
   case 7:
        //Put the message in your chat
        chatline_add(readstring(0), c_white);
   break;

   //Ship checkin. Sets the correct image and ship-dependant variables 
   //for a player when it spawns
   case 9:
        global.playership[dummy].mid = readbyte(0);
        ship = readbyte(0);
        //If the player is on red team, set choose a red ship and set
        //the right values
        if(global.team[dummy] = 1)
         switch(ship)
         {
          case 1: //Alphastar
               global.playership[dummy].sprite_index = spr_alphastar;
               global.playership[dummy].ship_turning_rate = 5;
               global.playership[dummy].minspeed = 2;
               global.playership[dummy].velocity_maximum = 7;               
          break;
          case 2: //Swiftwing
               global.playership[dummy].sprite_index = spr_swiftwing;
               global.playership[dummy].ship_turning_rate = 8;
               global.playership[dummy].minspeed = 4;
               global.playership[dummy].velocity_maximum = 10;               
          break;
          case 3: //Goliath
               global.playership[dummy].sprite_index = spr_goliath;
               global.playership[dummy].ship_turning_rate = 3;
               global.playership[dummy].minspeed = 1;
               global.playership[dummy].velocity_maximum = 5;
          break;
         }
        else
        //If the player is on blue team, set choose a blue ship and set
        //the right values
         switch(ship)
         {
          case 1: //Alphastar
               global.playership[dummy].sprite_index = spr_alphastar_enemy;
               global.playership[dummy].ship_turning_rate = 5;
               global.playership[dummy].minspeed = 2;
               global.playership[dummy].velocity_maximum = 7;               
          break;
          case 2: //Swiftwing
               global.playership[dummy].sprite_index = spr_swiftwing_enemy;
               global.playership[dummy].ship_turning_rate = 8;
               global.playership[dummy].minspeed = 4;
               global.playership[dummy].velocity_maximum = 10;               
          break;
          case 3: //Goliath
               global.playership[dummy].sprite_index = spr_goliath_enemy;
               global.playership[dummy].ship_turning_rate = 3;
               global.playership[dummy].minspeed = 1;
               global.playership[dummy].velocity_maximum = 5;               
          break;
         }
   break;
  
   //Respawn Packet
   case 10:
        tele = instance_create(readushort(0), readushort(0), obj_teleport_other);
        tele.mid = dummy;
   break;  

   //Primary Switched
   case 11:
        global.playerprimary[dummy] = readbyte(0);
   break;
      
   //Change snapdir
   case 13:
        global.playership[dummy].snapdir = readbyte(0)-100;
   break;
   
   //Begin Firing Primary weapon
   case 14:
        global.primaryRNG[dummy] = readushort(0);
   break;

      //A Deathmatch is over
   case TIME_UP:
        chatline_add(readstring(0), c_maroon);
        chatline_add(readstring(0), c_blue);
        switch(readbyte(0))
        {
         case 0:
              chatline_add("The match has ended in a draw.", c_white);
         break;
         case 1:
              chatline_add("Red Team has won the match.", c_maroon);
         break;
         case 2:
              chatline_add("Blue Team has won the match.", c_navy);
         break;
        }
        alarm[2] = 180;
   break;
   
   //Begin Firing Primary weapon
   case 15:
        global.playership[dummy].ship_status_hacked = true;
        global.playership[dummy].alarm[5] = 90;        
   break;

    //A player leaves the game
   case CLIENT_DROP:
        //Get info from leaving player
        droppedname = readstring(0);
        //Destroy the removed player
        with(global.playership[dummy])
         instance_destroy();
        //Create a dud to intercept remaining messages
        global.playership[dummy] = instance_create(-2000, -2000, obj_dud);
        //Send a notice to your chat
        chatline_add(readstring(0), c_maroon)        
        if(global.team[dummy] = 0)
         chatcolor[4] = c_maroon;
        else
         chatcolor[4] = c_navy;
   break;
  }
 }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//This part of the step event is the personal checks
//Things here will not be sent to/received by other players.

pinged += 1;

if(fadetoblack = 1)
{
    blackalpha += 0.04;
    if(blackalpha &gt;= 1)
        room_goto(rm_aftermatch);
}

audio_listener_position(view_xview[0]+view_wview[0]/2, view_yview[0]+view_hview[0]/2, 0);
 
//Handle announcements
switch(announcing)
{
 case 1:
      announcealpha += 0.05;
      if(announcealpha = 1)
      {
       alarm[10] = 240;
       announcing = 2;
      }
 break;
 case 3:
      announcealpha -= 0.05;
      if(announcealpha = 0)
       announcing = 0;
 break;
}

if(!instance_exists(view_object[0]))
 view_object[0] = obj_ship;
//Handle background positioning
if((view_xview[0]&gt;0&amp;&amp;view_xview[0]+view_wview[0]&lt;room_width))
{
    if(global.spacemap = 1)
    { 
        background_hspeed[0]=view_object.hspeed/1.2;
        background_hspeed[2]=(view_object.hspeed+back_extrahspeed)/2;
        background_hspeed[3]=(view_object.hspeed+back_extrahspeed)/3;
        background_hspeed[4]=(view_object.hspeed+back_extrahspeed)/4;
        background_hspeed[5]=(view_object.hspeed+back_extrahspeed)/5.5;
        background_hspeed[6]=(view_object.hspeed+back_extrahspeed)/8;
    }
    
    background_hspeed[1]=view_object.hspeed/1.2;
}
else
{
    background_hspeed[0]=0;
    background_hspeed[1]=0;
    background_hspeed[2]=back_extrahspeed/2;
    background_hspeed[3]=back_extrahspeed/3;
    background_hspeed[4]=back_extrahspeed/4;
    background_hspeed[5]=back_extrahspeed/5.5;
    background_hspeed[6]=back_extrahspeed/8;
}
if((view_yview[0]&gt;0&amp;&amp;view_yview[0]+view_hview[0]&lt;room_height))
{
    if(global.spacemap = 1)
    { 
        background_vspeed[0]=view_object.vspeed/1.2;
        background_vspeed[2]=(view_object.vspeed+back_extravspeed)/2;
        background_vspeed[3]=(view_object.vspeed+back_extravspeed)/3;
        background_vspeed[4]=(view_object.vspeed+back_extravspeed)/4;
        background_vspeed[5]=(view_object.vspeed+back_extravspeed)/5.5;
        background_vspeed[6]=(view_object.vspeed+back_extravspeed)/8;
    }
    
    background_vspeed[1]=view_object.vspeed/1.2;
}
else
{
    background_vspeed[0]=0;
    background_vspeed[1]=0;
    background_vspeed[2]=back_extravspeed/2;
    background_vspeed[3]=back_extravspeed/3;
    background_vspeed[4]=back_extravspeed/4;
    background_vspeed[5]=back_extravspeed/5.5;
    background_vspeed[6]=back_extravspeed/8;
}


//Rotate cursor parts
global.rot1 += 2.5;
global.rot2 -= 4;
global.rot3 += 6;

//Handle Goliath Weaponsmith Bay
if(global.selected_ship[global.mymid] = 3)
 weaponsmith(dstock);

//Find the player farthest from you, but within view range
farthestdist = 0;
farthesttarget = -1;
for(i = 0; i &lt; 8; i += 1)
{
 if(i = global.mymid) continue;
 if(global.activated[i] = 0 &amp;&amp; i &gt; 0) continue;
 if(global.playership[i] = view_object) continue;
 loldist = point_distance(view_object.x, view_object.y, global.playership[i].x, global.playership[i].y);
 if(loldist &lt;= 740 &amp;&amp; loldist &gt; farthestdist)
 {
  farthestdist = loldist;
  farthesttarget = global.playership[i];
 }
}

//Targetting
//Target the enemy closest to the cursor
if(obj_ship.armor &gt; 0)
 foundtarget = instance_nearest(mouse_x,mouse_y,prnt_enemy);

//Check if there is a target
if(farthesttarget &gt; -1)
{
    view_focusx = farthesttarget.x;
    if(farthesttarget.x &lt; 64)
        view_focusx = 66;
    if(farthesttarget.x &gt; room_width-64)
        view_focusx = room_width-66;
    view_focusy = farthesttarget.y;
    if(farthesttarget.y &lt; 64)
        view_focusy = 66;
    if(farthesttarget.y &gt; room_height-64)
        view_focusy = room_height-66;
        
 //Check if the target is moving out of view
 if(view_hview[0] &lt; 1480 &amp;&amp; view_wview[0] &lt; room_width-increx &amp;&amp;
  
 (view_focusx &lt; view_xview[0]+64 || view_focusx &gt; view_xview[0]+view_wview[0]-64 || view_focusy&lt;view_yview[0]+64 || view_focusy &gt; view_yview[0]+view_hview[0]-64))
 {
  //Expand the view to keep it seen
  view_wview[0] += increx;
  view_hview[0] += increy;
  stall = 1;
 }
 //Check if the view is larger than normal
 if(view_hview[0] &gt; viewheight)
 {
  //Check if the target is moving closer
  if(stall = 1 &amp;&amp; view_focusx &gt; view_xview[0]+128 &amp;&amp; view_focusx &lt; view_xview[0]+view_wview[0]-128 &amp;&amp; view_focusy &gt; view_yview[0]+128 &amp;&amp; view_focusy &lt; view_yview[0]+view_hview[0]-128)
  {
   //Shrink the view as needed
   stall = 0;
   alarm[6] = 180;
  }
 }
}
else
{
 //If there is no target, check to see if the view is larger
 //than normal
 if(stall = 1 &amp;&amp; view_hview[0] &gt; viewheight)
 {
  //Shrink the view as needed
   stall = 0;
   alarm[6] = 180;
 }
 foundtarget = -1;
}

//Convert the distance to target to be used by the targetting meter
if(foundtarget != -1 &amp;&amp; instance_exists(foundtarget))
 targetdist = ceil(point_distance(view_object.x, view_object.y, foundtarget.x, foundtarget.y)/29.6);
else
 targetdist = 0;
//Center your ship
screen_shake(view_object);
//Update match time
if(global.matchtype != "stock")
{
global.time = date_current_datetime();
if(minute = 0)
 global.matchcolor = c_red;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
