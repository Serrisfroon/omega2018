<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Set the size of the GUI to be the same as the screen port
display_set_gui_size(view_wport[0], view_hport[0]);

//Reset the position of the audio listener
audio_listener_position(0, 0, 0);

//Set the weapon icon HUD based on the icon order
secondary_icon_order = global.shipselect*(global.secondary_type[4]+1)-1;

//Start the match with your first energy secondary_selected selected
secondary_selection_position = 2;

//Hold the cursor rotations locally for faster lookup
cursor_rotation[1] = 0;
cursor_rotation[2] = 0;
cursor_rotation[3] = 0;

//Initialize the goliath flag- for handling its passive
if(global.selected_ship[global.mymid] = 3)
    goliath_selected = true;
else
    goliath_selected = false;

//Store the activated flag and playership reference variables locally for faster lookup
for(i = 0; i &lt; 8; i += 1)
{
    player_activated[i] = global.activated[i];
    player_object[i] = global.playership[i]
}

//Initialize the variables used to draw the armor and shield bars
draw_armor_bar = 1;
draw_shield_bar = 1;

//Initialize the variable that holds the previous value of the player's primary firing direction. For comparisons.
previous_primary_direction = -1;

//Initialize the variable that holds the scaling ratio of the screen
screen_scaling_ratio = view_hview[0]/480;

//Hold the map type locally for faster lookup
map_type_space = global.spacemap;

//Initialize the coordinate variables that control the screen offset to create a shaking effect
modify_x = 0;
modify_y = 0;

//Loop through the four secondary weapons
for(i = 1; i &lt;= 4; i++)
{
    //Hold the max stock for each secondary locally
    max_secondary_stock[i] = global.secondary_stock[i];
    //Initialize the weapon availability coloring variables
    weapon_avaialable_color[i] = c_white;
}
      
//Hold the value of the image index of weapon icons corresponding to your team
team_color_index = global.team[global.mymid]-1;

//Initialize announcement variables
announcement_message = "";      //Holds the message string
announcement_alpha = 0;         //Holds the alpha value of the announcement
announcement_color = c_maroon;  //Holds the text color of the announcement
announcement_stage = 0;         //Holds the stage variable that controls what the announcement is doing

//Initialize chat-related variables
chat_open = false;      //Flag that says whether or not the extended chat window is open
chat_flashing = '';                  //Holds the ending typing character
alarm[5] = 10;                  //Set the time until the ending typing character changes

//Initialize netcode-related timer variables
ping_frame_count = 0;       //Holds the number of frames that have passed since the last ping update
ping_send_timer = 0;        //Holds the time(in frames) until the next ping packet is sent
update_packet_timer = 0;    //Holds the time(in frames) until the next refresh packet is sent
disconnect_timer = 0;       //Holds the time(in frames) since the last update packet was received by the host

//Initialize view position
screen_shake_intensity = 0;

//Merge walls together
global.wallsprite = spr_empty;
global.drawwallsprite = spr_empty;
makenewwall = 0;
alarm[4] = 2;

//Set the targetting values
targeted_object = -1;
distance_to_target = 0;
thisplayer = 0;

//Initialize the notice chat
for(i = 0; i &lt;= 4; i += 1)
{
    chatline[i] = "";
    chatcolor[i] = c_black;
    chatalpha[i] = 0;
}
for(i = 0; i &lt;= 16; i += 1)
{
    extchatline[i] = "";
}

//Initialize the flag controlling when the vie zooms back in
view_zoom_out_flag = false;

//Set the view increments
view_x_increase = 24;
view_y_increase = 15;
view_height_base = 750;
view_hview[0] = view_height_base;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Shader variables
uni_time = shader_get_uniform(shd_magnify,"time");
var_time_var = 0;

uni_mouse_pos = shader_get_uniform(shd_magnify,"mouse_pos");

uni_resolution = shader_get_uniform(shd_magnify,"resolution");

uni_circle_radius = shader_get_uniform(shd_magnify,"circleRadius");
var_circle_radius = 0.204; 

uni_circle_zoom_min = shader_get_uniform(shd_magnify,"minZoom");
var_circle_zoom_min = 0.40; 

uni_circle_zoom_max = shader_get_uniform(shd_magnify,"maxZoom");
var_circle_zoom_max = 0.60;

magnify1 = surface_create(view_wport[0], view_hport[0]);
magnify2 = surface_create(view_wport[0], view_hport[0]);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="10">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Begin fading out the displayed announcement.</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>announcement_stage = 3;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="6">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Zoom the view in slowly</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string> //Check if the view is larger than normal
 if(view_hview[0] &gt; view_height_base &amp;&amp; view_zoom_out_flag = false)
 {
   alarm[6] = 1;
   view_wview[0] -= view_x_increase/3;
   view_hview[0] -= view_y_increase/3;
 }

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="5">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Change the ending typing character</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Change the flashing text
if(chat_flashing = '')
 chat_flashing = '|';
else
 chat_flashing = '';
//Set time until next flash
alarm[5] = 10;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Consolidate all the wall objects</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Create a surface large enough to hold all wall drawings
global.wallsurface = surface_create(ceil(room_width/16), ceil(room_height/16));

//Begin drawing to the surface
surface_set_target(global.wallsurface);
//Clear the surface
draw_clear_alpha(c_black, 1);
//Have each wall mark its position with a square
draw_set_alpha(1);
with(obj_wall)
{
 draw_set_color(c_dkgray);
 draw_rectangle(x/16, y/16, (x+sprite_width)/16, (y+sprite_height)/16, 0);
}
//Create a sprite from the surface
global.wallsprite = sprite_create_from_surface(global.wallsurface, 0, 0, ceil(room_width/16), ceil(room_height/16), 1, 0, 0, 0);
//Stop drawing to the surface
surface_reset_target();
//Free the surface from memory
surface_free(global.wallsurface);

//Stop execution if there were no walls in the room
if(instance_number(obj_wall) &lt; 1)
 exit;

makenewwall = 1;

//Destroy all walls
with(obj_wall)
 instance_destroy();
 



//Create one of these objects
superwall = instance_create(0, 0, obj_bigwall);
superwall.sprite_index = global.wallsprite;
//Scale the object to actual size
superwall.image_xscale = 16;
superwall.image_yscale = 16;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Create a screen fading effect</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Create the effect to fade the screen to black
instance_create(0, 0, obj_fade_screen);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Force-Quit the game</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Close the udp stocket if you are a client
if(global.master = false)
{
    closesocket(global.udpsock);
    closesocket(global.host);
}
//End 39dll
dllfree();
//Return to the appropriate room
if(global.public_game = true)
    room_goto(rm_public_game);
else
    room_goto(rm_private_game);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Respawn the player</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//respawn if there is stock left
if(global.ships &gt; 0)
{
 tele = instance_create(global.myspawnx, global.myspawny, obj_teleport);
 tele.mid = global.mymid;
 //destroy the error stopper
 with(obj_ship_placeholder)
    instance_destroy();
  //Send respawn to host
  clearbuffer(0);
  packet_label_write(10, global.mymid);
  writeushort(global.myspawnx, 0);
  writeushort(global.myspawny, 0);
  //Send to everyone if host
  if(global.master = true)
   client_sendall(0, 0);
  else
  //Send to host if client
   sendmessage(global.host, 0, 0, 0);
}
else
{
 //Check for game over if host
 if(global.master = true &amp;&amp; alarm[2] &lt;= 0)
 {
  //Add the player to the elimination count
  if(global.team[global.mymid] = 1)
  {
   global.redteamout += 1;
   //Check if all of red team is eliminated
   if(global.redteam = global.redteamout)
   {
    //Send it to your chat
    chatline_add("Red Team has been eliminated.", c_maroon);
    lolcolor[3] = 1;
    chatline_add("Blue Team has won the match.", c_navy);
    lolcolor[4] = 2;
    obj_mod.announcement_stage  = 1;
    obj_mod.announcement_message = "Operation Failed";
    obj_mod.announcement_color = c_navy;
    obj_mod.announcement_alpha = 0;
    global.outcome = 1;

    //Send the message to all clients
    clearbuffer(0);
    packet_label_write(5, global.mymid);
    writebyte(lolcolor[3], 0);
    writestring(chatline[3], 0);
    writebyte(lolcolor[4], 0);
    writestring(chatline[4], 0);
    client_sendall(0, 0);
    //Set time until return to waiting room
    alarm[2] = 180;
   }
  }
  else
  {
   global.blueteamout += 1;
   //Check if all of blue team is eliminated
   if(global.blueteam = global.blueteamout)
   {
    //Send it to your chat
    chatline_add("Blue Team has been eliminated.", c_navy);
    lolcolor[3] = 2;
    chatline_add("Red Team has won the match.", c_maroon);
    lolcolor[4] = 1;
    obj_mod.announcement_stage  = 1;
    obj_mod.announcement_message = "Operation Failed";
    obj_mod.announcement_color = c_red;
    obj_mod.announcement_alpha = 0;
    global.outcome = 1;
    //Send the message to all clients
    clearbuffer(0);
    packet_label_write(5, global.mymid);
    writebyte(lolcolor[3], 0);
    writestring(chatline[3], 0);
    writebyte(lolcolor[4], 0);
    writestring(chatline[4], 0);
    client_sendall(0, 0);
    //Set time until return to waiting room    
    alarm[2] = 180;
   }
  }
 }
 else
 {
  //Send elimination to host
  clearbuffer(0);
  packet_label_write(4, global.mymid);
  sendmessage(global.host, 0, 0, 0);
 }  
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>switch(ping_send_timer)
{
 case 0:
      clearbuffer(0);
      packet_label_write(1, global.mymid);
      if(obj_ship.armor &gt; 0)
       writebyte(status_compress(obj_ship.smoke, obj_ship.ship_status_hacked, obj_ship.ship_status_shocked), 0);
      else
       writebyte(0, 0);
      writebyte(0, 0);
      writebyte(fps, 0);
      client_sendall(0, 0);   
      ping_send_timer = 120;   
 break;
 default:
         ping_send_timer -= 1;
 break;
}

switch(update_packet_timer)
{
 case 0:
      update_packet_timer = 5;
      clearpack();
      packet_label_write(0, global.mymid);
      crush(round(obj_ship.direction*10), 3600, 0);
      crush(round(obj_ship.facedir*10), 3600, 0);
      if(obj_ship.armor &gt; 0)
      {
       crush(round(obj_ship.x*10), 65000, 0);
       crush(round(obj_ship.y*10), 65000, 0);
      }
      else
      {
       crush(65000, 65000, 0);
       crush(65000, 65000, 0);
      }
      
      crush(round(abs(obj_ship.speed*100)), 2500, 0);
      crush(prediction_compress(obj_ship.predictturn, obj_ship.predictspeed, obj_ship.multiplayer_primary_fire_flag), 72, 0);
      if(obj_ship.multiplayer_primary_fire_flag = true)
      {
       update_packet_timer = 3;
       crush(global.primaryRNG[global.mymid], 15, 0);
       crush(round(obj_ship.newdir*10), 3600, 0);
       switch(global.primary)
       {
        case 4:
            //Find out which ship you are targetting
            if(obj_mod.targeted_object &lt;= -1)
             testtarget = 8;
            else
            {
            testtarget = -1;
            while(true)
            {
             testtarget+=1;
            if(testtarget != global.mymid)
              if(global.playership[testtarget] = obj_mod.targeted_object)
              break;
            }
            }
            crush(testtarget, 8, 0);
        break;
        case 6:
             crush(min(100, round(point_distance(obj_ship.x, obj_ship.y, mouse_x, mouse_y)/10)), 100, 0);
        break;
        case 7:
             if(targeted_object != -1)
              crush(targeted_object.mid, 10, 0);
             else
              crush(10, 10, 0);
        break;
       }
      }
      for(i = 1; i &lt; 8; i += 1)
      {
       if(global.activated[i] &lt;= 0) continue;
       if(global.playership[i] = obj_dud) continue;
       crush(round(global.playership[i].direction*10), 3600, 0);
       crush(round(global.playership[i].facedir*10), 3600, 0);
       crush(clamp(round(global.playership[i].x*10), 0, 65000), 65000, 0);
       crush(clamp(round(global.playership[i].y*10), 0, 65000), 65000, 0);
       crush(round(global.playership[i].speed*100), 2500, 0);
       crush(prediction_compress(global.playership[i].turning, global.playership[i].speeding, global.playership[i].multiplayer_primary_fire_flag), 72, 0);
       if(global.playership[i].multiplayer_primary_fire_flag = true)
       {
        update_packet_timer = 3;
        crush(round(global.playership[i].newdir*10), 3601, 0);
        switch(global.playerprimary[i])
        {
         case 4:
              crush(global.playership[i].flankcurve, 8, 0);
         break;
         case 6:
              crush(min(100, global.playership[i].crossfiredist), 100, 0);
         break;
         case 7:
              crush(global.playership[i].siphontarget, 10, 0);
         break;
        }
       }
      }
      //Send to everyone
      bufferpack();
      client_sendall(0, 0);
 break;
 default:
    update_packet_timer -= 1;
 break;   
 
}

if(obj_player.primary_direction != previous_primary_direction)
{
    previous_primary_direction = obj_player.primary_direction;
    clearbuffer(0);
    packet_label_write(13, global.mymid);
    crush(obj_player.primary_direction/5, 0, 73);
    client_sendall(0, 0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
//This part of the step event deals with player communications
//This is the host object, so it must relay messages to other
//players
//check_disconnect();

//Start the infinite while loop. It will cycle through until 
//there are no new messages
while(true)
 {
  //Initialize variables
  //var size;
  size = 0;
  //Check each player one by one for a new message
  for(i = 0; i &lt; ds_list_size(global.clients); i += 1)
  {
   //Check for a tcp message
   size = receivemessage(client_port(i), 0, 0);
   //If a message was received, break the for loop
   if(size &gt; 0) {
   break;}
  }
  //If no message was received, break the while loop
  if(size &lt; 0) break;
  if(size = 0) break;////////////////////
  //Read the label byte to find the packet id and the player who sent it
  lollabel = readbyte(0);
  packet_label_read(lollabel);

  
  //Perform the correct acton depending on what packet has been sent
  switch(packet)
  {
  
   //The player sends its refresh packet
   case 0:
        if(playerdisconnect[dummy] &gt; -700)
            playerdisconnect[dummy] = 0;
        uncrushbegin();
        global.playership[dummy].direction = uncrush(3600, 0)/10;
        global.playership[dummy].facedir = uncrush(3600, 0)/10;
        global.playership[dummy].x = uncrush(65000, 0)/10;
        global.playership[dummy].y = uncrush(65000, 0)/10;
        global.playership[dummy].speed = uncrush(2500, 0)/100;
        decomp = uncrush(72, 0);
        prediction_decompress(decomp);
        if(global.playership[dummy].multiplayer_primary_fire_flag = true)
        {
         global.primaryRNG[global.mymid] = uncrush(15, 0);
         global.playership[dummy].newdir = uncrush(3600, 0)/10;
         switch(global.playerprimary[dummy])
         {
          case 4:
               global.playership[dummy].flankcurve = uncrush(8, 0);
          break;
          case 6:
               global.playership[dummy].crossfiredist = uncrush(100, 0)*10;
          break;
          case 7:
               global.playership[dummy].siphontarget = uncrush(10, 0);
          break;
         }         
        }
   break;
   
   //The player sends its ping packet
   case 1:
        lolstatuses = readbyte(0);
        status_decompress(lolstatuses);
        if(global.playership[dummy].ship_status_hacked = true)
        {
         global.playership[dummy].thisturn = 0;
         global.playership[dummy].turning = 0;
         global.playership[dummy].speeding = 2;
        }
        global.ping[dummy] = readbyte(0)*20;
        global.playerfps[dummy] = readbyte(0);
        client_sendall(0, 0);    
   break;
   
   //The player uses a secondary weapon
   case 2:
        receive_secondary();
   break;
   
   //The player is defeated
   case 3:
        playerdisconnect[dummy] = -600;
        defeatmid = readbyte(0);
        anotherspawn[dummy] = readbyte(0);
        with(obj_turret)
            if(mid = obj_mod.dummy)
                instance_destroy();
        with(obj_turret_enemy)
            if(mid = obj_mod.dummy)
                instance_destroy();
        //Update score
        if(defeatmid != 20)
         global.kills[defeatmid] += 1;
        global.deaths[dummy] += 1;
        switch(global.matchtype)
        {
         case "stock":
              //Reduce your team's score by 1
              switch(global.team[dummy])
              {
               case 1:
                    global.redscore -= 1;
               break;
               case 2:
                    global.bluescore -= 1;
               break;
              }
         break;
         case "death":
              //Increase other team's score by 1
              switch(global.team[dummy])
              {
               case 1:
                    global.bluescore += 1;
               break;
               case 2:
                    global.redscore += 1;
               break;
              }
         break;
        }
        //Create a defeated ship in the player's place
        defeat = instance_create(global.playership[dummy].x, global.playership[dummy].y, obj_deadother);
        defeat.direction = global.playership[dummy].direction;
        defeat.speed = global.playership[dummy].speed+1;
        defeat.sprite_index = global.playership[dummy].sprite_index;
        defeat.dummy = dummy;
        if(global.playership[dummy] = view_object[0])
         view_object[0] = defeat;
        //Send a defeat notice to chat
        //Send it to your chat
        switch(readbyte(0))
        {
         case 1:         
              newcolor = c_maroon;
         break;
         case 2:
              newcolor = c_navy;
         break;
        }
        chatline_add(readstring(0), newcolor);
        //Create an announcement
        if(obj_mod.announcement_stage = 0 &amp;&amp; defeatmid != 20)
        {
         obj_mod.announcement_stage  = 1;
         obj_mod.announcement_message = global.othername[defeatmid]+" defeated "+global.othername[dummy];
         obj_mod.announcement_color = newcolor;
        }

        //Reset targetting if currently targetting this ship
        if(targeted_object = global.playership[dummy])
        {
         targeted_object = -1;
         distance_to_target = point_distance(obj_ship.x, obj_ship.y, -10000, -10000);
        }
        //Destroy the designated ship
        with(global.playership[dummy])
         instance_destroy();
        //Create an object to intercept late info
        global.playership[dummy] = instance_create(0, 0, obj_dud);                
        client_sendall(0, dummy);
   break;
   
   //A player is eliminated in a stock match
   case 4:
        if(alarm[2] &gt; 0)
         exit;
        playerdisconnect[dummy] = -700;
        //Add the player to the elimination count
        if(global.team[dummy] = 1)
        {
         global.redteamout += 1;
         if(global.redteam = global.redteamout)
         {
          //Send it to your chat
          //Send it to your chat
          chatline_add("Red Team has been eliminated.", c_maroon);
          lolcolor[3] = 1;
          chatline_add("Blue Team has won the match.", c_navy);
          lolcolor[4] = 2;
          obj_mod.announcement_stage  = 1;
          obj_mod.announcement_alpha = 0;
          if(global.team[global.mymid] = 1)
          {
           obj_mod.announcement_message = "Operation Failed";
           global.outcome = 1;
           obj_mod.announcement_color = c_navy;
          }
          else
          {
           obj_mod.announcement_message = "Operation Successful";
           obj_mod.announcement_color = c_navy;
           global.outcome = 0;
          }         

          //Send the message to all clients
          clearbuffer(0);
          packet_label_write(5, global.mymid);
          writebyte(lolcolor[3], 0);
          writestring(chatline[3], 0);
          writebyte(lolcolor[4], 0);
          writestring(chatline[4], 0);
          client_sendall(0, 0);
          //Set time until returning to waiting room
          alarm[2] = 180;
         }
        }
        else
        {
         global.blueteamout += 1;
         if(global.blueteam = global.blueteamout)
         {
          //Send it to your chat
          //Send it to your chat
          chatline_add("Blue Team has been eliminated.", c_navy);
          lolcolor[3] = 2;
          chatline_add("Red Team has won the match.", c_maroon);
          lolcolor[4] = 1;
          obj_mod.announcement_stage  = 1;
          obj_mod.announcement_alpha = 0;
          if(global.team[global.mymid] = 1)
          {
           obj_mod.announcement_message = "Operation Successful";
           obj_mod.announcement_color = c_maroon;
           global.outcome = 0;
          }
          else
          {
           obj_mod.announcement_message = "Operation Failed";
           obj_mod.announcement_color = c_maroon;
           global.outcome = 1;
          }
          clearbuffer(0);
          packet_label_write(5, global.mymid);
          writebyte(lolcolor[3], 0);
          writestring(chatline[3], 0);
          writebyte(lolcolor[4], 0);
          writestring(chatline[4], 0);
          client_sendall(0, 0);
          //Set time until returning to waiting room
          alarm[2] = 180;
         }
        }
   break;
   
   //Prediction Packet
   case 6:
        client_sendall(1, dummy);
   break;  
   
   //Chat Message
   case 7:
        //Put the message in your chat
        chatline_add(readstring(0), c_white);
        client_sendall(0, dummy);  
   break;
   
   //Ship checkin. Sets the correct image and ship-dependant variables 
   //for a player when it spawns
   case 9:
        global.playership[dummy].mid = readbyte(0);
        ship = readbyte(0);
        //If the player is on red team, set choose a red ship and set
        //the right values
        if(global.team[dummy] = 1)
         switch(ship)
         {
          case 1: //Alphastar
               global.playership[dummy].sprite_index = spr_alphastar;
               global.playership[dummy].ship_turning_rate = 5;
               global.playership[dummy].minspeed = 2;
               global.playership[dummy].velocity_maximum = 7;
          break;
          case 2: //Swiftwing
               global.playership[dummy].sprite_index = spr_swiftwing;
               global.playership[dummy].ship_turning_rate = 8;
               global.playership[dummy].minspeed = 4;
               global.playership[dummy].velocity_maximum = 10;               
          break;
          case 3: //Goliath
               global.playership[dummy].sprite_index = spr_goliath;
               global.playership[dummy].ship_turning_rate = 3;
               global.playership[dummy].minspeed = 1;
               global.playership[dummy].velocity_maximum = 5;
          break;
         }
        else
        //If the player is on blue team, set choose a blue ship and set
        //the right values
         switch(ship)
         {
          case 1: //Alphastar
               global.playership[dummy].sprite_index = spr_alphastar_enemy;
               global.playership[dummy].ship_turning_rate = 5;
               global.playership[dummy].minspeed = 2;
               global.playership[dummy].velocity_maximum = 7;               
          break;
          case 2: //Swiftwing
               global.playership[dummy].sprite_index = spr_swiftwing_enemy;
               global.playership[dummy].ship_turning_rate = 8;
               global.playership[dummy].minspeed = 4;
               global.playership[dummy].velocity_maximum = 10;               
          break;
          case 3: //Goliath
               global.playership[dummy].sprite_index = spr_goliath_enemy;
               global.playership[dummy].ship_turning_rate = 3;
               global.playership[dummy].minspeed = 1;
               global.playership[dummy].velocity_maximum = 5;               
          break;
         }
        client_sendall(0, dummy);
   break;
   
   //Respawn Packet
   case 10:
        dummyx = readushort(0);
        dummyy = readushort(0);
        tele = instance_create(dummyx, dummyy, obj_teleport_other);
        tele.mid = dummy;
        client_sendall(0, dummy);        
   break;  

   //Primary Switched
   case 11:
        global.playerprimary[dummy] = uncrush(0, 73);
        client_sendall(0, dummy);
   break;
   
   //Change primary direction
   case 13:   
        global.playership[dummy].primary_direction = uncrush(0, 73)*5;
        client_sendall(0, dummy);
   break;
   
   //Begin Firing Primary weapon
   case 14:
        global.primaryRNG[dummy] = readushort(0);
        client_sendall(0, dummy);
   break;
   
   //Begin Firing Primary weapon
   case 15:
        global.playership[dummy].ship_status_hacked = true;
        global.playership[dummy].alarm[5] = 90;        
        client_sendall(0, dummy);
   break;

   //A player leaves the game
   case CLIENT_DROP:
        //Get info from leaving player
        droppedname = readstring(0);
        //Drop the player and add the drop to the count
        client_drop(dummy);
        //Destroy the removed player
        with(global.playership[dummy])
         instance_destroy();
        //Create a dud to intercept remaining messages
        global.playership[dummy] = instance_create(-2000, -2000, obj_dud);
        //Send a notice to your chat
        chatline_add(readstring(0), c_maroon)
        if(global.team[dummy] = 1)
         chatcolor[4] = c_maroon;
        else
         chatcolor[4] = c_navy;
        //Relay the info to other players
        client_sendall(0, 0); 
        //Add the player to the elimination count
        if(global.team[dummy] = 1)
        {
            //Check if all of red team is eliminated
            if(global.redteam = global.redteamout)
            {
                //Send it to your chat
                chatline_add("Red Team has been eliminated.", c_maroon);
                lolcolor[3] = 1;
                chatline_add("Blue Team has won the match.", c_navy);
                lolcolor[4] = 2;
                if(global.team[global.mymid] = 1)
                {
                    global.outcome = 1;
                    obj_mod.announcement_message = "Operation Failed";
                }
                else
                {
                    global.outcome = 0;
                    obj_mod.announcement_message = "Operation Successful";
                }
                
                obj_mod.announcement_stage  = 1;
                obj_mod.announcement_color = c_navy;
                obj_mod.announcement_alpha = 0;
            
                //Send the message to all clients
                clearbuffer(0);
                packet_label_write(5, disi);
                writebyte(lolcolor[3], 0);
                writestring(chatline[3], 0);
                writebyte(lolcolor[4], 0);
                writestring(chatline[4], 0);
                client_sendall(0, 0);
                //Set time until return to waiting room
                alarm[2] = 180;
            }
        }
        else
        {
            //Check if all of blue team is eliminated
            if(global.blueteam = global.blueteamout)
            {
                //Send it to your chat
                chatline_add("Blue Team has been eliminated.", c_navy);
                lolcolor[3] = 2;
                chatline_add("Red Team has won the match.", c_maroon);
                lolcolor[4] = 1;
                obj_mod.announcement_stage  = 1;
                obj_mod.announcement_color = c_maroon;
                obj_mod.announcement_alpha = 0;
                if(global.team[global.mymid] = 2)
                {
                    global.outcome = 1;
                    obj_mod.announcement_message = "Operation Failed";
                }
                else
                {
                    global.outcome = 0;
                    obj_mod.announcement_message = "Operation Successful";
                }
                //Send the message to all clients
                clearbuffer(0);
                packet_label_write(5, dummy);
                writebyte(lolcolor[3], 0);
                writestring(chatline[3], 0);
                writebyte(lolcolor[4], 0);
                writestring(chatline[4], 0);
                client_sendall(0, 0);
                //Set time until return to waiting room    
                alarm[2] = 180;
            }
        }   break;
  }
 }
//Listen for a new player
newclient = tcpaccept(global.listen, true);
if(newclient &gt; 0)
{
    //Reject the new player
    clearbuffer(0);
    writebyte(CLIENT_UNABLE, 0);
    sendmessage(newclient, 0, 0, 0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//This part of the step event is the personal checks
//Things here will not be sent to/received by other players.

//Handle announcements
switch(announcement_stage)
{
    case 1:
        announcement_alpha += 0.05;
        if(announcement_alpha = 1)
        {
            alarm[10] = 240;
            announcement_stage = 2;
        }
    break;
    case 3:
        announcement_alpha -= 0.05;
        if(announcement_alpha = 0)
            announcement_stage = 0;
    break;
}

if((view_xview[0] &gt; 0 &amp;&amp; view_xview[0]+view_wview[0] &lt; room_width))
{
    if(map_type_space = 1)
    { 
        background_hspeed[0]=view_object.hspeed/1.2;
        background_hspeed[2]=(view_object.hspeed+back_extrahspeed)/2;
        background_hspeed[3]=(view_object.hspeed+back_extrahspeed)/3;
        background_hspeed[4]=(view_object.hspeed+back_extrahspeed)/4;
        background_hspeed[5]=(view_object.hspeed+back_extrahspeed)/5.5;
        background_hspeed[6]=(view_object.hspeed+back_extrahspeed)/8;
    }
    background_hspeed[6]=(view_object.hspeed+back_extrahspeed)/8;    
    background_hspeed[1]=view_object.hspeed/1.2;
}
else
{
    background_hspeed[0]=0;
    background_hspeed[1]=0;
    background_hspeed[2]=back_extrahspeed/2;
    background_hspeed[3]=back_extrahspeed/3;
    background_hspeed[4]=back_extrahspeed/4;
    background_hspeed[5]=back_extrahspeed/5.5;
    background_hspeed[6]=back_extrahspeed/8;
}
if((view_yview[0]&gt;0&amp;&amp;view_yview[0]+view_hview[0]&lt;room_height))
{
    if(map_type_space = 1)
    { 
        background_vspeed[0]=view_object.vspeed/1.2;
        background_vspeed[2]=(view_object.vspeed+back_extravspeed)/2;
        background_vspeed[3]=(view_object.vspeed+back_extravspeed)/3;
        background_vspeed[4]=(view_object.vspeed+back_extravspeed)/4;
        background_vspeed[5]=(view_object.vspeed+back_extravspeed)/5.5;
        background_vspeed[6]=(view_object.vspeed+back_extravspeed)/8;
    }
    
    background_hspeed[6]=(view_object.vspeed+back_extrahspeed)/8;
    background_vspeed[1]=view_object.vspeed/1.2;
}
else
{
    background_vspeed[0]=0;
    background_vspeed[1]=0;
    background_vspeed[2]=back_extravspeed/2;
    background_vspeed[3]=back_extravspeed/3;
    background_vspeed[4]=back_extravspeed/4;
    background_vspeed[5]=back_extravspeed/5.5;
    background_vspeed[6]=back_extravspeed/8;
}

//Rotate the cursor parts
cursor_rotation[1] += 2.5;
cursor_rotation[2] -= 4;
cursor_rotation[3] += 6;

//Handle Goliath Weaponsmith Bay
//if(goliath_selected = true)
//    weaponsmith(dstock);

//Find the player farthest from you, but within target range
//Initialize variables to hold the distance to the farthest possible target, and the farthest possible target
var distance_to_farthest_target = 0;
var farthest_target = -1;
//Loop through all players
for(i = 1; i &lt; 8; i += 1)
{
    //Skip this player if it isn't activated
    if(player_activated[i] = 0) continue;
    //Skip this player it it's you
    if(i = global.mymid) continue;
    //Calculate the distance to this player
    var distance_to_target = point_distance(view_object.x, view_object.y, player_object[i].x, player_object[i].y);
    //Check if the player is within view range
    if(distance_to_target &lt;= 900)
    { 
        //Also check if this player is farther away then the player previous marked fartheest away
        if(distance_to_target &gt; distance_to_farthest_target)
        {
            distance_to_farthest_target = distance_to_target;   //Save this distance as the farthest distance
            farthest_target = player_object[i];                 //Save this player as the farthest possible target
        }
    }
}

//Targetting
oldtarget = targeted_object;
//Target the enemy closest to the cursor if you are still alive
if(obj_player.armor &gt; 0)
    targeted_object = instance_nearest(mouse_x, mouse_y, obj_dummy_enemy);
else
{
    targeted_object = -1;
    exit;
}

//Check if there is a target
if(farthest_target != -1)
{
    //Initialize the x value of the second focus point of the view
    var view_focusx = farthest_target.x;
    //Make sure that the focus point if not close the edges of the room
    if(farthest_target.x &lt; 64)
        view_focusx = 66;
    else
        if(farthest_target.x &gt; room_width-64)
            view_focusx = room_width-66;
    //Initialize the y value of the second focus point of the view
    var view_focusy = farthest_target.y;
    //Make sure that the focus point if not close the edges of the room
    if(farthest_target.y &lt; 64)
        view_focusy = 66;
    else
        if(farthest_target.y &gt; room_height-64)
            view_focusy = room_height-66;
    
    //Check if the view has room to expand
    if(view_hview[0] &lt; 1480)
        if(view_wview[0] &lt; room_width-view_x_increase)
            //Check if the target is moving out of view
            if(view_focusx &lt; view_xview[0]+64 || view_focusx &gt; view_xview[0]+view_wview[0]-64 || view_focusy&lt;view_yview[0]+64 || view_focusy &gt; view_yview[0]+view_hview[0]-64)
            {
                //Expand the view to keep it seen
                view_wview[0] += view_x_increase;
                view_hview[0] += view_y_increase;
                view_zoom_out_flag = true;
            }
            
    //Check if the view is larger than normal
    if(view_hview[0] &gt; view_height_base)
    {
        //Check if the target is moving closer
        if(view_zoom_out_flag = true)
            if(view_focusx &gt; view_xview[0]+128)
                if(view_focusx &lt; view_xview[0]+view_wview[0]-128)
                    if(view_focusy &gt; view_yview[0]+128)
                        if(view_focusy &lt; view_yview[0]+view_hview[0]-128)
                        {
                            //Shrink the view as needed
                            view_zoom_out_flag = false;
                            alarm[6] = 180;
                        }
    }
}
else
{
    //If there is no target, check to see if the view is larger
    //than normal
    if(view_zoom_out_flag = true)
        if(view_hview[0] &gt; view_height_base)
        {
            //Shrink the view as needed
            view_zoom_out_flag = false;
            alarm[6] = 180;
        }
    targeted_object = -1;
}
//Convert the distance to target to be used by the targetting meter
if(targeted_object != -1)
{
    distance_to_target = ceil(point_distance(view_object.x, view_object.y, targeted_object.x, targeted_object.y)/33.33);
    if(distance_to_target &gt; 27)
        targeted_object = -1;
}
else
    distance_to_target = 0;


//Creeate a new cursor effect
if(targeted_object != -1)
    if(targeted_object != oldtarget)
    {
        with(obj_lockoncursor)
            instance_destroy();
        newlockon = instance_create(0, 0, obj_lockoncursor);
        newlockon.target = targeted_object;
        newlockon.direction = global.rot2;
    }

//Center your ship
screen_shake(view_object);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="61">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>switch(secondary_selection_position)
{
 case 2:
    event_perform(ev_keypress, ord('2'));
 break;
 case 42:
    event_perform(ev_keypress, ord('3'));
 break;
 case 82:
    event_perform(ev_keypress, ord('1'));
 break;
} 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="60">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>switch(secondary_selection_position)
{
 case 2:
    event_perform(ev_keypress, ord('3'));
 break;
 case 42:
    event_perform(ev_keypress, ord('1'));
 break;
 case 82:
    event_perform(ev_keypress, ord('2'));
 break;
} 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="54">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Exit if the player is alive
if(obj_ship.armor &gt; 0)
 exit;

//Loop to find the mid value of the currently viewed player
for(i = 0; i &lt; 8; i += 1)
{
 //Skip if not active
 if(global.activated[i] = 0 &amp;&amp; i &gt; 0) continue;
 if(global.playership[i] = global.object_view)
 {
  //Reset view trigger
  foundview = 0;
  //Loop through the mids following the viewed mid
  for(ii = i+1; ii &lt; 8; ii += 1)
  {
   //Skip inactive slots and dead players
   if(global.activated[ii] = 0 &amp;&amp; ii &gt; 0) continue;  
   if(global.playership[ii].x &gt; room_width || global.playership[ii] = obj_dud) continue;
   //Set the view to follow the found player
   global.object_view = global.playership[ii];
   foundview = 1;
   break;
  }
  //If no player has yet been found, loop through mids before the viewed mid
  if(foundview = 0)
   for(ii = 0; ii &lt; i; ii += 1)
   {
    //Skip inactive slots and dead players
    if(global.activated[ii] = 0 &amp;&amp; ii &gt; 0) continue;  
    if(global.playership[ii].x &gt; room_width || global.playership[ii] = obj_dud) continue;
    //Set the view to follow the found player
    global.object_view = global.playership[ii];
    break;
   }
  break;
 }
}
view_object = global.object_view;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Exit if the player is alive
if(obj_ship.armor &gt; 0)
 exit;

//Loop to find the mid value of the currently viewed player
for(i = 0; i &lt; 8; i += 1)
{
 //Skip if not active
 if(global.activated[i] = 0 &amp;&amp; i &gt; 0) continue;
 if(global.playership[i] = view_object)
 {
  //Reset view trigger
  foundview = 0;
  //Loop through the mids following the viewed mid
  for(ii = i+1; ii &lt; 8; ii += 1)
  {
   //Skip inactive slots and dead players
   if(global.activated[ii] = 0 &amp;&amp; ii &gt; 0) continue;  
   if(global.playership[ii].x &gt; room_width || global.playership[ii] = obj_dud) continue;
   //Set the view to follow the found player
   view_object = global.playership[ii];
   foundview = 1;
   break;
  }
  //If no player has yet been found, loop through mids before the viewed mid
  if(foundview = 0)
   for(ii = 0; ii &lt; i; ii += 1)
   {
    //Skip inactive slots and dead players
    if(global.activated[ii] = 0 &amp;&amp; ii &gt; 0) continue;  
    if(global.playership[ii].x &gt; room_width || global.playership[ii] = obj_dud) continue;
    //Set the view to follow the found player
    view_object = global.playership[ii];
    break;
   }
  break;
 }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Delete temporary data from memory
sprite_delete(global.wallsprite);
background_delete(global.starback[0]);
background_delete(global.starback[1]);
background_delete(global.starback[2]);
init_menuback();
switch(global.matchroom)
{
    case rm_deepspace:
         background_delete(global.background[0]);
         background_delete(global.background[2]);
         background_delete(global.background[3]);
         background_delete(global.background[5]);
    break;
    case rm_katrinbase:
         background_delete(global.background[0]);
         background_delete(global.backpiece_1); 
         background_delete(global.backpiece_2); 
         background_delete(global.backpiece_3); 
    break;
    case rm_combatzone:
         background_delete(global.background[0]);
         background_delete(global.background[2]);
         background_delete(global.background[3]);
         background_delete(global.background[4]);
         background_delete(global.background[5]);
         background_delete(global.background[7]);
         background_delete(global.backpiece_1); 
         background_delete(global.backpiece_2); 
         background_delete(global.backpiece_3); 
    break;
    case rm_victatundra:
         background_delete(global.background[0]);
         background_delete(global.background[2]);
         background_delete(global.background[4]);
         background_delete(global.background[7]); 
         background_delete(global.backpiece_1); 
         background_delete(global.backpiece_2); 
         background_delete(global.backpiece_3); 
         background_delete(global.cloudback);        
    break;
    case rm_barricade:
         background_delete(global.background[0]);
         background_delete(global.background[1]);
         background_delete(global.background[2]);
         background_delete(global.background[4]);
         background_delete(global.background[5]);
         background_delete(global.background[7]);      
         background_delete(global.backpiece_1); 
         background_delete(global.backpiece_2); 
         background_delete(global.backpiece_3); 
    break;
    case rm_victabase:
         background_delete(global.background[0]);
         background_delete(global.backpiece_1); 
         background_delete(global.backpiece_2); 
         background_delete(global.backpiece_3);        
    break;
    case rm_satellite:
         background_delete(global.background[0]);
         background_delete(global.background[1]);
         background_delete(global.background[2]);
         background_delete(global.background[4]);
         background_delete(global.background[5]);
         background_delete(global.background[7]);      
    break;
    case rm_katrincoast:
         background_delete(global.background[0]);
         background_delete(global.backpiece_1); 
         background_delete(global.backpiece_2); 
         background_delete(global.backpiece_3);        
    break;
    case rm_spacedepot:
         background_delete(global.background[0]);
         background_delete(global.background[2]);
         background_delete(global.background[4]);
         background_delete(global.background[5]);
         background_delete(global.background[7]);      
         background_delete(global.backpiece_1); 
         background_delete(global.backpiece_2); 
         background_delete(global.backpiece_3); 
    break;
    case rm_orbitstation:
         background_delete(global.background[0]);
         background_delete(global.background[2]);
         background_delete(global.background[4]);
         background_delete(global.background[5]);
         background_delete(global.background[7]);      
         background_delete(global.backpiece_1); 
         background_delete(global.backpiece_2); 
         background_delete(global.backpiece_3); 
    break;
} 


//audio_stop_all();
draw_texture_flush();
cleanmem();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var current_secondary = obj_player.secondary_selected;
var current_secondary_stock = global.secondary_stock[current_secondary];

screen_scaling_ratio = view_hview[0]/480;
texture_set_interpolation(false);
//If you are targeting an enemy, draw the targetting cursor
if(targeted_object &gt; -1 &amp;&amp; !instance_exists(obj_lockoncursor))
 draw_sprite_ext(spr_targetcursor, distance_to_target, (targeted_object.x-view_xview[0])/screen_scaling_ratio, (targeted_object.y-view_yview[0])/screen_scaling_ratio, 1, 1, global.rot2, c_white, 0.7);
 
//Draw announcement text, if there is any
if(announcement_alpha &gt; 0)
{
 draw_set_halign(fa_center);
 draw_set_valign(fa_middle);
 draw_set_font(fnt_bigtext);
 draw_set_alpha(announcement_alpha);
 draw_text_bordered(view_wport[0]/2, 130, announcement_message, 1, 2, announcement_color, c_white);
 draw_set_halign(fa_left);
 draw_set_valign(fa_top);
}

//Draw equipped weapons
check_weapons();

//Draw the weapon icons and ammo bars depending on the icon order
switch(secondary_icon_order)
{
    case 0: //The order is E-H-H-E
        draw_sprite_ext(global.secondaryimage[1], team_color_index, 2, 73, 1, 1, 0, weapon_avaialable_color[1], 1);
        draw_sprite_ext(global.secondaryimage[2], team_color_index, 42, 73, 1, 1, 0, weapon_avaialable_color[2], 1);
        draw_sprite_part_ext(spr_deploybar, 0, 0, 0, (global.secondary_stock[2]/max_secondary_stock[2])*26, 36, 42, 73, 1, 1, c_white, 1);
        draw_sprite_ext(global.secondaryimage[3], team_color_index, 82, 73, 1, 1, 0, weapon_avaialable_color[3], 1);
        draw_sprite_part_ext(spr_deploybar, 0, 0, 0, (global.secondary_stock[3]/max_secondary_stock[3])*26, 36, 82, 73, 1, 1, c_white, 1);
        draw_sprite_ext(global.secondaryimage[4], team_color_index, 122, 73, 1, 1, 0, weapon_avaialable_color[4], 1);
    break;
    case 1: //The order is E-E-H-H
        draw_sprite_ext(global.secondaryimage[1], team_color_index, 2, 73, 1, 1, 0, weapon_avaialable_color[1], 1);
        
        draw_sprite_ext(global.secondaryimage[2], team_color_index, 42, 73, 1, 1, 0, weapon_avaialable_color[2], 1);
        
        draw_sprite_ext(global.secondaryimage[3], team_color_index, 82, 73, 1, 1, 0, weapon_avaialable_color[3], 1);
        draw_sprite_part_ext(spr_deploybar, 0, 0, 0, (global.secondary_stock[3]/max_secondary_stock[3])*26, 36, 82, 73, 1, 1, c_white, 1);
        
        draw_sprite_ext(global.secondaryimage[4], team_color_index, 122, 73, 1, 1, 0, weapon_avaialable_color[4], 1);
        draw_sprite_part_ext(spr_deploybar, 0, 0, 0, (global.secondary_stock[4]/max_secondary_stock[4])*26, 36, 122, 73, 1, 1, c_white, 1);    
    break;
    case 2: //The order is E-E-H-E
        draw_sprite_ext(global.secondaryimage[1], team_color_index, 2, 73, 1, 1, 0, weapon_avaialable_color[1], 1);
        
        draw_sprite_ext(global.secondaryimage[2], team_color_index, 42, 73, 1, 1, 0, weapon_avaialable_color[2], 1);
        
        draw_sprite_ext(global.secondaryimage[3], team_color_index, 82, 73, 1, 1, 0, weapon_avaialable_color[3], 1);
        draw_sprite_part_ext(spr_deploybar, 0, 0, 0, (global.secondary_stock[3]/max_secondary_stock[3])*26, 36, 82, 73, 1, 1, c_white, 1);
        
        draw_sprite_ext(global.secondaryimage[4], team_color_index, 122, 73, 1, 1, 0, weapon_avaialable_color[4], 1);    
    break;
    case 3: //The order is E-E-E-H
        draw_sprite_ext(global.secondaryimage[1], team_color_index, 2, 73, 1, 1, 0, weapon_avaialable_color[1], 1);
        
        draw_sprite_ext(global.secondaryimage[2], team_color_index, 42, 73, 1, 1, 0, weapon_avaialable_color[2], 1);
        
        draw_sprite_ext(global.secondaryimage[3], team_color_index, 82, 73, 1, 1, 0, weapon_avaialable_color[3], 1);
        
        draw_sprite_ext(global.secondaryimage[4], team_color_index, 122, 73, 1, 1, 0, weapon_avaialable_color[4], 1);
        draw_sprite_part_ext(spr_deploybar, 0, 0, 0, (global.secondary_stock[4]/max_secondary_stock[4])*26, 36, 122, 73, 1, 1, c_white, 1);        
    break;
    case 4: //The order is H-H-H-E
        draw_sprite_ext(global.secondaryimage[1], team_color_index, 2, 73, 1, 1, 0, weapon_avaialable_color[1], 1);
        draw_sprite_part_ext(spr_deploybar, 0, 0, 0, (global.secondary_stock[1]/max_secondary_stock[1])*26, 36, 2, 73, 1, 1, c_white, 1);
        
        draw_sprite_ext(global.secondaryimage[2], team_color_index, 42, 73, 1, 1, 0, weapon_avaialable_color[2], 1);
        draw_sprite_part_ext(spr_deploybar, 0, 0, 0, (global.secondary_stock[2]/max_secondary_stock[2])*26, 36, 42, 73, 1, 1, c_white, 1);
        
        draw_sprite_ext(global.secondaryimage[3], team_color_index, 82, 73, 1, 1, 0, weapon_avaialable_color[3], 1);
        draw_sprite_part_ext(spr_deploybar, 0, 0, 0, (global.secondary_stock[3]/max_secondary_stock[3])*26, 36, 82, 73, 1, 1, c_white, 1);
        
        draw_sprite_ext(global.secondaryimage[4], team_color_index, 122, 73, 1, 1, 0, weapon_avaialable_color[4], 1);
    break;
    case 5: //The order is E-H-H-H
        draw_sprite_ext(global.secondaryimage[1], team_color_index, 2, 73, 1, 1, 0, weapon_avaialable_color[1], 1);
        
        draw_sprite_ext(global.secondaryimage[2], team_color_index, 42, 73, 1, 1, 0, weapon_avaialable_color[2], 1);
        draw_sprite_part_ext(spr_deploybar, 0, 0, 0, (global.secondary_stock[2]/max_secondary_stock[2])*26, 36, 42, 73, 1, 1, c_white, 1);
        
        draw_sprite_ext(global.secondaryimage[3], team_color_index, 82, 73, 1, 1, 0, weapon_avaialable_color[3], 1);
        draw_sprite_part_ext(spr_deploybar, 0, 0, 0, (global.secondary_stock[3]/max_secondary_stock[3])*26, 36, 82, 73, 1, 1, c_white, 1);
        
        draw_sprite_ext(global.secondaryimage[4], team_color_index, 122, 73, 1, 1, 0, weapon_avaialable_color[4], 1);
        draw_sprite_part_ext(spr_deploybar, 0, 0, 0, (global.secondary_stock[4]/max_secondary_stock[4])*26, 36, 122, 73, 1, 1, c_white, 1);    
    break;
}

with(obj_weaponflash)
    draw_sprite_ext(sprite_index, image_index, xstart, 73, 1, 1, 0, c_white, 1);
    
//Draw the highlighter
draw_sprite_ext(spr_numbers_selected, 0, secondary_selection_position, 73, 1, 1, 0, c_white, 1);

//Draw Armor, Shield, Energy, and Ammo bars
if(obj_ship.armor &gt; 0)
{
 armorratio = obj_ship.armor/obj_ship.armor_maximum;
 if(armorratio &lt; draw_armor_bar)
  draw_armor_bar -= 0.02;
 else
  draw_armor_bar = armorratio;
 draw_sprite_part_ext(spr_armorbar, 0, 0, 0, 4+draw_armor_bar*233, 86, 0, 0, 1, 1, c_white, 1);
}
if(obj_ship.shield &gt; 0)
{
 shieldratio = obj_ship.shield/obj_ship.shield_maximum;
 if(shieldratio &lt; draw_shield_bar)
  draw_shield_bar -= 0.02;
 else
  draw_shield_bar = shieldratio;
 draw_sprite_part_ext(spr_shieldbar, 0, 0, 0, 4+draw_shield_bar*233, 86, 0, 0, 1, 1, c_white, 0.4+(0.6*shieldratio));
}
else
 draw_shield_bar = 0;
if(obj_ship.energy &gt; 0)
{
    draw_sprite_part_ext(spr_energybar, 0, 0, 0, 107+(obj_ship.energy/100)*130, 86, 0, 0, 1, 1, c_white, 1);
}
draw_sprite_ext(spr_overheatbar, 0, 0, 0, 1, 1, 0, c_white, 1);
if(instance_exists(obj_overheatshine))
    draw_sprite_ext(spr_overheatshine, obj_overheatshine.image_index, 0, 0, 1, 1, 0, c_white, 1);


if(current_secondary_stock &gt; 0)
    draw_sprite_part_ext(spr_ammobar, max_secondary_stock[current_secondary], 0, 0, 81+(current_secondary_stock/max_secondary_stock[current_secondary])*157, 64, 0, 0, 1, 1, c_white, 1);

//Draw the gauge backgrounds
draw_sprite_ext(spr_gauges, 0, 0, 0, 1, 1, 0, c_white, 1);
draw_sprite_ext(spr_weaponicons, secondary_icon_order, 0, 0, 1, 1, 0, c_white, 1);

//Draw the match status
switch(global.matchtype)
{
 case "stock":
      switch(global.team[global.mymid])
      {
       case 1:
            for(i = 0; i &lt; global.ships; i += 1)
             draw_sprite_ext(spr_lifecount, global.shipselect, i*shipspace, 0, 1, 1, 0, c_white, .7);
       break;
       case 2:
            for(i = 0; i &lt; global.ships; i += 1)
             draw_sprite_ext(spr_lifecount, global.shipselect+3, i*shipspace, 0, 1, 1, 0, c_white, .7);
       break;
      }
 break;
 case "death":
      draw_set_font(fnt_chat);
      draw_set_alpha(0.7);
      draw_set_color(global.matchcolor);
      minute = floor(date_minute_span(global.time, global.endtime));
      second = floor(date_second_span(global.time, global.endtime)-minute*60);
      draw_text_transformed(10, 5, string(minute)+":"+string(second), 1, 1, 0);
 break;
}

//Draw the radar
draw_sprite_ext(spr_radar, 0, view_wport[0], 0, 1, 1, 0, c_white, 1);
//Draw the map of the walls
draw_sprite_part_ext(global.wallsprite, 0, (obj_ship.x-1600)/16, (obj_ship.y-1600)/16, 200, 200, view_wport[0]-113, 11, 0.5, 0.5, c_white, 0.8);
//Check which loop to set to
for(i = 0; i &lt; 8; i += 1)
{
 //Check to make sure the current number is not your own if you are not master
 if(global.mymid != i &amp;&amp; (global.activated[i] = 1 || i = 0))
 {
  radarpoint = global.team[i]-1;
  //Set radar point position
  //radardist = point_distance(obj_ship.x, obj_ship.y, global.playership[radarplayer].x, global.playership[radarplayer].y);
  radarx = ((global.playership[i].x-obj_ship.x)*50)/1500;
  radary = ((global.playership[i].y-obj_ship.y)*50)/1500;
  //Draw radar point if it is in range
  if(abs(radarx) &lt;51 &amp;&amp; abs(radary) &lt; 51)
   draw_sprite_ext(spr_radar_player, radarpoint, view_wport[0]-65+radarx, 62+radary, 1, 1, global.playership[i].image_angle, c_white, 1);
 }
}
  
draw_set_font(fnt_chat);
//Draw the framerate
draw_set_color(c_white);
draw_text_transformed(10, view_hport[0]-20, string(fps), 1, 1, 0);

//Draw the chat bar if chatting
switch(obj_mod.chat_open)
{
 case true:
      draw_set_color(c_white);
      draw_sprite_ext(spr_chatinput, 0, 0, view_hport[0], 1, 1, 0, c_white, 1);
      //Stop more input if max is reached
      if(string_length(keyboard_string) &gt; 60)
       keyboard_string = string_copy(keyboard_string, 0, 60);
            
      //Undo '#'
      keyboard_string = string_replace(keyboard_string, '#', '');
      
      //Find the correct text to fit into the bar
      for(i = string_length(keyboard_string); i &gt;= 0; i -= 1)
       if(string_width(string_copy(keyboard_string, i, string_length(keyboard_string)-i)) &gt; 280 || i = 0)
       {
        startchat = i;
        stopchat = string_length(keyboard_string)+1-i;
        break;  
       }
      //Draw the text in the chat bar
      draw_text_transformed(14, 454, string_copy(keyboard_string, startchat, stopchat)+chat_flashing, 1, 1, 0);
      draw_sprite_ext(spr_extchat, 0, 0, 0, 1, 1, 0, c_white, 1);
      //draw chat
      draw_set_color(c_white);
      for(i = 0; i &lt;= 16; i += 1)
      {
       draw_text_ext_transformed(14, (406-(i*18)), extchatline[16-i], 9, 300, 1, 1, 0);
      }
 break;
 case false:
      //draw chat
      for(i = 0; i &lt;= 4; i += 1)
      {
       draw_set_color(chatcolor[4-i]);
       draw_set_alpha(chatalpha[4-i]);
       draw_text_ext_transformed(14, (406-(i*18)), chatline[4-i], 9, 300, 1, 1, 0);
       chatalpha[4-i] -= 0.005;
      } 
 break;
}

//Show score window when ` is pressed
draw_set_alpha(1);
if(keyboard_check_direct(vk_tab))
{
 global.playerfps[global.mymid] = fps;
 draw_sprite_ext(spr_pscores, 0, view_wport[0], view_hport[0], 1, 1, 0, c_white, 1);
 draw_set_font(fnt_chat);
 for(i = 0; i &lt; 8; i += 1)
 {
  if(global.activated[i] = 0 &amp;&amp; i &gt; 0) continue;
  switch(global.team[i])
  {
   case 1:
        draw_set_color(c_red);
   break;
   case 2:
        draw_set_color(c_navy);
   break;
  }
  draw_set_halign(fa_left);
  draw_text_transformed(view_wport[0]-247, view_hport[0]-(246-(i*20)), global.othername[i], 1, 1, 0);
  draw_set_halign(fa_center);
  draw_text_transformed(view_wport[0]-110, view_hport[0]-(246-(i*20)), string(global.playerfps[i]), 1, 1, 0);
  draw_text_transformed(view_wport[0]-82, view_hport[0]-(246-(i*20)), string(global.ping[i]), 1, 1, 0);
  draw_text_transformed(view_wport[0]-56, view_hport[0]-(246-(i*20)), string(global.kills[i]), 1, 1, 0);
  draw_text_transformed(view_wport[0]-29, view_hport[0]-(246-(i*20)), string(global.deaths[i]), 1, 1, 0);
 }
 draw_set_color(c_black);
 draw_text_transformed(view_wport[0]-52, view_hport[0]-305, string(global.redscore), 1, 1, 0);
 draw_text_transformed(view_wport[0]-52, view_hport[0]-288, string(global.bluescore), 1, 1, 0); 
 draw_set_halign(fa_left);
}


//Draw the cursor
draw_sprite_ext(spr_cursor, 0, (mouse_x-view_xview[0])/screen_scaling_ratio, (mouse_y-view_yview[0])/screen_scaling_ratio, 0.7, 0.7, cursor_rotation[1], c_white, 0.7);
draw_sprite_ext(spr_cursor, 1, (mouse_x-view_xview[0])/screen_scaling_ratio, (mouse_y-view_yview[0])/screen_scaling_ratio, 0.7, 0.7, cursor_rotation[2], c_white, 0.7);
draw_sprite_ext(spr_cursor, 2, (mouse_x-view_xview[0])/screen_scaling_ratio, (mouse_y-view_yview[0])/screen_scaling_ratio, 0.7, 0.7, cursor_rotation[3], c_white, 0.7);
texture_set_interpolation(true);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_stasis();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="115">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if window_get_fullscreen()
{
    window_set_fullscreen(false);
}
else
{
    window_set_fullscreen(true);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="51">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check if you are chatting
if(obj_mod.chat_open = true) exit;
audio_play_sound(snd_changeweapon, 1, 0);

secondary_selection_position = 82;
//Switch to the correct new attack
global.playership[global.mymid].secondary_selected = 3;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="50">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check if you are chatting
if(obj_mod.chat_open = true) exit;
audio_play_sound(snd_changeweapon, 1, 0);
secondary_selection_position = 42;
//Switch to the correct new attack
global.playership[global.mymid].secondary_selected = 2;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="49">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check if you are chatting
if(obj_mod.chat_open = true) exit;
audio_play_sound(snd_changeweapon, 1, 0);
secondary_selection_position = 2;
//Switch to the correct new attack
global.playership[global.mymid].secondary_selected = 1;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="27">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(global.musictoggle = 0)
{   
    audio_stop_all();
    audio_play_sound(music_quasar, 1, 1);
}
//Check if you are host
if(global.master = true)
{
 //Remove the game from the games list if you made the game on it
 if(global.public_game = true)
        sql_remove(global.myipaddress); 
 host_quit();
 //Set time until exiting the game
 alarm[1]=2;
 exit;
}
//If you are a client, send the disconnection message 
//to the host and return to the connecting
//room
clearbuffer(0);
writebyte(CLIENT_DROP, 0);
writebyte(global.mymid, 0);
writestring(global.name, 0);
if(obj_ship.ismine = 1)
 writestring(global.name+" has RAGEQUIT the game.", 0)
else
 writestring(global.name+" has left the game.", 0) 
sendmessage(global.host, 0, 0, 0);
alarm[1]=4;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>switch(obj_mod.chat_open)
{
 case false:
      obj_mod.chat_open = true;
      global.playership[global.mymid].ship_disabled = true;
      keyboard_string = '';
      //Send a prediction to show the stopping
      with(obj_ship)
      {
       predictspeed = 2;
       predictturn = 0;
       thisturn = 0;
       //Send the prediction
       clearbuffer(0);
       packet_label_write(6, global.mymid);
       writebyte(prediction_compress(predictturn, predictspeed, 0), 0);
       //Send to everyone if host
       if(global.master = true)
        client_sendall(1, 0);
       else
        //Send to host if client
        sendmessage(global.udpsock, global.playerip, global.playerport, 0);
      }
 break;
 case true:
      obj_mod.chat_open = false;
      global.playership[global.mymid].ship_disabled = true;
      //Check if text was typed
      if(keyboard_string = '') break;
      
      //Send a prediction to show movement
      with(obj_player)
      {
        if(ship_status_hacked = false)
            ship_disabled = false;
       predictspeed = 0;
       predictturn = 0;
       thisturn = 0;
       //Send the prediction
       clearbuffer(0);
       packet_label_write(6, global.mymid);
       writebyte(prediction_compress(predictturn, predictspeed, 0), 0);
       //Send to everyone if host
       if(global.master = true)
        client_sendall(1, 0);
       else
        //Send to host if client
        sendmessage(global.udpsock, global.playerip, global.playerport, 0);
      }      
      //create the new chat line and take note of its middle
      sendline = global.name+": "+ keyboard_string;
      middle = string_length(sendline)/2;
      //Break up text if there is no space near the middle
      if(string_replace(string_copy(sendline, middle-4, 8), ' ', '-') = string_copy(sendline, middle-4, 8) &amp;&amp; string_length(sendline) &gt; 30)
       sendline = string_insert(' ', sendline, middle);
            
      //Send it to your chat
      chatline_add(sendline, c_white);
      //Send the defeat to everyone
      clearbuffer(0);
      packet_label_write(7, global.mymid);
      writestring(chatline[4], 0);
      //Send to everyone if host
      if(global.master = true)
       client_sendall(0, 0);
      else
       //Send to host if client
       sendmessage(global.host, 0, 0, 0);
 break;
} 
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
