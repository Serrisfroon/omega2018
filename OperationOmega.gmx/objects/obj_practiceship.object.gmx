<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_alphastar</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_ship</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>invincible = 0.6;
alarm[10] = 180;
view_object = id;

nextturnblur = 0;
totalturnblur = 0;


redirectfire = 0;

//Create your graze field
field = instance_create(x, y, obj_grazefield);

//Set all barriers to ignore you
with(obj_barrier_enemy)
 ignore = 1;

//Set ability to shoot
shoot = 0;
nowshoot = 0;
abilityactive = 0;
global.playership[global.mymid] = obj_ship;

warping = -1;

//Set initial target values
target = -1;
targetx = 0;
targety = 0;

controlling = true;

//Initialize flame trail particles
deployhits = 0;
system = part_system_create();

//Initialize Chain control
chain = 0;
chained = 0;
chainer = 0;

//Intialize whip count
whips = 0;
stardust = 0;

//Initialize flame effect
for(i = 0; i &lt;= 11; i += 1)
{
 flamelife[i] = 0;
 flamex[i] = 0;
 flamey[i] = 0;
 flamedir[i] = 0;
 flameimage[i] = 0;
}
nextflame = 0;

//Set energy to max
energy = 100;
heat = 50;
cooldown = 1;
beserk = 0;
beserking= 0;

//Initialize energy regenration and set time until regen speeds up
energygain = 0.3*global.framerate;
alarm[3] = 120/global.framerate;



//Set ship-dependant values: shield, armor, max shield, max armor, and how 
//fast you turn automatically
switch(global.shipselect)
{
 case 1: //Alphastar
      shield = 30;
      armor = 100;
      maxshield = 30;
      maxarmor = 100;
      autoturn = 2*global.framerate;
      forceturn = 3*global.framerate;
      maxspeed = 7*global.framerate;
      lowspeed = 2*global.framerate;
      regentime = 300/global.framerate;
      regenrate = 0.05*global.framerate;
      controlturn = 0.75;
      if(global.framerate = 2)
       controlturn = 3;       
 break;
 case 2: //Swiftwing
      shield = 30;
      armor = 50;
      maxshield = 30;
      maxarmor = 50;
      autoturn = 3*global.framerate;
      forceturn = 5*global.framerate;
      maxspeed = 10*global.framerate;
      lowspeed = 4*global.framerate;
      regentime = 300/global.framerate;
      regenrate = 0.05*global.framerate;
      controlturn = 1.2;
      if(global.framerate = 2)
       controlturn = 4.8;       
 break;
 case 3: //Goliath
      shield = 50;
      armor = 130;
      maxshield = 50;
      maxarmor = 130;
      autoturn = 1*global.framerate;
      forceturn = 2*global.framerate;
      maxspeed = 5*global.framerate;
      lowspeed = 1*global.framerate;
      regentime = 300/global.framerate;
      regenrate = 0.04*global.framerate;
      controlturn = 0.5;
      if(global.framerate = 2)
       controlturn = 2;       
 break;
}

//Initialize shield regen
alarm[4] = 1;


//Set deploy values
deploystock[1] = 0;
deploystock[2] = 0;
deploystock[3] = 0;
for(i = 1; i &lt;= 3; i += 1)
{
 if(i &gt; 1 &amp;&amp; global.shipselect = 2) continue;
 if(i = 3 &amp;&amp; global.shipselect = 1) continue;
 switch(global.deploy[i])
 {
  case 1:
       deploystock[i] = 4; //Dual Missile
       maxdstock[i] = 4;
       dualmissile = 8;
       if(global.spacesecond = 0)
       {
            deploystock[i] = 5;
            maxdstock[i] = 5;
            dualmissile = 10;       
       }
  break;
  case 2:
       deploystock[i] = 3; //Layer Missile
       maxdstock[i] = 3;
       layermissile = 3;
       if(global.spacesecond = 4)
       {
            deploystock[i] = 4;
            maxdstock[i] = 4;
            layermissile = 4;       
       }
  break;
  case 3:
       deploystock[i] = 3; //Hunter Mine
       maxdstock[i] = 3;
       huntermine = 3;
       if(global.spacesecond = 3)
       {
            deploystock[i] = 4;
            maxdstock[i] = 4;
            huntermine = 4;       
       }
  break;
  case 4:
       deploystock[i] = 4; //Locust Missile
       maxdstock[i] = 4;
       locustmissile = 24;
       if(global.spacesecond = 6)
       {
            deploystock[i] = 5;
            maxdstock[i] = 5;
            locustmissile = 30;       
       }
  break;
  case 5:
       deploystock[i] = 4; //Phantom Mine
       maxdstock[i] = 4;
       phantommine = 4;
       if(global.spacesecond = 7)
       {
            deploystock[i] = 5;
            maxdstock[i] = 5;
            phantommine = 5;       
       }
  break;
  case 6:
       deploystock[i] = 2; //Solus
       maxdstock[i] = 2;
       soluscount = 2;
       if(global.spacesecond = 8)
       {
            deploystock[i] = 3;
            maxdstock[i] = 3;
            soluscount = 3;       
       }
  break;
  case 7:
       deploystock[i] = 4; //Trident Missile
       maxdstock[i] = 4;
       tridentmissile = 12;
       if(global.spacesecond = 13)
       {
            deploystock[i] = 5;
            maxdstock[i] = 5;
            tridentmissile = 15;       
       }
  break;
  case 8:
       deploystock[i] = 3; //Shock Missile
       maxdstock[i] = 3;
       shockmissile = 3;
       if(global.spacesecond = 17)
       {
            deploystock[i] = 4;
            maxdstock[i] = 4;
            shockmissile = 4;       
       }
  break;
  case 9:
       deploystock[i] = 2; //Hacker mine
       maxdstock[i] = 2;
       hackermine = 2;
       if(global.spacesecond = 16)
       {
            deploystock[i] = 3;
            maxdstock[i] = 3;
            hackermine = 3;       
       }
  break;
  case 10:
       deploystock[i] = 4; //Hermit Missile
       maxdstock[i] = 4;
       hermitmissile = 4;
       if(global.spacesecond = 18)
       {
            deploystock[i] = 5;
            maxdstock[i] = 5;
            hermitmissile = 5;       
       }
  break;
  case 11:
       deploystock[i] = 10; //Strike Missile
       maxdstock[i] = 10;
       strikemissile = 10;
  break;
  case 12:
       deploystock[i] = 8; //Strike Mine
       maxdstock[i] = 8;
       strikemine = 8;
       if(global.spacesecond = 20)
       {
            deploystock[i] = 9;
            maxdstock[i] = 9;
            strikemine = 9;       
       }
  break;
  case 13:
       deploystock[i] = 3; //Turret
       maxdstock[i] = 3;
       turret = 3;
       if(global.spacesecond = 21)
       {
            deploystock[i] = 4;
            maxdstock[i] = 4;
            turret = 4;       
       }
  break;
  case 14:
       deploystock[i] = 3; //Split Missile
       maxdstock[i] = 3;
       splitmissile = 3;
       if(global.spacesecond = 28)
       {
            deploystock[i] = 4;
            maxdstock[i] = 4;
            splitmissile = 4;       
       }
  break;
  case 15:
       deploystock[i] = 3; //Cluster Mine
       maxdstock[i] = 3;
       clustermine = 3;
       if(global.spacesecond = 29)
       {
            deploystock[i] = 4;
            maxdstock[i] = 4;
            clustermine = 4;       
       }
  break;
 }
}

//Initialize sparkline node tracking
node = -1;
node2 = -1;
node3 = -1;
//Initialize stardust hit limiter
dusted = 0;

//Initialize damage threshold
threshold = 1;

//Initialize Hacker Mine hack variable
hacked = false;
//Initialize Shock Missile shock variable
shocked = false;

//Initialize chaining
chaining = 0;

hit = 0;
secondary = 0;
//Set damage smoke and initialize smoke alarm(lol)
smoke = 6;
alarm[2] = 1;




//Set the correct colors to be displayed on radar
global.redblue = 0;
global.bluered = 1;
//Change to correct ship image
switch(global.shipselect)
{
 case 1:
      sprite_index = spr_alphastar;
 break;
 case 2:
      sprite_index = spr_swiftwing;
 break;
 case 3:
      sprite_index = spr_goliath;
 break;
}


//Set a new spawn point at random
nextspawn = floor(random(8)-0.01);
if(nextspawn &lt; 0) nextspawn = 0;
global.myspawnx = global.spawnx[nextspawn];
global.myspawny = global.spawny[nextspawn];

//Face the center
direction = point_direction(x, y, room_width/2, room_height/2);
//Initialize facedir. This is your target direction
facedir = direction;
//Set this object to be followed in view
view_object[0] = id;

//Initialize refresh packet rate
refreshing = 0;

//Ragequit variable
ismine = 0;

//Initialize prediction variables
predictturn = 0;
predictspeed = 0;
thisturn = 0;
lastturn = 0;

//Set the ship's mid
mid = global.mymid;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>sound_stop(snd_stardust);
sound_stop(snd_whip);
mask_index = spr_empty;
//Destroy all flame trails
for(i = 0; i &lt; deployhits; i += 1)
 part_emitter_destroy(system, emit[i]);

//Reset targetting
with(obj_mod)
{
 foundtarget = -1;
 targetdist = point_distance(obj_ship.x, obj_ship.y, -10000, -10000);
}

//Create a defeated ship in your place and give it your movement
defeat = instance_create(x, y, obj_practiceship_dead);
defeat.direction = direction;
defeat.speed = speed+1;
defeat.sprite_index = sprite_index;

//Change the view's focus
view_object[0] = defeat;
defeat.alarm[1] = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!instance_exists(chainer))
{
 chained = 0;
 obj_mod.sendping = 0;
 exit;
}
if(chainer.shooting = 0 || chained = 0)
{
 chained = 0;
 obj_mod.sendping = 0;
 exit;
}
alarm[11] = 11;

//Take damage
if(shocked = false)
 shield -= 1;
else
{
 shield -= 0.5;
 armor -= 0.5;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = point_direction(x, y, chainer.x, chainer.y);
 hurt.hurting = id;
}

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>invincible = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="9">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Reset stardust hit limiter
dusted = 0;
threshold = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="8">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Stardust
//If there are parts of the attack left, reset the alarm
//to create them
repeat(global.framerate)
{
if(whips &gt; 0)
{
alarm[8] = 1;
whips -= 1;
}
else
    sound_stop(snd_whip);
//Set target direction
aim = point_direction(x, y, hitx, hity);
//Get movement speed of the current bullet
switch(whips)
{
 case 19:
      whipspeed = 12*global.framerate;
 break;
 case 18:
      whipspeed = 10*global.framerate;
 break;
 case 17:
      whipspeed = 8*global.framerate;
 break;
 case 16:
      whipspeed = 6*global.framerate;
 break;
 case 15:
      whipspeed = 4*global.framerate;
 break;
 case 14:
      whipspeed = 2*global.framerate;
 break;
 case 13:
      whipspeed = 3*global.framerate;
 break;
 case 12:
      whipspeed = 4*global.framerate;
 break;
 case 11:
      whipspeed = 5.5*global.framerate;
 break;
 case 10:
      whipspeed = 7*global.framerate;
 break;
 case 9:
      whipspeed = 8.5*global.framerate;
 break;
 case 8:
      whipspeed = 10*global.framerate;
 break;
 case 7:
      whipspeed = 12*global.framerate;
 break;
 case 6:
      whipspeed = 14*global.framerate;
 break;
 case 5:
      whipspeed = 16*global.framerate;
 break;
 case 4:
      whipspeed = 19*global.framerate;
 break;
 case 3:
      whipspeed = 18*global.framerate;
 break;
 case 2:
      whipspeed = 16*global.framerate;
 break;
 case 1:
      whipspeed = 14.5*global.framerate;
 break;
 case 0:
      whipspeed = 13*global.framerate;
 break;
}
bullet = bullet_create(x, y, "Whip", aim, global.mymid, whipspeed);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Destroy all burn trail effects ad reset effect counter
for(i = 0; i &lt; deployhits; i += 1)
 part_emitter_destroy(system, emit[i]);
depoyhits = 0;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="6">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Reset shock variable
shocked = false;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Reset hack variable
hacked = false;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(shocked = true || beserk = 1)
{
 alarm[4] = 120/global.framerate;
 exit;
}
if(shield &lt; maxshield)
 shield += regenrate;
alarm[4] = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Increase the energy regen rate and set time until next increase
if(shocked = false)
 energygain += 0.2*global.framerate;
alarm[3] = 120/global.framerate;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check if smoking should be occuring
if(smoke &lt; 6)
{
 //Select a color
 switch(floor(random(3)))
 {
  case 0:
       //Make a random color somewhere between pure red and pure yellow
       smokecolor = make_color_rgb(255, random(255), 0);
  break;
  case 1:
       smokecolor = c_gray;
  break;
  case 2:
       smokecolor = c_dkgray;
  break;
 }
 //If smoking is still low, force gray smoke
 if(smoke &gt; 3) smokecolor = c_gray;
 //Create the smoke on the ship
 effect_create_above(ef_smoke, x-6+random(12), y-6+random(12), 0, smokecolor);
}
//Set the time until the next smoke effect, dependant on how bad smoking is
alarm[2]=(6*smoke+10)/global.framerate;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Stardust
//If there are parts of the attack left, reset the alarm
//to create them
repeat(global.framerate)
{
if(stardust &gt; 0)
{
alarm[1] = 1;
stardust -= 1;
}
else
    sound_stop(snd_stardust);
//Set target direction
aim = point_direction(x, y, hitx, hity);
//Create a stardust part
fuse = instance_create(x, y, obj_stardust);
fuse.mid = global.mymid;
fuse.amplified = staramp;
//Set movement dependant on which part it is
switch(stardust)
{
 case 24:
      fuse.speed = 11*global.framerate;
      fuse.direction = aim;
 break;
 case 23:
      fuse.speed = 13*global.framerate;
      fuse.direction = aim+11;
 break;
 case 22:
      fuse.speed = 7*global.framerate;
      fuse.direction = aim-17;
 break;
 case 21:
      fuse.speed = 9*global.framerate;
      fuse.direction = aim+7;
 break;
 case 20:
      fuse.speed = 15*global.framerate;
      fuse.direction = aim+21;
 break;
 case 19:
      fuse.speed = 10*global.framerate;
      fuse.direction = aim-9;
 break;
 case 18:
      fuse.speed = 12*global.framerate;
      fuse.direction = aim+1;
 break;
 case 17:
      fuse.speed = 8*global.framerate;
      fuse.direction = aim-13;
 break;
 case 16:
      fuse.speed = 14*global.framerate;
      fuse.direction = aim+19;
 break;
 case 15:
      fuse.speed = 13*global.framerate;
      fuse.direction = aim-25;
 break;
 case 14:
      fuse.speed = 10*global.framerate;
      fuse.direction = aim+5;
 break;
 case 13:
      fuse.speed = 14*global.framerate;
      fuse.direction = aim-15;
 break;
 case 12:
      fuse.speed = 12*global.framerate;
      fuse.direction = aim+17;
 break;
 case 11:
      fuse.speed = 15*global.framerate;
      fuse.direction = aim-5;
 break;
 case 10:
      fuse.speed = 10*global.framerate;
      fuse.direction = aim+13;
 break;
 case 9:
      fuse.speed = 8*global.framerate;
      fuse.direction = aim-23;
 break;
 case 8:
      fuse.speed = 13*global.framerate;
      fuse.direction = aim+9;
 break;
 case 7:
      fuse.speed = 9*global.framerate;
      fuse.direction = aim-1;
 break;
 case 6:
      fuse.speed = 12*global.framerate;
      fuse.direction = aim+15;
 break;
 case 5:
      fuse.speed = 15*global.framerate;
      fuse.direction = aim-11;
 break;
 case 4:
      fuse.speed = 10*global.framerate;
      fuse.direction = aim-19;
 break;
 case 3:
      fuse.speed = 11*global.framerate;
      fuse.direction = aim-7;
 break;
 case 2:
      fuse.speed = 9*global.framerate;
      fuse.direction = aim+3;
 break;
 case 1:
      fuse.speed = 14*global.framerate;
      fuse.direction = aim-21;
 break;
 case 0:
      fuse.speed = 8*global.framerate;
      fuse.direction = aim+25;
 break;
}
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Fusion
//If there are parts of the attack left, reset the alarm
//to create them
if(fusions &gt; 0)
{
alarm[0] = 5/global.framerate;
fusions -= 1;
}
//Create a fusion part
fuse = instance_create(x, y, obj_fusion);
//Set its movement
fuse.speed = 10*global.framerate;
fuse.direction = 72*fusions;
//Set its target location
fuse.targetx = hitx;
fuse.targety = hity;
fuse.mid = global.mymid;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(invincible = 0.6)
{
    shield = maxshield;
    armor = maxarmor;
}

//Primary weapon fire delay
shoot -= 1;

//Replace graze field
field.x = x;
field.y = y;

//Change the angle of the ship
image_angle = facedir;
//update the direction of this ship
prespeed = speed;
hspeed += lengthdir_x(controlturn, facedir);
vspeed += lengthdir_y(controlturn, facedir);
speed = prespeed;

//Drop speed to half the max if chained
if(chained = 1)
 switch(global.shipselect)
 {
  case 1: //Alphastar
       if(speed &gt; 2*global.framerate)
        speed = 2*global.framerate;
  break;
  case 2: //Swiftwing
       if(speed &gt; 3*global.framerate)
        speed = 3*global.framerate;
  break;
  case 3: //Goliath
       if(speed &gt; 2*global.framerate)
        speed = 2*global.framerate;
  break;
 }
//Handle swiftwing warping
if(warping &gt; -1)
{
 //Perform the warp at the 15th frame
 if(warping = 30)
 {
  x = warpx;
  y = warpy;
  //Check if warped into a wall, and die if you did
  if(obj_bulletcontrol.wallposition[floor(x/32), floor(y/32)] = true)
  {
   //remove mask and reset sprite
   mask_index = spr_empty;
   sprite_index = spr_swiftwing;
   if(global.team[global.mymid] = 2)
    sprite_index = spr_swiftwing_enemy;
   //Destroy this object
   instance_destroy();
  }
 }
 //Return to the normal sprite at the last frame
 if(warping = 0)
 {
  sprite_index = spr_swiftwing;
  if(global.team[global.mymid] = 2)
   sprite_index = spr_swiftwing_enemy;
 }
 //Count toward the next frame
 warping -= 1;
} 

//Handle Beserk Drive
if(global.lolship[global.mymid] = 2 &amp;&amp; armor &lt;= 10 &amp;&amp; beserk = 0)
    beserk = 1;

if(beserk = 1) beserking += 1;

if(facedir &lt; 0) facedir += 360;
if(facedir &gt; 360) facedir -= 360;

//Update burn trail effect positions
for(i = 0; i &lt; deployhits; i += 1)
 part_emitter_region(system, emit[i], x+lengthdir_x(8, direction+effectdir[i]), x+lengthdir_x(8, direction+effectdir[i]), y+lengthdir_y(8, direction+effectdir[i]), y+lengthdir_y(8, direction+effectdir[i]), ps_shape_ellipse, ps_distr_linear);

//Set the minimum speed. If braking, change
//the minimum to 0.
//Brake if S is pressed, if you are chatting, or if you were hacked
speedmin = lowspeed;
if(keyboard_check(ord('S')) || global.chatting = true || hacked = true) 
{
 speedmin = 0;
 speed -= 0.2;
 if(global.framerate = 2)
  speed -= 0.6;       
}

//Lower speed
if(speed &gt; speedmin) 
{
 speed -= 0.04;
 if(global.framerate = 2)
  speed -= 0.12;       
}
else 
 speed = speedmin;

 
//Constantly recover energy the current energy regen rate
if(energy &lt; 100 &amp;&amp; shocked = false &amp;&amp; cooldown = 1) energy += energygain;
//Recover energy faster if beserk
if(beserk = 1 &amp;&amp; energy &lt; 100 &amp;&amp; cooldown = 1) energy += energygain*2;
if(heat &lt; 50) heat += 0.2;
else 
{
    if(cooldown = 0)
        instance_create(x, y, obj_overheatshine);
    cooldown = 1;
}

//Bounce back into the map if you move out of it
if(x &lt; 0 || x &gt; room_width || y &lt; 0 || y &gt; room_height)
{
 if(x &lt; 0)
 {
  x += 10;
  hspeed = -hspeed;
  facedir = direction;
 }
 if(x &gt; room_width)
 {
  x -= 10;
  hspeed = -hspeed;
  facedir = direction;
 }
 if(y &lt; 0)
 {
  vspeed = -vspeed;
  y += 10;
  facedir = direction;
 }
 if(y &gt; room_height)
 {
  vspeed = -vspeed;
  y -= 10;
  facedir = direction;
 }
}

//Autoturn
//Check if autoturn is enabled or if you are chatting
if(speed &gt; 0.5 || keyboard_check(ord('S')) = false || hacked = true)
 exit;

//Set the direction to the cursor
point = point_direction(x, y, mouse_x, mouse_y);

//Check which direction you will turn in, and see if it is different from before
//Turn towards mouse cursor
thisturn = step_towards_direction(point, autoturn);
facedir = direction;
if(thisturn != lastturn)
//Send turning prediction packet if it is different
{
 //Take note of the last direction sent
 lastturn = thisturn;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_clustermine_small_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
armor -= 10/shielded;
//Check if under shock effect
if(shocked = false)
 shield -= 10/shielded;
else
{
 shield -= 5;
 armor -= 5;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

effectdir[deployhits] = point_direction(x, y, other.xprevious, other.yprevious)
//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = effectdir[deployhits];
 hurt.hurting = id;
}

//Create burning trail effect
if(global.dflameseffect = 1)
{
 emit[deployhits] = part_emitter_create(system);
 part_emitter_region(system, emit[deployhits], x+lengthdir_x(8, effectdir[deployhits]), x+lengthdir_x(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), ps_shape_ellipse, ps_distr_linear);
 part_emitter_stream(system, emit[deployhits], obj_partsystem.deployhit, 2);
 effectdir[deployhits] =  direction-effectdir[deployhits];
 alarm[7] = 60/global.framerate;
 deployhits += 1;
}


//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Shake the screen
obj_mod.viewpos = 8;

//Reset shield regen time
alarm[4] = regentime;


//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_splitmissile_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel if this ship was the last targeted
if(other.oldmid = global.mymid)
 exit;
//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
armor -= other.damage/shielded;
//Check if under shock effect
if(shocked = false)
 shield -= other.damage/shielded;
else
{
 shield -= other.damage/2;
 armor -= other.damage/2;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

effectdir[deployhits] = point_direction(x, y, other.xprevious, other.yprevious)
//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = effectdir[deployhits];
 hurt.hurting = id;
}

//Create burning trail effect
if(global.dflameseffect = 1)
{
 emit[deployhits] = part_emitter_create(system);
 part_emitter_region(system, emit[deployhits], x+lengthdir_x(8, effectdir[deployhits]), x+lengthdir_x(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), ps_shape_ellipse, ps_distr_linear);
 part_emitter_stream(system, emit[deployhits], obj_partsystem.deployhit, 2);
 effectdir[deployhits] =  direction-effectdir[deployhits];
 alarm[7] = 60/global.framerate;
 deployhits += 1;
}

//Shake the screen
obj_mod.viewpos = 8;

//Split into two missiles.
if(other.damage &gt; 4)
{
 other.split = instance_create(other.x, other.y, obj_splitmissile_enemy);
 other.split.mid = other.mid;
 other.split.direction = other.direction-30;
 other.split.damage = other.damage-2+other.amplified*2;
 other.split.oldmid = global.mymid;
 other.split = instance_create(other.x, other.y, obj_splitmissile_enemy);
 other.split.mid = other.mid;
 other.split.direction = other.direction+30;
 other.split.damage = other.damage-2+other.amplified*2;
 other.split.oldmid = global.mymid;
}

//Destroy the attack
with(other) 
 instance_destroy();
//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));
 
//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_strikemine_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
armor -= 15/shielded;
//Check if under shock effect
if(other.amplified = 0)
{
 if(shocked = false)
  shield -= 10/shielded;
 else
 {
  shield -= 5;
  armor -= 5;
 }
}
else
 armor -= 10;

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

effectdir[deployhits] = point_direction(x, y, other.xprevious, other.yprevious)
//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = effectdir[deployhits];
 hurt.hurting = id;
}

//Create burning trail effect
if(global.dflameseffect = 1)
{
 emit[deployhits] = part_emitter_create(system);
 part_emitter_region(system, emit[deployhits], x+lengthdir_x(8, effectdir[deployhits]), x+lengthdir_x(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), ps_shape_ellipse, ps_distr_linear);
 part_emitter_stream(system, emit[deployhits], obj_partsystem.deployhit, 2);
 effectdir[deployhits] =  direction-effectdir[deployhits];
 alarm[7] = 60/global.framerate;
 deployhits += 1;
}


//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Shake the screen
obj_mod.viewpos = 8;

//Reset shield regen time
alarm[4] = regentime;


//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_strikemine">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(other.mid != global.mymid || other.recollect = 0)
 exit;
//Take the mine away from your mine count
strikemine += 1;
//Take from the correct deploy count
for(i = 1; i &lt;= 3; i += 1)
{
 if(global.deploy[i] = 12)
  deploystock[i] += 1;
}

with(other)
{
 collected = 1;
 instance_destroy();
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_strikemissile_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
armor -= 12/shielded;
//Check if under shock effect
if(shocked = false)
 shield -= 12/shielded;
else
{
 shield -= 6;
 armor -= 6;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

effectdir[deployhits] = point_direction(x, y, other.xprevious, other.yprevious)
//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = effectdir[deployhits];
 hurt.hurting = id;
}

//Create burning trail effect
if(global.dflameseffect = 1)
{
 emit[deployhits] = part_emitter_create(system);
 part_emitter_region(system, emit[deployhits], x+lengthdir_x(8, effectdir[deployhits]), x+lengthdir_x(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), ps_shape_ellipse, ps_distr_linear);
 part_emitter_stream(system, emit[deployhits], obj_partsystem.deployhit, 2);
 effectdir[deployhits] =  direction-effectdir[deployhits];
 alarm[7] = 60/global.framerate;
 deployhits += 1;
}

//Shake the screen
obj_mod.viewpos = 8;

//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));
 
//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_counterfield_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if too soon for this ship
if(other.breaker = global.mymid &amp;&amp; other.breakerhit = 0)
    exit;
//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
        
obj_mod.frag = other.mid;    
with(obj_fragmentmissile_enemy)
    if(mid = obj_mod.frag)
    {
        target = global.playership[global.mymid];
        go = 3;
    }
        
//Take damage
armor -= 2/shielded;
//Check if under shock effect
if(shocked = false)
 shield -= 2/shielded;
else
{
 shield -= 1;
 armor -= 1;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

effectdir[deployhits] = point_direction(x, y, other.xprevious, other.yprevious)
//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = effectdir[deployhits];
 hurt.hurting = id;
}

//Create burning trail effect
if(global.dflameseffect = 1)
{
 emit[deployhits] = part_emitter_create(system);
 part_emitter_region(system, emit[deployhits], x+lengthdir_x(8, effectdir[deployhits]), x+lengthdir_x(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), ps_shape_ellipse, ps_distr_linear);
 part_emitter_stream(system, emit[deployhits], obj_partsystem.deployhit, 2);
 effectdir[deployhits] =  direction-effectdir[deployhits];
 alarm[7] = 60/global.framerate;
 deployhits += 1;
}

//Shake the screen
obj_mod.viewpos = 8;

//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));
 
//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_hermitmissile_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
        
other.fragment = 1;
other.breaker = mid;
//Take damage
armor -= 12/shielded;
//Check if under shock effect
if(shocked = false)
 shield -= 12/shielded;
else
{
 shield -= 6;
 armor -= 6;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

effectdir[deployhits] = point_direction(x, y, other.xprevious, other.yprevious)
//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = effectdir[deployhits];
 hurt.hurting = id;
}

//Create burning trail effect
if(global.dflameseffect = 1)
{
 emit[deployhits] = part_emitter_create(system);
 part_emitter_region(system, emit[deployhits], x+lengthdir_x(8, effectdir[deployhits]), x+lengthdir_x(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), ps_shape_ellipse, ps_distr_linear);
 part_emitter_stream(system, emit[deployhits], obj_partsystem.deployhit, 2);
 effectdir[deployhits] =  direction-effectdir[deployhits];
 alarm[7] = 60/global.framerate;
 deployhits += 1;
}

//Shake the screen
obj_mod.viewpos = 8;

//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));
 
//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_hackermine_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
armor -= 11/shielded;
//Check if under shock effect
if(shocked = false)
 shield -= 6/shielded;
else
{
 shield -= 3;
 armor -= 3;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

effectdir[deployhits] = point_direction(x, y, other.xprevious, other.yprevious)
//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = effectdir[deployhits];
 hurt.hurting = id;
}

//Create burning trail effect
if(global.dflameseffect = 1)
{
 emit[deployhits] = part_emitter_create(system);
 part_emitter_region(system, emit[deployhits], x+lengthdir_x(8, effectdir[deployhits]), x+lengthdir_x(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), ps_shape_ellipse, ps_distr_linear);
 part_emitter_stream(system, emit[deployhits], obj_partsystem.deployhit, 2);
 effectdir[deployhits] =  direction-effectdir[deployhits];
 alarm[7] = 60/global.framerate;
 deployhits += 1;
}


//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));
 
//Shake the screen
obj_mod.viewpos = 8;

hacked = true;
alarm[5] = 90;
 
//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_shockmissile_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
armor -= 10/shielded;
//Check if under shock effect
if(shocked = false)
 shield -= 6/shielded;
else
{
 shield -= 3;
 armor -= 3;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

effectdir[deployhits] = point_direction(x, y, other.xprevious, other.yprevious)
//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = effectdir[deployhits];
 hurt.hurting = id;
}

//Create burning trail effect
if(global.dflameseffect = 1)
{
 emit[deployhits] = part_emitter_create(system);
 part_emitter_region(system, emit[deployhits], x+lengthdir_x(8, effectdir[deployhits]), x+lengthdir_x(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), ps_shape_ellipse, ps_distr_linear);
 part_emitter_stream(system, emit[deployhits], obj_partsystem.deployhit, 2);
 effectdir[deployhits] =  direction-effectdir[deployhits];
 alarm[7] = 60/global.framerate;
 deployhits += 1;
}

//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));
 
//Shake the screen
obj_mod.viewpos = 8;

shocked = true;
if(other.amplified = 0)
 alarm[6] = 600;
else
 alarm[6] = 900;
  
//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_tridentmissile_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
armor -= 8/shielded;
shield -= 2;
//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

effectdir[deployhits] = point_direction(x, y, other.xprevious, other.yprevious)
//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = effectdir[deployhits];
 hurt.hurting = id;
}

//Create burning trail effect
if(global.dflameseffect = 1)
{
 emit[deployhits] = part_emitter_create(system);
 part_emitter_region(system, emit[deployhits], x+lengthdir_x(8, effectdir[deployhits]), x+lengthdir_x(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), ps_shape_ellipse, ps_distr_linear);
 part_emitter_stream(system, emit[deployhits], obj_partsystem.deployhit, 2);
 effectdir[deployhits] =  direction-effectdir[deployhits];
 alarm[7] = 60/global.framerate;
 deployhits += 1;
}


//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Shake the screen
obj_mod.viewpos = 4;

//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_phantommine_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
armor -= 15/shielded;
//Check if under shock effect
if(shocked = false)
 shield -= 20/shielded;
else
{
 shield -= 10;
 armor -= 10;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

effectdir[deployhits] = point_direction(x, y, other.xprevious, other.yprevious)
//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = effectdir[deployhits];
 hurt.hurting = id;
}

//Create burning trail effect
if(global.dflameseffect = 1)
{
 emit[deployhits] = part_emitter_create(system);
 part_emitter_region(system, emit[deployhits], x+lengthdir_x(8, effectdir[deployhits]), x+lengthdir_x(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), ps_shape_ellipse, ps_distr_linear);
 part_emitter_stream(system, emit[deployhits], obj_partsystem.deployhit, 2);
 effectdir[deployhits] =  direction-effectdir[deployhits];
 alarm[7] = 60/global.framerate;
 deployhits += 1;
}


//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Shake the screen
obj_mod.viewpos = 8;

//Reset shield regen time
alarm[4] = regentime;


//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_locustmissile_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
//Take damage
//Check if under shock effect
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
if(shocked = false)
 shield -= 3/shielded;
else
{
 shield -= 1;
 armor -= 2;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 //Do double damage to armor
 armor += shield*1.167;
 shield = 0;
}


//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = point_direction(x, y, other.xprevious, other.yprevious);
 hurt.hurting = id;
}

//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_huntermine_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
armor -= 25/shielded;
//Check if under shock effect
if(shocked = false)
 shield -= 15/shielded;
else
{
 shield -= 7.5;
 armor -= 7.5;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

effectdir[deployhits] = point_direction(x, y, other.xprevious, other.yprevious)
//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = effectdir[deployhits];
 hurt.hurting = id;
}

//Create burning trail effect
if(global.dflameseffect = 1)
{
 emit[deployhits] = part_emitter_create(system);
 part_emitter_region(system, emit[deployhits], x+lengthdir_x(8, effectdir[deployhits]), x+lengthdir_x(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), ps_shape_ellipse, ps_distr_linear);
 part_emitter_stream(system, emit[deployhits], obj_partsystem.deployhit, 2);
 effectdir[deployhits] =  direction-effectdir[deployhits];
 alarm[7] = 60/global.framerate;
 deployhits += 1;
}



//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Shake the screen
obj_mod.viewpos = 8;

//Reset shield regen time
alarm[4] = regentime;


//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_layermissile_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
//Find out ideal direction for a "direct hit"
directdir = point_direction(other.x, other.y, x, y);
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Base connection damage and explosion
armor -= 15/shielded;
//Check if under shock effect
if(shocked = false)
 shield -= 10+other.bonusdamage/shielded;
else
{
 shield -= 5+other.bonusdamage/2;
 armor -= 5+other.bonusdamage/2;
}

other.hits = 1;
//If the missile's direction is near the ideal direction, add more damage and explosion
if(directdir &gt;= other.direction-4 &amp;&amp; directdir &lt;= other.direction+4)
{
 armor -= 20/shielded;
 //Check if under shock effect
 if(shocked = false)
  shield -= 10/shielded;
 else
 {
  shield -= 5;
  armor -= 5;
 }
 other.hits = 2;
}
//If the missile's direction is VERY close to the ideal direction, add even more damage and explosion
if(directdir &gt;= other.direction-1 &amp;&amp; directdir &lt;= other.direction+1)
{
 armor -= 25/shielded;
 //Check if under shock effect
 if(shocked = false)
  shield -= 10/shielded;
 else
 {
  shield -= 5;
  armor -= 5;
 }
 other.hits = 3;
}
//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

effectdir[deployhits] = point_direction(x, y, other.xprevious, other.yprevious)
//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = effectdir[deployhits];
 hurt.hurting = id;
}

//Create burning trail effect
if(global.dflameseffect = 1)
{
 emit[deployhits] = part_emitter_create(system);
 part_emitter_region(system, emit[deployhits], x+lengthdir_x(8, effectdir[deployhits]), x+lengthdir_x(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), ps_shape_ellipse, ps_distr_linear);
 part_emitter_stream(system, emit[deployhits], obj_partsystem.deployhit, 2);
 effectdir[deployhits] =  direction-effectdir[deployhits];
 alarm[7] = 60/global.framerate;
 deployhits += 1;
}


//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Shake the screen
obj_mod.viewpos = 8;

//Reset shield regen time
alarm[4] = regentime;


//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_dualmissile_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
armor -= 10/shielded;
//Check if under shock effect
if(shocked = false)
 shield -= 8/shielded;
else
{
 shield -= 4;
 armor -= 4;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

effectdir[deployhits] = point_direction(x, y, other.xprevious, other.yprevious)
//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = effectdir[deployhits];
 hurt.hurting = id;
}

//Create burning trail effect
if(global.dflameseffect = 1)
{
 emit[deployhits] = part_emitter_create(system);
 part_emitter_region(system, emit[deployhits], x+lengthdir_x(8, effectdir[deployhits]), x+lengthdir_x(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), y+lengthdir_y(8, effectdir[deployhits]), ps_shape_ellipse, ps_distr_linear);
 part_emitter_stream(system, emit[deployhits], obj_partsystem.deployhit, 2);
 effectdir[deployhits] =  direction-effectdir[deployhits];
 alarm[7] = 60/global.framerate;
 deployhits += 1;
}

//Shake the screen
obj_mod.viewpos = 8;

//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));
 
//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_storm_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;

sfx_play(snd_hit, x, y);
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
if(shocked = false)
 shield -= 4/shielded;
else
{
 shield -= 2;
 armor -= 2;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = point_direction(x, y, other.xprevious, other.yprevious);
 hurt.hurting = id;
}

//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_trail_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;

sfx_play(snd_hit, x, y);
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
if(shocked = false)
 shield -= 5*threshold/shielded;
else
{
 shield -= 2.5*threshold/2;
 armor -= 2.5*threshold/2;
}
threshold -= 0.08;
alarm[9] = 60;
if(threshold &lt; 0.1)
    threshold = 0.1;   

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = point_direction(x, y, other.xprevious, other.yprevious);
 hurt.hurting = id;
}

//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_serpent_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;

sfx_play(snd_hit, x, y);
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
if(shocked = false)
 shield -= 6/shielded;
else
{
 shield -= 3;
 armor -= 3;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = point_direction(x, y, other.xprevious, other.yprevious);
 hurt.hurting = id;
}

//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_spiral_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;

sfx_play(snd_hit, x, y);
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
if(shocked = false)
 shield -= 7/shielded;
else
{
 shield -= 3.5;
 armor -= 3.5;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = point_direction(x, y, other.xprevious, other.yprevious);
 hurt.hurting = id;
}

//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_sparkline_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
sfx_play(snd_hit, x, y);
//Take damage
switch(other.damage)
{
 case 0:
      //Check if under shock effect
      if(shocked = false)
       shield -= 10/shielded;
      else
      {
       shield -= 5;
       armor -= 5;
      }
      //Shake the screen
      obj_mod.viewpos = 4;
 break;
 case 1:
      //Check if under shock effect
      if(shocked = false)
       shield -= 10/shielded;
      else
      {
       shield -= 6;
       armor -= 6;
      }
      //Shake the screen
      obj_mod.viewpos = 8;
 break;
 case 2:
      //Check if under shock effect
      if(shocked = false)
       shield -= 10/shielded;
      else
      {
       shield -= 6;
       armor -= 6;
      }
      //Shake the screen
      obj_mod.viewpos = 8;
 break;
}
//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = point_direction(x, y, other.xprevious, other.yprevious);
 hurt.hurting = id;
}

//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_formationa_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
sfx_play(snd_hit, x, y);
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
//Check if under shock effect
if(shocked = false)
 shield -= 7/shielded;
else
{
 shield -= 3.5;
 armor -= 3.5;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = point_direction(x, y, other.xprevious, other.yprevious);
 hurt.hurting = id;
}


//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_stardust_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
sfx_play(snd_hit, x, y);

//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;

//Activate the limiter and set time until deactivation
threshold -= 0.1;
alarm[9] = 60/global.framerate;
if(threshold &lt; 0.1)
 threshold = 0.1;
 
//Take damage
if(shocked = false)
 shield -= 5*threshold/shielded;
else
{
 shield -= 2.5*threshold;
 armor -= 2.5*threshold;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = point_direction(x, y, other.xprevious, other.yprevious);
 hurt.hurting = id;
}

//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_fusion_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
sfx_play(snd_hit, x, y);
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
//Check if under shock effect
if(shocked = false)
 shield -= 6/shielded;
else
{
 shield -= 3;
 armor -= 3;
}
//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = point_direction(x, y, other.xprevious, other.yprevious);
 hurt.hurting = id;
}

//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));
//Shake the screen
obj_mod.viewpos = 4;
//Reset shield regen time
alarm[4] = regentime;


//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_enemystasis_field">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string> switch(global.shipselect)
 {
  case 1: //Alphastar
       if(speed &gt; 2*global.framerate)
        speed = 2*global.framerate;
  break;
  case 2: //Swiftwing
       if(speed &gt; 3*global.framerate)
        speed = 3*global.framerate;
  break;
  case 3: //Goliath
       if(speed &gt; 2*global.framerate)
        speed = 2*global.framerate;
  break;
 }
other.slowing = 1;
other.alarm[2] = 3;


if(other.damaged[global.mymid] = 1)
    exit;
other.damaged[global.mymid] = 1;
sfx_play(snd_hit, x, y);

//Take damage
if(shocked = false)
 shield -= 1;
else
{
 armor -= 1;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = point_direction(x, y, other.xprevious, other.yprevious);
 hurt.hurting = id;
}

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_crossfire_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
sfx_play(snd_hit, x, y);
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
//Check if under shock effect
if(shocked = false)
 shield -= other.damage/shielded;
else
{
 shield -= other.damage/2;
 armor -= other.damage/2;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = point_direction(x, y, other.xprevious, other.yprevious);
 hurt.hurting = id;
}

//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_flank_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Cancel the collision if a pulse is active
closepulse = instance_nearest(x, y, obj_shieldpulse);
if(closepulse != noone)
 if(closepulse.mid = global.mymid)
 exit;
sfx_play(snd_hit, x, y);
//Check if there's a nearby paladin turret
var shielded;
shielded = 1;
if(instance_exists(obj_turret))
    if(distance_to_object(instance_nearest(x, y, obj_turret)) &lt; 400)
        shielded = 2;
//Take damage
//Check if under shock effect
if(shocked = false)
 shield -= 6/shielded;
else
{
 shield -= 3;
 armor -= 3;
}
//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

//If there is shield left, create effect
if(shield &gt; 0)
{
 hurt = instance_create(0, 0, obj_hit);
 hurt.hitdir = point_direction(x, y, other.xprevious, other.yprevious);
 hurt.hurting = id;
}

//Destroy the attack
with(other) instance_destroy();

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

//Reset shield regen time
alarm[4] = regentime;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Destroy this object
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_wall">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Disregard collision if not hitting the ship's center
walltest = collision_point(x, y, obj_wall, 1, 1)
if(walltest &lt; 0)
 exit;
sfx_play(snd_explode1, x, y);
//Take damage
//Check if under shock effect
if(shocked = false)
 shield -= 2;
else
{
 shield -= 1;
 armor -= 1;
}

//If there is no more shield, transfer damage to armor
if(shield &lt; 0) 
{
 armor += shield;
 shield = 0;
}

//Create smoke at the collision
smokecolor = make_color_rgb(255, random(255), 0);
effect_create_above(ef_smoke, x-6+random(12), y-6+random(12), 0, smokecolor);

//Update smoking
if(armor &lt;= (maxarmor*100)/60)
 smoke = floor(armor/(maxarmor/10));

obj_mod.viewpos = 4;

//Check if your ship has been defeated
if(armor &lt;= 0)
{
 //Move to avoid another wall
 x = x+lengthdir_x(speed+2, direction-180);
 y = y+lengthdir_y(speed+2, direction-180); 
 //Destroy this object
 instance_destroy();
}
else
{
 if(collision_point(xprevious+hspeed, yprevious, obj_wall, 1, 1))
 {
  hspeed = -hspeed;
  x = xprevious;
 }
 if(collision_point(xprevious, yprevious+vspeed, obj_wall, 1, 1))
 {
  vspeed = -vspeed;
  y = yprevious;
 }
 facedir = direction;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="87">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check if you are chatting
if(global.chatting = true || hacked = true) exit;
//Accelerate- increse speed until a max speed is reached
bonusspeed = 0;
if(shield &gt; maxshield-0.2)
    bonusspeed = 3;
if(speed &lt; maxspeed+bonusspeed)
    speed += 0.2;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check if you are chatting
if(global.chatting = true || hacked = true) exit;
//Turn clockwise at the right speed
switch(global.enableautoturn)
{
 case true:
      facedir -= forceturn;
 break;
 case false:
      switch(keyboard_check(vk_shift))
      {
       case true:
            facedir -= forceturn;       
       break;
       case false:
            facedir -= autoturn+forceturn;
       break;
      }
 break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="65">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check if you are chatting
if(global.chatting = true || hacked = true) exit;
//Turn counter-clockwise at the right speed
switch(global.enableautoturn)
{
 case true:
      facedir += forceturn;
 break;
 case false:
      switch(keyboard_check(vk_shift))
      {
       case true:
            facedir += forceturn;       
       break;
       case false:
            facedir += autoturn+forceturn;
       break;
      }
 break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="18">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_perform(ev_keyboard, vk_control);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="17">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(abilityactive = 0)
 exit;
switch(global.shipselect)
{
 case 1:
     //Drain energy to use drift ability
     energygain = 0.2*global.framerate;
     energy -= 0.45*global.framerate;
     if(energy &lt;= 0)
     {
      energy = 0;
      //Switch controlturn to make Alpha Drift ability
      controlturn = 0.75;
      if(global.framerate = 2)
       controlturn = 3;       
      abilityactive = 0;
     }      
 break;
 case 3:
     //Drain energy to use shield pulse ability
     energygain = 0.2*global.framerate;
     energy -= 0.7*global.framerate;
     shield -= 0.10;
     if(energy &lt;= 0 || shield &lt;= 0)
     {
    abilityactive = 0;    
      energy = 0;
      with(obj_shieldpulse)
        if(mid = global.mymid)
            endnow = 1;
     }      
 break;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="16">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_perform(ev_keyboard, vk_control);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>nowshoot = 0;
shooting = 0;
chaining = 0;
obj_mod.refreshing = 0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="54">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check if you are chatting
if(global.chatting = true || hacked = true) exit;

if(global.firingmode = 1 &amp;&amp; redirectfire = 0)
{
    event_perform(ev_keypress, vk_space);
    exit;
}
//Trigger Alphastar passive
amplified = 0;
redirectfire = 0;

switch(global.secondary)
{

 //Dual Missile
 case 0:
      //Make sure you are targetting someone
      if(obj_mod.foundtarget &lt;= -1)
       exit;
      //Check if an existing dual missile belongs to you
      with(obj_dualmissile)
       if(mid = global.mymid)
        exit;
      //Check if you have missiles left
      if(dualmissile&gt;1)
      {
       //Create the first missile and give it its properties
       missile = instance_create(x, y, obj_dualmissile);
       missile.startdir = facedir;
       missile.direction = facedir-90;
       missile.speed = 4*global.framerate;
       missile.target = obj_mod.foundtarget;
       missile.mid = global.mymid;
       //Create the second missile
       missile = instance_create(x, y, obj_dualmissile);
       missile.startdir = facedir;
       missile.direction = facedir+90;
       missile.speed = 4*global.framerate;
       missile.target = obj_mod.foundtarget;
       missile.mid = global.mymid;
       //Take the missiles away from your missile count
       dualmissile -= 2;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 1)
         deploystock[i] -= 1;
       }
       //Find out which ship you are targetting
       testtarget = -1;
       while(true)
       {
        testtarget+=1;
        if(testtarget != global.mymid)
         if(global.playership[testtarget] = obj_mod.foundtarget)
          break;
       }
      }
 break;
 
 //Fusion
 case 1:
      //Check to see if you have enough energy to use it
      if(energy &lt; 20)
       exit;
      //Initialize the attack
      energygain = 0.2*global.framerate;
      alarm[0] = 1;
      fusions = 5;
      //Set the targetted coordinates
      hitx = mouse_x;
      hity = mouse_y;
      //Reduce energy
      energy -= 20;
 break;
 
 //Stardust
 case 2:
      //Check to see if you have enough energy to use it
      if(energy &lt; 25)
       exit;
         //Check if still shooting out stardust
         if(stardust &gt; 0)
           exit;
      //Initialize the attack
        if(global.sfxtoggle = 0)
            sound_loop(snd_stardust);
      energygain = 0.2*global.framerate;
      alarm[1] = 1;
      stardust = 25;
      staramp = 0;
      //Set the targetted coordinates
      hitx = mouse_x;
      hity = mouse_y;
      //Reduce energy
      energy -= 25;
 break;
      
 //Hunter Mine
 case 3:
      //Check if an existing hunter mine belongs to you
      with(obj_huntermine)
       if(mid = global.mymid)
        exit;
      //Check if you have mines left
      if(huntermine &gt; 0)
      {
       hmine=instance_create(x, y, obj_huntermine)
       hmine.mid = global.mymid;
       //Take the mine away from your mine count
       huntermine -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 3)
         deploystock[i] -= 1;
       }
      }
 break;
 
 //Layer Missile
 case 4:
      //Check if an existing dual missile belongs to you
      with(obj_layermissile)
       if(mid = global.mymid)
        exit;
      //Check if you have missiles left
      if(layermissile &gt; 0)
      {
       //Create the first missile and give it its properties
       missile = instance_create(x, y, obj_layermissile);
       missile.direction = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);
       missile.speed = 12*global.framerate;
       missile.mid = global.mymid;
       //Take the missiles away from your missile count
       layermissile -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 2)
         deploystock[i] -= 1;
       }
      }
 break;
 
 //Barrier
 case 5:
      //Check if you have energy for the barrier
      if(energy &lt; 35)
       exit;
      energygain = 0.2*global.framerate;
      //Reduce Energy
      energy -= 35;
      //Create a barrier where the cursor is, and give it the appropriate direction
      barrier = instance_create(mouse_x, mouse_y, obj_barrier);
      barrier.direction = point_direction(x, y, barrier.x, barrier.y);
 break;
 
 //Locust Missile
 case 6:
      //Make sure you are targetting someone
      if(obj_mod.foundtarget &lt;= -1)
       exit;
      //Check if an existing dual missile belongs to you
      with(obj_locustmissile)
       if(mid = global.mymid)
        exit;
      //Check if you have missiles left
      if(locustmissile &gt; 1)
      {
        sfx_play(snd_missile, x, y);
       nextm = 0;
       repeat(6)
       {
        //Create the missile and give it its properties
        missile = instance_create(x, y, obj_locustmissile);
        missile.direction = facedir-90+(nextm*60);
        missile.target = obj_mod.foundtarget;
        missile.mid = global.mymid;
        nextm += 1;
       }
       //Take the missiles away from your missile count
       locustmissile -= 6;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 4)
         deploystock[i] -= 1;
       }
       //Find out which ship you are targetting
       testtarget = -1;
       while(true)
       {
        testtarget+=1;
        if(testtarget != global.mymid)
         if(global.playership[testtarget] = obj_mod.foundtarget)
          break;
       }
      }
 break;

 //Phantom Mine
 case 7:
      //Check if you have mines left
      if(phantommine &gt; 0)
      {
       phan = instance_create(x, y, obj_phantommine);
       phan.mid = global.mymid;
       //Take the mine away from your mine count
       phantommine -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 5)
         deploystock[i] -= 1;
       }
      }
 break;
 
 //Solus
 case 8:
      //Check if you have soluses left
      if(soluscount &lt; 1)
       exit;
      //Check if an existing solus belongs to you
      with(obj_solus)
       if(mid = global.mymid)
        exit;
      //Reduce soluses
      soluscount -= 1;
      //Create the solus where the cursor is
      solus = instance_create(x, y, obj_solus);
      solus.mid = global.mymid;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 6)
         deploystock[i] -= 1;
       }
 break;
 
 //Formation
 case 9:
      //Make sure you are targetting someone
      if(obj_mod.foundtarget &lt;= -1)
       exit;
      //Check if you have energy for the barrier
      if(energy &lt; 30)
       exit;
      energygain = 0.2*global.framerate;
      //Reduce Energy
      energy -= 30;
      //Crete and send the initial shot at the cursor
      form = instance_create(x, y, obj_formationa);
      form.target = obj_mod.foundtarget;
      form.direction = point_direction(x, y, mouse_x, mouse_y);
      form.targetx = mouse_x;
      form.targety = mouse_y;
      form.mid = global.mymid;
      //Find out which ship you are targetting
      testtarget = -1;
      while(true)
      {
       testtarget+=1;
       if(testtarget != global.mymid)
        if(global.playership[testtarget] = obj_mod.foundtarget)
         break;
      }
 break;
 
 //Beam
 case 10:
      //Check if you have energy for the beam and that you are not moving
      if(energy &lt; 99.9 || speed &gt; 0 || cooldown = 0)
       exit;
      energygain = 0.2*global.framerate;
      //Reduce Energy
      energy -= 60;
      heat -= 25;
      cooldown = 0;
      audio_play_sound(snd_overheat, 1, 0);
      //Create a beam and give it the correct direction
      beam = instance_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), obj_beam);
      beam.direction = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);
      beam.mid = global.mymid;
 break;

 //Sparkline
 case 11:
      //Check if you have enough energy
      if(energy &lt; 15)
       exit;
      //Check if three nodes already exist
      if(instance_exists(node3) &amp;&amp; node3 != -1)
       exit;
      //Check if existing nodes are attacking
      if(instance_exists(node2) &amp;&amp; node2 != -1)
       if(node2.stage = 1)
        exit;
      if(instance_exists(node) &amp;&amp; node != -1)
       if(node.stage = 1)
        exit;
      energygain = 0.2*global.framerate;
      //Reduce Energy
      energy -= 15;
      //Create an infinite loop to section off this code
      while(true)
      {
       //Destroy existing nodes if this node is fired too far away
       if(instance_exists(node) &amp;&amp; node != -1)
       if(point_distance(mouse_x, mouse_y, node.x, node.y) &gt; 680)
       {
        with(node) instance_destroy();
        if(instance_exists(node2) &amp;&amp; node2 != -1)
         with(node2) instance_destroy();
       }
       if(instance_exists(node2) &amp;&amp; node2 != -1)
       {
        with(node) instance_destroy();
        with(node2) instance_destroy();
       }
        //Check if a node exists
       if(instance_exists(node) &amp;&amp; node != -1)
       {
        //Check if a second node exists
        if(instance_exists(node2) &amp;&amp; node2 != -1)
        {
         //Create a third node
         node3 = instance_create(x, y, obj_sparkline);
         node3.direction = point_direction(x, y, mouse_x, mouse_y);
         node3.targetx = mouse_x;
         node3.targety = mouse_y;
         node3.final = 1;
         node3.mid = global.mymid;
         //Make the second node connect to this node
         node2.second = node3;
         //Connect to the first node
         node3.second = node;
         //Note this is the third node
         nodecount = 3;
         //Break the loop
         break;
        }
        //Create a second node
        node2 = instance_create(x, y, obj_sparkline);
        node2.direction = point_direction(x, y, mouse_x, mouse_y);
        node2.targetx = mouse_x;
        node2.targety = mouse_y;
        node2.final = 0;
        node2.mid = global.mymid;
        //Make the first node connect to this node
        node.second = node2;
        //Note this is the third node
        nodecount = 2;
        //Break the loop
        break;
       }
       //Create a node
       node = instance_create(x, y, obj_sparkline);
       node.direction = point_direction(x, y, mouse_x, mouse_y);
       node.targetx = mouse_x;
       node.targety = mouse_y;
       node.final = 0;
       node.mid = global.mymid;
       //Note this is the third node
       nodecount = 1;
       //Break the loop
       break;
      }
 break;

 //Burst
 case 12:
      //Check if you have energy for the barrier
      if(energy &lt; 20)
       exit;
      energygain = 0.2*global.framerate;
      //Reduce Energy
      energy -= 20;
      //Crete and send the initial shot at the cursor
      form = instance_create(x, y, obj_burst);
      form.direction = point_direction(x, y, mouse_x, mouse_y);
      form.targetx = mouse_x;
      form.targety = mouse_y;
      form.mid = global.mymid;
 break;
 
 //Trident Missile
 case 13:
      //Make sure you are targetting someone
      if(obj_mod.foundtarget &lt;= -1)
       exit;
      //Check if an existing dual missile belongs to you
      with(obj_tridentmissile)
       if(mid = global.mymid)
        exit;
      //Check if you have missiles left
      if(tridentmissile&gt;2)
      {
       //Create the first missile and give it its properties
       missile1 = instance_create(x, y, obj_tridentmissile);
       missile1.startdir = facedir;
       missile1.direction = facedir;
       missile1.speed = 4*global.framerate;
       missile1.target = obj_mod.foundtarget;
       missile1.mid = global.mymid;
       missile1.trio = 1;
       //Create the second missile
       missile2 = instance_create(x, y, obj_tridentmissile);
       missile2.startdir = facedir;
       missile2.direction = facedir-90;
       missile2.speed = 4*global.framerate;
       missile2.target = obj_mod.foundtarget;
       missile2.mid = global.mymid;
       missile2.trio = 2;
       missile2.middle = missile1;
       //Create the last missile
       missile3 = instance_create(x, y, obj_tridentmissile);
       missile3.startdir = facedir;
       missile3.direction = facedir+90;
       missile3.speed = 4*global.framerate;
       missile3.target = obj_mod.foundtarget;
       missile3.mid = global.mymid;
       missile3.trio = 3;
       missile3.middle = missile1;
       //Take note of the last two missile in the first missile
       missile1.second = missile2;
       missile1.third = missile3;
       //Take the missiles away from your missile count
       tridentmissile -= 3;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 7)
         deploystock[i] -= 1;
       }
       //Find out which ship you are targetting
       testtarget = -1;
       while(true)
       {
        testtarget+=1;
        if(testtarget != global.mymid)
         if(global.playership[testtarget] = obj_mod.foundtarget)
          break;
       }
      }
 break;
 
 //Slash
 case 14:
      //Check if you have energy for the barrier
      if(energy &lt; 20)
       exit;

      energygain = 0.2*global.framerate;
      //Reduce Energy
      energy -= 20;
      //Create and send the initial shot at the cursor
      form = instance_create(x+lengthdir_x(32, point_direction(x, y,mouse_x, mouse_y)), y+lengthdir_y(32, point_direction(x, y,mouse_x, mouse_y)), obj_slash);
      form.mid = global.mymid;
      form.targetx = mouse_x;
      form.targety = mouse_y;
      form.direction = point_direction(x, y,mouse_x, mouse_y);
 break;

 //Horizon
 case 15:
      //Make sure you are targetting someone
      if(obj_mod.foundtarget &lt;= -1)
       exit;
      //Check if you have energy for the barrier
      if(energy &lt; 25)
       exit;
      energygain = 0.2*global.framerate;
      //Reduce Energy
      energy -= 25;
      //Crete and send the initial shot at the cursor
      loldir = point_direction(x, y, obj_mod.foundtarget.x, obj_mod.foundtarget.y);
      form = instance_create(obj_mod.foundtarget.x+lengthdir_x(500, loldir), obj_mod.foundtarget.y+lengthdir_y(500, loldir), obj_horizon);
      form.target = obj_mod.foundtarget;
      form.direction = loldir-180;
      form.mid = global.mymid;
 break;

 //Hacker Mine
 case 16:
      //Check if you have mines left
      if(hackermine &gt; 0)
      {
       phan = instance_create(x, y, obj_hackermine);
       phan.mid = global.mymid;
       //Take the mine away from your mine count
       hackermine -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 9)
         deploystock[i] -= 1;
       }
      }
 break;
 
 //Shock Missile
 case 17:
      //Make sure you are targetting someone
      if(obj_mod.foundtarget &lt;= -1)
       exit;
      //Check if an existing dual missile belongs to you
      with(obj_shockmissile)
       if(mid = global.mymid)
        exit;
      //Check if you have missiles left
      if(shockmissile &gt; 0)
      {
       //Create the first missile and give it its properties
       missile = instance_create(x, y, obj_shockmissile);
       missile.direction = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);
       missile.speed = 12*global.framerate;
       missile.target = obj_mod.foundtarget;
       missile.mid = global.mymid;
       //Take the missiles away from your missile count
       shockmissile -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 8)
         deploystock[i] -= 1;
       }
       //Find out which ship you are targetting
       testtarget = -1;
       while(true)
       {
        testtarget+=1;
        if(testtarget != global.mymid)
         if(global.playership[testtarget] = obj_mod.foundtarget)
          break;
       }
      }
 break;
 
 //Hermit Missile
 case 18:
      //Make sure you are targetting someone
      if(obj_mod.foundtarget &lt;= -1)
       exit;
      //Check if an existing hermit missile belongs to you
      with(obj_hermitmissile)
       if(mid = global.mymid)
        exit;
      //Check if you have missiles left
      if(hermitmissile &gt; 0)
      {
       //Create the first missile and give it its properties
       missile = instance_create(x, y, obj_hermitmissile);
       missile.direction = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);
       missile.speed = 13*global.framerate;
       missile.mid = global.mymid;
       missile.target = obj_mod.foundtarget;
       //Take the missiles away from your missile count
       hermitmissile -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 10)
         deploystock[i] -= 1;
       }
       //Find out which ship you are targetting
       testtarget = -1;
       while(true)
       {
        testtarget+=1;
        if(testtarget != global.mymid)
         if(global.playership[testtarget] = obj_mod.foundtarget)
          break;
       }
      }
 break;
 
 //Strike Missile
 case 19:
      //Make sure you are targetting someone
      if(obj_mod.foundtarget &lt;= -1)
       exit;
      //Check if you have missiles left
      if(strikemissile &gt; 0)
      {
       //Create the first missile and give it its properties
       missile = instance_create(x, y, obj_strikemissile);
       missile.direction = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);
       missile.speed = 13*global.framerate;
       missile.target = obj_mod.foundtarget;
       missile.mid = global.mymid;
       //Take the missiles away from your missile count
       strikemissile -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 11)
         deploystock[i] -= 1;
       }
       //Find out which ship you are targetting
       testtarget = -1;
       while(true)
       {
        testtarget+=1;
        if(testtarget != global.mymid)
         if(global.playership[testtarget] = obj_mod.foundtarget)
          break;
       }
      }
 break;
 
 //Strike Mine
 case 20:
      //Check if you have mines left
      if(strikemine &gt; 0)
      {
       phan = instance_create(x, y, obj_strikemine);
       phan.mid = global.mymid;
       //Take the mine away from your mine count
       strikemine -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 12)
         deploystock[i] -= 1;
       }
      }
 break;
 
 //Turret
 case 21:
      //Check if you have soluses left
      if(turret &lt; 1)
       exit;
      if(obj_bulletcontrol.wallposition[floor(mouse_x/32), floor(mouse_y/32)] = true)
       exit;
      //Reduce soluses
      turret -= 1;
      //Create the solus where the cursor is
      solus = instance_create(mouse_x, mouse_y, obj_turret);
      solus.mid = global.mymid;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 13)
         deploystock[i] -= 1;
       }
 break;
 
 //Spiral
 case 22:
      //Check if you have energy for the barrier
      if(energy &lt; 20)
       exit;
      energygain = 0.2*global.framerate;
      //Reduce Energy
      energy -= 20;
      //Crete and send the initial shot at the cursor
      form = instance_create(x, y, obj_spiral);
      form.direction = point_direction(x, y, mouse_x, mouse_y);
      form.targetx = mouse_x;
      form.targety = mouse_y;
      form.mid = global.mymid;
 break;

 //Whip
 case 23:
      //Check to see if you have enough energy to use it
      if(energy &lt; 20 || whips &gt; 0)
       exit;
      //Initialize the attack
      energygain = 0.2*global.framerate;
      alarm[8] = 1;
      whips = 15;
      //Set the targetted coordinates
      hitx = mouse_x;
      hity = mouse_y;
      //Reduce energy
      energy -= 20;
 break;

 //Trail
 case 24:
      //Check if you have energy for the barrier
      if(energy &lt; 25)
       exit;
      energygain = 0.2*global.framerate;
      //Reduce Energy
      energy -= 25;
      //Crete and send the initial shot at the cursor
      form = instance_create(x, y, obj_trail);
      form.direction = point_direction(x, y, mouse_x, mouse_y);
      form.mid = global.mymid;
 break;

 //Serpent
 case 25:
      //Check if you have energy
      if(energy &lt; 35)
       exit;
      energygain = 0.2*global.framerate;
      //Reduce Energy
      energy -= 35;
      //Create and send the shot at the cursor
      form = instance_create(x, y, obj_serpent);
      form.direction = point_direction(x, y, mouse_x, mouse_y);
      form.mid = global.mymid;
      form.target = 1;
 break;

 //Storm
 case 26:
      //Check if you have energy
      if(energy &lt; 20)
       exit;
      energygain = 0.2*global.framerate;
      //Reduce Energy
      energy -= 20;
      with(obj_storm)
      {
        if(mid = global.mymid)
            age += 1;
        if(age = 4)
            instance_destroy();
      }
      with(obj_storm_wall)
      {
        if(mid = global.mymid)
            age += 1;
        if(age = 4)
            instance_destroy();
      }
        sfx_play(snd_storm, x, y);
      //Create and send shots at the cursor
      storm = instance_create(x, y, obj_storm);
      storm.direction = point_direction(x, y, mouse_x, mouse_y);
      storm.mid = global.mymid;
      storm = instance_create(x, y, obj_storm);
      storm.direction = point_direction(x, y, mouse_x, mouse_y)-30;
      storm.mid = global.mymid;
      storm = instance_create(x, y, obj_storm);
      storm.direction = point_direction(x, y, mouse_x, mouse_y)+30;
      storm.mid = global.mymid;
      storm = instance_create(x, y, obj_storm);
      storm.direction = point_direction(x, y, mouse_x, mouse_y)-15;
      storm.mid = global.mymid;
      storm = instance_create(x, y, obj_storm);
      storm.direction = point_direction(x, y, mouse_x, mouse_y)+15;
      storm.mid = global.mymid;
      storm = instance_create(mouse_x, mouse_y, obj_storm_wall);
      storm.direction = point_direction(x, y, mouse_x, mouse_y)-180;
       storm.x += lengthdir_x(point_distance(x, y, mouse_x, mouse_y), storm.direction-180);
       storm.y += lengthdir_y(point_distance(x, y, mouse_x, mouse_y), storm.direction-180);       
      storm.image_angle = storm.direction;
      storm.mid = global.mymid;
        
 break;
 
 //Trigger
 case 27:
      //Check if you have energy for the barrier
      if(energy &lt; 20)
       exit;
      energygain = 0.2;
      //Reduce Energy
      energy -= 20;
        //Destroy an old trigger
        var direct;
        direct = 0;
        if(instance_exists(obj_trigger))
            if(instance_exists(directthis))
                direct = 1;
        if(direct = 0)
        {
            //Crete and send the initial shot at the cursor
            form = instance_create(x, y, obj_trigger);
            form.direction = point_direction(x, y, mouse_x, mouse_y);
            form.targetx = mouse_x;
            form.targety = mouse_y;
            form.mid = global.mymid;
            directthis = form;
        }
        else
        {
            sfx_play(snd_wave, directthis.x, directthis.y);
            directthis.targetx = mouse_x;
            directthis.targety = mouse_y;
            directthis.speed = 13;
            directthis.direction = point_direction(directthis.x, directthis.y, mouse_x, mouse_y);
            directthis.alarm[0] = 5;
        }
 break;

 //Split Missile
 case 28:
      //Check if an existing hermit missile belongs to you
      with(obj_splitmissile)
       if(mid = global.mymid)
        exit;
      //Check if you have missiles left
      if(splitmissile &gt; 0)
      {
       //Create the first missile and give it its properties
       missile = instance_create(x, y, obj_splitmissile);
       missile.direction = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);
       missile.speed = 13*global.framerate;
       missile.mid = global.mymid;
       missile.oldmid = -1;
       missile.damage = 11;
       //Take the missiles away from your missile count
       splitmissile -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 14)
         deploystock[i] -= 1;
       }
      }
 break;
 
 //Cluster Mine
 case 29:
      //Check if you have mines left
      if(clustermine &gt; 0)
      {
        //Destroy nearby mines
        for(i = instance_nearest(x, y, obj_clustermine); i != noone; i = instance_nearest(x, y, obj_clustermine))
        {
            if(point_distance(x, y, i.x, i.y) &lt; 400)
                with(i)
                    instance_destroy();
            else
                break;
        }
        for(i = instance_nearest(x, y, obj_clustermine_small); i != noone; i = instance_nearest(x, y, obj_clustermine_small))
        {
            if(point_distance(x, y, i.x, i.y) &lt; 400)
                with(i)
                    instance_destroy();
            else
                break;
        }
       phan = instance_create(x, y, obj_clustermine);
       phan.mid = global.mymid;
       //Take the mine away from your mine count
       clustermine -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 15)
         deploystock[i] -= 1;
       }
      }
 break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(cooldown = 0)
 exit;
nowshoot = 1;
shooting = 1;
obj_mod.refreshing = 0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="50">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Disable chatting if currently in chat mode
if(global.chatting = true)
 global.chatting = false;
 

//Disbale shooting if hacked
if(hacked = true || cooldown = 0) exit;

if(shoot &lt;= 0)
{
 nowshoot = 1;

 switch(global.primary)
 {
 
  //Needle Primary
  case 1:
       //Check to see if you have enough heat to shoot
       if(heat &gt; 2.1)
       {
        //Reduce heat and set a fire rate
        heat -= 2.1;
        shoot = 7;
        //Create an effect
        part_type_color1(obj_partsystem.primarypart, c_aqua);
        part_type_speed(obj_partsystem.primarypart,speed+1.68,speed+2.80,-0.04,0);
        part_type_direction(obj_partsystem.primarypart,facedir-50,facedir+50,0,0);
        if(global.psplasheffect = 1)
         part_particles_create(obj_partsystem.system, x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), obj_partsystem.primarypart, 10);
        newdir = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);        
        bullet = bullet_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), "Needle", newdir-3+random(6), global.mymid, 0);
       }
       else
       {
        nowshoot = 0;
        obj_mod.refreshing = 0;       
        heat = 0;
        cooldown = 0;
        audio_play_sound(snd_overheat, 1, 0);
       }
  break;
  
  //Sonic
  case 2:
       //Check to see if you have enough heat to shoot
       if(heat &gt; 2.4)
       {
        //Reduce heat and set a fire rate
        heat -= 2.4;
        shoot = 4;
        //Create an effect
        part_type_color1(obj_partsystem.primarypart, make_color_rgb(152, 77, 7));
        part_type_speed(obj_partsystem.primarypart,speed+1.68,speed+2.80,-0.04,0);
        part_type_direction(obj_partsystem.primarypart,facedir-50,facedir+50,0,0);
        if(global.psplasheffect = 1)
         part_particles_create(obj_partsystem.system, x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), obj_partsystem.primarypart, 5);
        newdir = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);        
        bullet = bullet_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), "Sonic", newdir-7+random(14), global.mymid, 0);
        bullet = bullet_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), "Sonic", newdir-7+random(14), global.mymid, 0);
       }
       else
       {
        nowshoot = 0;
        obj_mod.refreshing = 0;       
        heat = 0;
        cooldown = 0;
        audio_play_sound(snd_overheat, 1, 0);
       }
  break;
  
  //Wave
  case 3:
       //Check to see if you have enough heat to shoot
       if(heat &gt; 4.5)
       {
        //Reduce heat and set a fire rate
        heat -= 4.5;
        shoot = 12;
        //Create an effect
        part_type_color1(obj_partsystem.primarypart, c_purple);
        part_type_speed(obj_partsystem.primarypart,speed+1.68,speed+2.80,-0.04,0);
        part_type_direction(obj_partsystem.primarypart,facedir-50,facedir+50,0,0);
        if(global.psplasheffect = 1)
         part_particles_create(obj_partsystem.system, x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), obj_partsystem.primarypart, 15);
        //Create the shot and give it speed and facedir
        newdir = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);        
        bullet = bullet_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), "Wave", newdir-1+random(2), global.mymid, 0);
       }
       else
       {
        nowshoot = 0;
        obj_mod.refreshing = 0;       
        heat = 0;
        cooldown = 0;
        audio_play_sound(snd_overheat, 1, 0);
       }
  break;

  //Flank
  case 4:
       //Check to see if you have enough heat to shoot
       if(heat &gt; 5.3)
       {
        //Reduce heat and set a fire rate
        heat -= 5.3;
        shoot = 10;
        //Create an effect
        part_type_color1(obj_partsystem.primarypart, c_orange);
        part_type_speed(obj_partsystem.primarypart,speed+1.68,speed+2.80,-0.04,0);
        part_type_direction(obj_partsystem.primarypart,facedir-50,facedir+50,0,0);
        if(global.psplasheffect = 1)
         part_particles_create(obj_partsystem.system, x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), obj_partsystem.primarypart, 10);
        //Create the shot and give it speed and facedir
        flank = instance_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), obj_flank);
        sfx_play(snd_flank, x, y);
        flank.speed = 14*global.framerate;
        newdir = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);
        flank.direction = newdir-7+random(14);
        flank.mid = global.mymid;
            //Find out which ship you are targetting
            testtarget = -1;
            if(obj_mod.foundtarget &gt; -1)
            while(true)
            {
             testtarget+=1;
             if(testtarget != global.mymid)
              if(global.playership[testtarget] = obj_mod.foundtarget)
              break;
            }
        flank.target = testtarget;
       }
       else
       {
        nowshoot = 0;
        obj_mod.refreshing = 0;       
        heat = 0;
        cooldown = 0;
        audio_play_sound(snd_overheat, 1, 0);
       }
  break;
  
  //Stasis
  case 5:
       //Check to see if you have enough heat to shoot
       if(heat &gt;= 11)
       {
        //Reduce heat and set a fire rate
        heat -= 11;
        shoot = 25;
        //Create an effect
        part_type_color1(obj_partsystem.primarypart, c_aqua);
        part_type_speed(obj_partsystem.primarypart,speed+1.68,speed+2.80,-0.04,0);
        part_type_direction(obj_partsystem.primarypart,facedir-50,facedir+50,0,0);
        if(global.psplasheffect = 1)
         part_particles_create(obj_partsystem.system, x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), obj_partsystem.primarypart, 10);
        //Create the shot and give it speed and facedir
        newdir = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);      
        stasisslow = 0; 
        with(obj_stasis_field)
            if(mid = global.mymid &amp;&amp; slowing = 1)
                obj_ship.stasisslow = 1;
            sfx_play(snd_stasis, x, y);
            bullet = instance_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), obj_stasisnew);
            bullet.direction = newdir;
            bullet.mid = global.mymid;
        if(stasisslow = 1)
            shoot = 20;
       }
       else
       {
        nowshoot = 0;
        obj_mod.refreshing = 0;       
        heat = 0;
        cooldown = 0;
        audio_play_sound(snd_overheat, 1, 0);
       }
  break;
  
  //Crossfire
  case 6:
       //Check to see if you have enough heat to shoot
       if(heat &gt; 4.1)
       {
        //Reduce heat and set a fire rate
        heat -= 4.1;
        shoot = 9;
        //Create an effect
        part_type_color1(obj_partsystem.primarypart, c_fuchsia);
        part_type_speed(obj_partsystem.primarypart,1.68,2.80,-0.04,0);
        part_type_direction(obj_partsystem.primarypart,facedir-230,facedir+230,0,0);
        if(global.psplasheffect = 1)
         part_particles_create(obj_partsystem.system, x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), obj_partsystem.primarypart, 10);
        //Create the shot and give it speed and facedir
        sfx_play(snd_helix, x, y);
        cross = instance_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), obj_crossfire);
        cross.speed = 16*global.framerate;
        newdir = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);
        cross.direction = newdir;
        cross.mid = global.mymid;
        cross.side = 1;
        //Create the shot and give it speed and facedir
        cross = instance_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), obj_crossfire);
        cross.speed = 16*global.framerate;
        newdir = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);
        cross.direction = newdir;
        cross.mid = global.mymid;
        cross.side = 2;
       }          
       else
       {
        nowshoot = 0;
        obj_mod.refreshing = 0;       
        heat = 0;
        cooldown = 0;
        audio_play_sound(snd_overheat, 1, 0);
       }
  break;
  
  //Siphon
  case 7:
       //Check to see if you have enough heat to shoot
       if(heat &gt; 5)
       {
        nowshoot = 0;
        //Reduce heat and set a fire rate
        heat -= 5;
        shoot = 12;
        newdir = 0;
        //Create an effect
        part_type_color1(obj_partsystem.primarypart, c_aqua);
        part_type_speed(obj_partsystem.primarypart,speed+1.68,speed+2.80,-0.04,0);
        part_type_direction(obj_partsystem.primarypart,facedir-50,facedir+50,0,0);
        if(global.psplasheffect = 1)
         part_particles_create(obj_partsystem.system, x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), obj_partsystem.primarypart, 5);
        //Check if the target is nearby
        if(obj_mod.foundtarget &lt; 0 || point_distance(x, y, obj_mod.foundtarget.x, obj_mod.foundtarget.y) &gt; 400) 
        {
            heat -= 2;
         break;
        }
        //Check if the target is withing firing angle
        point = point_direction(x, y, obj_mod.foundtarget.x, obj_mod.foundtarget.y);
        if(aim_limit(facedir, point, 30) != point)
        {
            heat -= 2;
         break;
        }
        //Create the shot and give it speed and facedir
        nowshoot = 1;
         sfx_play(snd_siphon, x, y);
       siphon = instance_create(0, 0, obj_siphon);
        siphon.mid = global.mymid;
        siphon.targetmid = obj_mod.foundtarget.mid;
        //Absord shield
        if(obj_mod.foundtarget.shield &gt; 0) shield += 2;
        if(shield &gt; maxshield) shield = maxshield;
       }
       else
       {
        nowshoot = 0;
        obj_mod.refreshing = 0;       
        heat = 0;
        cooldown = 0;
        audio_play_sound(snd_overheat, 1, 0);
       }
  break;
 
  //Double Primary
  case 8:
       //Check to see if you have enough heat to shoot
       if(heat &gt; 3)
       {
        //Reduce heat and set a fire rate
        heat -= 3;
        shoot = 10;
        //Create an effect
        part_type_color1(obj_partsystem.primarypart, c_maroon);
        part_type_speed(obj_partsystem.primarypart,speed+1.68,speed+2.80,-0.04,0);
        part_type_direction(obj_partsystem.primarypart,facedir-50,facedir+50,0,0);
        if(global.psplasheffect = 1)
         part_particles_create(obj_partsystem.system, x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), obj_partsystem.primarypart, 10);
        newdir = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30)-5+random(10); 
        sfx_play(snd_double, x, y);
        bullet = bullet_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), "Double", newdir, global.mymid, 0);
        enemynear = instance_nearest(x, y, prnt_enemy);
        if(instance_exists(enemynear))
            newdir = aim_limit(facedir-180, point_direction(x, y, enemynear.x, enemynear.y), 30)-180;
        bullet = bullet_create(x+lengthdir_x(9, facedir-180), y+lengthdir_y(9, facedir-180), "Double", newdir-180, global.mymid, 0);
       }
       else
       {
        nowshoot = 0;
        obj_mod.refreshing = 0;       
        heat = 0;
        cooldown = 0;
        audio_play_sound(snd_overheat, 1, 0);
       }
  break;

  //Pierce Primary
  case 9:
       //Check to see if you have enough heat to shoot
       if(heat &gt; 4)
       {
        //Reduce heat and set a fire rate
        heat -= 4;
        shoot = 7;
        //Create an effect
        part_type_color1(obj_partsystem.primarypart, c_aqua);
        part_type_speed(obj_partsystem.primarypart,speed+1.68,speed+2.80,-0.04,0);
        part_type_direction(obj_partsystem.primarypart,facedir-50,facedir+50,0,0);
        if(global.psplasheffect = 1)
         part_particles_create(obj_partsystem.system, x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), obj_partsystem.primarypart, 10);
        newdir = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);        
        bullet = bullet_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), "Pierce", newdir-4+random(8), global.mymid, 0);
       }
       else
       {
        nowshoot = 0;
        obj_mod.refreshing = 0;       
        heat = 0;
        cooldown = 0;
        audio_play_sound(snd_overheat, 1, 0);
       }
  break;

  //Spread Primary
  case 10:
       //Check to see if you have enough heat to shoot
       if(heat &gt; 7)
       {
        //Reduce heat and set a fire rate
        heat -= 7;
        shoot = 20;
        //Create an effect
        part_type_color1(obj_partsystem.primarypart, c_maroon);
        part_type_speed(obj_partsystem.primarypart,speed+1.68,speed+2.80,-0.04,0);
        part_type_direction(obj_partsystem.primarypart,facedir-50,facedir+50,0,0);
        if(global.psplasheffect = 1)
         part_particles_create(obj_partsystem.system, x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), obj_partsystem.primarypart, 30);
        sfx_play(snd_spread, x, y);
        newdir = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 10)-5+random(10);        
        bullet = bullet_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), "Spread", newdir, global.mymid, 0);
        bullet = bullet_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), "Spread", newdir-15, global.mymid, 0);
        bullet = bullet_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), "Spread", newdir-30, global.mymid, 0);
        bullet = bullet_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), "Spread", newdir-45, global.mymid, 0);
        bullet = bullet_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), "Spread", newdir+15, global.mymid, 0);
        bullet = bullet_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), "Spread", newdir+30, global.mymid, 0);
        bullet = bullet_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), "Spread", newdir+45, global.mymid, 0);
       }
       else
       {
        nowshoot = 0;
        obj_mod.refreshing = 0;       
        heat = 0;
        cooldown = 0;
        audio_play_sound(snd_overheat, 1, 0);
       }
  break;

 }
}
 

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_flame();
draw_turnblur();
//Draw the ship
draw_sprite_ext(sprite_index, -1, x, y, 1, 1, image_angle, c_white, invincible);
if(shocked = true)
 draw_sprite_ext(spr_shocksparks, nextflame, x, y, 1, 1, 0, c_white, 0.8);
if(beserk = true &amp;&amp; warping = -1)
 draw_sprite_ext(spr_swiftwing_beserkglow, beserking, x, y, 1, 1, image_angle, c_white, 1);
//Draw the flame trail particles
part_system_drawit(system);

if(chained = 1)
{
 //Set the number of images to draw depenadant on the distance between the two nodes
 lines = floor(point_distance(chainer.x, chainer.y, x, y)/64);
 //Set the direction to the node
 dir = point_direction(chainer.x, chainer.y, x, y);
 //Set the scale value so that all images are drawn the same
 scale = (point_distance(chainer.x, chainer.y, x, y)-(lines*64))/64;
 for(i = 1; i &lt;= lines; i += 1)
 {
   draw_sprite_ext(spr_chainsap, obj_mod.chaincount+i*11, chainer.x+lengthdir_x(64*(i-1), dir), chainer.y+lengthdir_y(64*(i-1), dir), 1, 1, dir, global.enemycolor, 0.8);
 }
 draw_sprite_ext(spr_chainsap, obj_mod.chaincount+i*11, chainer.x+lengthdir_x(64*(i-1), dir), chainer.y+lengthdir_y(64*(i-1), dir), scale, 1, dir, global.enemycolor, 0.8);
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="87">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check if you are chatting
if(global.chatting = true || hacked = true) exit;

predictspeed = 1;

boosteffect = instance_create(x+lengthdir_x(8, image_angle-180), y+lengthdir_y(8, image_angle-180), obj_boosteffect)
boosteffect.image_angle = image_angle;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="83">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check if you are chatting
if(global.chatting = true || hacked = true) exit;

predictspeed = 2;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check if you are chatting
if(global.chatting = true || hacked = true) exit;

predictturn = 1;
if(global.enableautoturn = false &amp;&amp; keyboard_check(vk_shift) = true)
 //Take note of the last direction sent
 thisturn = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="65">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check if you are chatting
if(global.chatting = true || hacked = true) exit;

predictturn = 2;
if(global.enableautoturn = false &amp;&amp; keyboard_check(vk_shift) = true)
 //Take note of the last direction sent
 thisturn = 2;
 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check if you are chatting
if(global.chatting = true || hacked = true) exit;

//Trigger Alphastar passive
amplified = 0;
if(global.lolship[global.mymid] = 1)
 amplified = 1;

switch(global.spacesecond)
{

 //Dual Missile
 case 0:
      //Make sure you are targetting someone
      if(obj_mod.foundtarget &lt;= -1)
       exit;
      //Check if an existing dual missile belongs to you
      with(obj_dualmissile)
       if(mid = global.mymid)
        exit;
      //Check if you have missiles left
      if(dualmissile&gt;1)
      {
       //Create the first missile and give it its properties
       missile = instance_create(x, y, obj_dualmissile);
       missile.startdir = facedir;
       missile.direction = facedir-90;
       missile.speed = 4*global.framerate;
       missile.target = obj_mod.foundtarget;
       missile.mid = global.mymid;
       missile.amplified = amplified;
       
       //Create the second missile
       missile = instance_create(x, y, obj_dualmissile);
       missile.startdir = facedir;
       missile.direction = facedir+90;
       missile.speed = 4*global.framerate;
       missile.target = obj_mod.foundtarget;
       missile.mid = global.mymid;
       missile.amplified = amplified;

       //Take the missiles away from your missile count
       dualmissile -= 2;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 1)
         deploystock[i] -= 1;
       }
       //Find out which ship you are targetting
       testtarget = -1;
       while(true)
       {
        testtarget+=1;
        if(testtarget != global.mymid)
         if(global.playership[testtarget] = obj_mod.foundtarget)
          break;
       }
      }
 break;
 
 //Fusion
 case 1:
      //Check to see if you have enough energy to use it
      if(energy &lt; 20)
       exit;
      //Initialize the attack
      energygain = 0.2;
      alarm[0] = 1;
      fusions = 7;
      //Set the targetted coordinates
      hitx = mouse_x;
      hity = mouse_y;
      //Reduce energy
      energy -= 20;
 break;
 
 //Stardust
 case 2:
      //Check to see if you have enough energy to use it
      if(energy &lt; 25)
       exit;
         //Check if still shooting out stardust
         if(stardust &gt; 0)
           exit;
        if(global.sfxtoggle = 0)
            sound_loop(snd_stardust);
      //Initialize the attack
      energygain = 0.2;
      alarm[1] = 1;
      stardust = 25;
      staramp = 0;
      if(amplified = 1)
       staramp = 1;
      //Set the targetted coordinates
      hitx = mouse_x;
      hity = mouse_y;
      //Reduce energy
      energy -= 25;
 break;
      
 //Hunter Mine
 case 3:
      //Check if an existing hunter mine belongs to you
      with(obj_huntermine)
       if(mid = global.mymid)
        exit;
      //Check if you have mines left
      if(huntermine &gt; 0)
      {
       hmine=instance_create(x, y, obj_huntermine)
       hmine.mid = global.mymid;
       hmine.amplified = amplified;
       //Take the mine away from your mine count
       huntermine -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 3)
         deploystock[i] -= 1;
       }
      }
 break;
 
 //Layer Missile
 case 4:
      //Check if an existing dual missile belongs to you
      with(obj_layermissile)
       if(mid = global.mymid)
        exit;
      //Check if you have missiles left
      if(layermissile &gt; 0)
      {
       //Create the first missile and give it its properties
       missile = instance_create(x, y, obj_layermissile);
       missile.direction = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);
       missile.speed = 12*global.framerate;
       missile.mid = global.mymid;
       missile.amplified = amplified;
       //Take the missiles away from your missile count
       layermissile -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 2)
         deploystock[i] -= 1;
       }
      }
 break;
 
 //Barrier
 case 5:
      //Check if you have energy for the barrier
      if(energy &lt; 35)
       exit;
      energygain = 0.2;
      //Reduce Energy
      energy -= 35;
      //Create a barrier where the cursor is, and give it the appropriate direction
      barrier = instance_create(mouse_x, mouse_y, obj_barrier);
      barrier.direction = point_direction(x, y, barrier.x, barrier.y);
      barrier.amplified = amplified;
 break;
 
 //Locust Missile
 case 6:
      //Make sure you are targetting someone
      if(obj_mod.foundtarget &lt;= -1)
       exit;
      //Check if an existing dual missile belongs to you
      with(obj_locustmissile)
       if(mid = global.mymid)
        exit;
      //Check if you have missiles left
      if(locustmissile &gt; 1)
      {
        sfx_play(snd_missile, x, y);
       nextm = 0;
       if(amplified = 0)
       repeat(6)
       {
        //Create the missile and give it its properties
        missile = instance_create(x, y, obj_locustmissile);
        missile.direction = facedir-90+(nextm*60);
        missile.target = obj_mod.foundtarget;
        missile.mid = global.mymid;
        nextm += 1;
       }
       else
       repeat(8)
       {
        //Create the missile and give it its properties
        missile = instance_create(x, y, obj_locustmissile);
        missile.direction = facedir-22.5+(nextm*45);
        missile.target = obj_mod.foundtarget;
        missile.mid = global.mymid;
        nextm += 1;
       }
       
       //Take the missiles away from your missile count
       locustmissile -= 6;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 4)
         deploystock[i] -= 1;
       }
       //Find out which ship you are targetting
       testtarget = -1;
       while(true)
       {
        testtarget+=1;
        if(testtarget != global.mymid)
         if(global.playership[testtarget] = obj_mod.foundtarget)
          break;
       }
      }
 break;

 //Phantom Mine
 case 7:
      //Check if you have mines left
      if(phantommine &gt; 0)
      {
       phan = instance_create(x, y, obj_phantommine);
       phan.mid = global.mymid;
       phan.amplified = amplified;
       //Take the mine away from your mine count
       phantommine -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 5)
         deploystock[i] -= 1;
       }
      }
 break;
 
 //Solus
 case 8:
      //Check if you have soluses left
      if(soluscount &lt; 1)
       exit;
      //Check if an existing solus belongs to you
      with(obj_solus)
       if(mid = global.mymid)
        exit;
      //Reduce soluses
      soluscount -= 1;
      //Create the solus where the cursor is
      solus = instance_create(x, y, obj_solus);
      solus.mid = global.mymid;
      solus.amplified = amplified;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 6)
         deploystock[i] -= 1;
       }
 break;
 
 //Formation
 case 9:
      //Make sure you are targetting someone
      if(obj_mod.foundtarget &lt;= -1)
       exit;
      //Check if you have energy for the barrier
      if(energy &lt; 30)
       exit;
      energygain = 0.2;
      //Reduce Energy
      energy -= 30;
      //Crete and send the initial shot at the cursor
      form = instance_create(x, y, obj_formationa);
      form.target = obj_mod.foundtarget;
      form.direction = point_direction(x, y, mouse_x, mouse_y);
      form.targetx = mouse_x;
      form.targety = mouse_y;
      form.mid = global.mymid;
      form.amplified = amplified;
      //Find out which ship you are targetting
      testtarget = -1;
      while(true)
      {
       testtarget+=1;
       if(testtarget != global.mymid)
        if(global.playership[testtarget] = obj_mod.foundtarget)
         break;
      }
 break;
 
 //Beam
 case 10:
      //Check if you have energy for the beam and that you are not moving
      if((energy &lt; 60 &amp;&amp; amplified = 1) || (energy &lt; 99.9 &amp;&amp; amplified = 0) || speed &gt; 0)
       exit;
      energygain = 0.2;
      //Reduce Energy
      energy -= 60;
      cooldown = 0;
      //Create a beam and give it the correct direction
      beam = instance_create(x+lengthdir_x(9, facedir), y+lengthdir_y(9, facedir), obj_beam);
      beam.direction = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);
      beam.mid = global.mymid;
 break;

 //Sparkline
 case 11:
      //Check if you have enough energy
      if(energy &lt; 15)
       exit;
      //Check if three nodes already exist
      if(instance_exists(node3) &amp;&amp; node3 != -1)
       exit;
      //Check if existing nodes are attacking
      if(instance_exists(node2) &amp;&amp; node2 != -1)
       if(node2.stage = 1)
        exit;
      if(instance_exists(node) &amp;&amp; node != -1)
       if(node.stage = 1)
        exit;
      energygain = 0.2;
      //Reduce Energy
      energy -= 15;
      if(amplified = 0)
       maxdist = 480;
      else
       maxdist = 680;
      //Create an infinite loop to section off this code
      while(true)
      {
       //Destroy existing nodes if this node is fired too far away
       if(instance_exists(node) &amp;&amp; node != -1)
       if(point_distance(mouse_x, mouse_y, node.x, node.y) &gt; maxdist)
       {
        with(node) instance_destroy();
        if(instance_exists(node2) &amp;&amp; node2 != -1)
         with(node2) instance_destroy();
       }
       if(instance_exists(node2) &amp;&amp; node2 != -1)
       if(point_distance(mouse_x, mouse_y, node2.x, node2.y) &gt; maxdist || amplified = 0)
       {
        with(node) instance_destroy();
        with(node2) instance_destroy();
       }
        //Check if a node exists
       if(instance_exists(node) &amp;&amp; node != -1)
       {
        //Check if a second node exists
        if(instance_exists(node2) &amp;&amp; node2 != -1)
        {
         //Create a third node
         node3 = instance_create(x, y, obj_sparkline);
         node3.direction = point_direction(x, y, mouse_x, mouse_y);
         node3.targetx = mouse_x;
         node3.targety = mouse_y;
         node3.final = 1;
         node3.mid = global.mymid;
         //Make the second node connect to this node
         node2.second = node3;
         //Connect to the first node
         node3.second = node;
         //Note this is the third node
         nodecount = 3;
         //Break the loop
         break;
        }
        //Create a second node
        node2 = instance_create(x, y, obj_sparkline);
        node2.direction = point_direction(x, y, mouse_x, mouse_y);
        node2.targetx = mouse_x;
        node2.targety = mouse_y;
        node2.final = 0;
        node2.mid = global.mymid;
        //Make the first node connect to this node
        node.second = node2;
        //Note this is the third node
        nodecount = 2;
        //Break the loop
        break;
       }
       //Create a node
       node = instance_create(x, y, obj_sparkline);
       node.direction = point_direction(x, y, mouse_x, mouse_y);
       node.targetx = mouse_x;
       node.targety = mouse_y;
       node.final = 0;
       node.mid = global.mymid;
       //Note this is the third node
       nodecount = 1;
       //Break the loop
       break;
      }
 break;

 //Burst
 case 12:
      //Check if you have energy for the barrier
      if(energy &lt; 20)
       exit;
      energygain = 0.2;
      //Reduce Energy
      energy -= 20;
      //Crete and send the initial shot at the cursor
      form = instance_create(x, y, obj_burst);
      form.direction = point_direction(x, y, mouse_x, mouse_y);
      form.targetx = mouse_x;
      form.targety = mouse_y;
      form.mid = global.mymid;
      form.amplified = amplified;
 break;
 
 //Trident Missile
 case 13:
      //Make sure you are targetting someone
      if(obj_mod.foundtarget &lt;= -1)
       exit;
      //Check if an existing dual missile belongs to you
      with(obj_tridentmissile)
       if(mid = global.mymid)
        exit;
      //Check if you have missiles left
      if(tridentmissile&gt;2)
      {
       //Create the first missile and give it its properties
       missile1 = instance_create(x, y, obj_tridentmissile);
       missile1.startdir = facedir;
       missile1.direction = facedir;
       missile1.speed = 4*global.framerate;
       missile1.target = obj_mod.foundtarget;
       missile1.mid = global.mymid;
       missile1.trio = 1;
       missile1.amplified = amplified;
       //Create the second missile
       missile2 = instance_create(x, y, obj_tridentmissile);
       missile2.startdir = facedir;
       missile2.direction = facedir-90;
       missile2.speed = 4*global.framerate;
       missile2.target = obj_mod.foundtarget;
       missile2.mid = global.mymid;
       missile2.trio = 2;
       missile2.middle = missile1;
       missile2.amplified = amplified;
       //Create the last missile
       missile3 = instance_create(x, y, obj_tridentmissile);
       missile3.startdir = facedir;
       missile3.direction = facedir+90;
       missile3.speed = 4*global.framerate;
       missile3.target = obj_mod.foundtarget;
       missile3.mid = global.mymid;
       missile3.trio = 3;
       missile3.middle = missile1;
       missile3.amplified = amplified;
       //Take note of the last two missile in the first missile
       missile1.second = missile2;
       missile1.third = missile3;
       //Take the missiles away from your missile count
       tridentmissile -= 3;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 7)
         deploystock[i] -= 1;
       }
       //Find out which ship you are targetting
       testtarget = -1;
       while(true)
       {
        testtarget+=1;
        if(testtarget != global.mymid)
         if(global.playership[testtarget] = obj_mod.foundtarget)
          break;
       }
      }
 break;
 
 //Slash
 case 14:
      //Check if you have energy for the barrier
      if(energy &lt; 20)
       exit;

      energygain = 0.2;
      //Reduce Energy
      energy -= 20;
      //Create and send the initial shot at the cursor
      form = instance_create(x+lengthdir_x(32, point_direction(x, y,mouse_x, mouse_y)), y+lengthdir_y(32, point_direction(x, y,mouse_x, mouse_y)), obj_slash);
      form.mid = global.mymid;
      form.targetx = mouse_x;
      form.targety = mouse_y;
      form.direction = point_direction(x, y,mouse_x, mouse_y);
      form.amplified = amplified;
 break;

 //Horizon
 case 15:
      //Make sure you are targetting someone
      if(obj_mod.foundtarget &lt;= -1)
       exit;
      //Check if you have energy for the barrier
      if(energy &lt; 25)
       exit;
      energygain = 0.2;
      //Reduce Energy
      energy -= 25;
      //Crete and send the initial shot at the cursor
      loldir = point_direction(x, y, obj_mod.foundtarget.x, obj_mod.foundtarget.y);
      form = instance_create(obj_mod.foundtarget.x+lengthdir_x(500, loldir), obj_mod.foundtarget.y+lengthdir_y(500, loldir), obj_horizon);
      form.target = obj_mod.foundtarget;
      form.direction = loldir-180;
      form.mid = global.mymid;
      form.amplified = amplified;
 break;

 //Hacker Mine
 case 16:
      //Check if you have mines left
      if(hackermine &gt; 0)
      {
       phan = instance_create(x, y, obj_hackermine);
       phan.mid = global.mymid;
       phan.amplified = amplified;
       //Take the mine away from your mine count
       hackermine -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 9)
         deploystock[i] -= 1;
       }
      }
 break;
 
 //Shock Missile
 case 17:
      //Make sure you are targetting someone
      if(obj_mod.foundtarget &lt;= -1)
       exit;
      //Check if an existing dual missile belongs to you
      with(obj_shockmissile)
       if(mid = global.mymid)
        exit;
      //Check if you have missiles left
      if(shockmissile &gt; 0)
      {
       //Create the first missile and give it its properties
       missile = instance_create(x, y, obj_shockmissile);
       missile.direction = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);
       missile.speed = 12*global.framerate;
       missile.target = obj_mod.foundtarget;
       missile.mid = global.mymid;
       missile.amplified = amplified;
       //Take the missiles away from your missile count
       shockmissile -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 8)
         deploystock[i] -= 1;
       }
       //Find out which ship you are targetting
       testtarget = -1;
       while(true)
       {
        testtarget+=1;
        if(testtarget != global.mymid)
         if(global.playership[testtarget] = obj_mod.foundtarget)
          break;
       }
      }
 break;
 
 //Hermit Missile
 case 18:
      //Make sure you are targetting someone
      if(obj_mod.foundtarget &lt;= -1)
       exit;
      //Check if an existing hermit missile belongs to you
      with(obj_hermitmissile)
       if(mid = global.mymid)
        exit;
      //Check if you have missiles left
      if(hermitmissile &gt; 0)
      {
       //Create the first missile and give it its properties
       missile = instance_create(x, y, obj_hermitmissile);
       missile.direction = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);
       missile.speed = 13*global.framerate;
       missile.mid = global.mymid;
       missile.target = obj_mod.foundtarget;
       missile.amplified = amplified;
       //Take the missiles away from your missile count
       hermitmissile -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 10)
         deploystock[i] -= 1;
       }
       //Find out which ship you are targetting
       testtarget = -1;
       while(true)
       {
        testtarget+=1;
        if(testtarget != global.mymid)
         if(global.playership[testtarget] = obj_mod.foundtarget)
          break;
       }
      }
 break;

 
 //Strike Missile
 case 19:
      //Make sure you are targetting someone
      if(obj_mod.foundtarget &lt;= -1)
       exit;
      //Check if you have missiles left
      if(strikemissile &gt; 0)
      {
       //Create the first missile and give it its properties
       missile = instance_create(x, y, obj_strikemissile);
       missile.direction = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);
       missile.speed = 13*global.framerate;
       missile.target = obj_mod.foundtarget;
       missile.mid = global.mymid;
       missile.amplified = amplified;
       //Take the missiles away from your missile count
       strikemissile -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 11)
         deploystock[i] -= 1;
       }
       //Find out which ship you are targetting
       testtarget = -1;
       while(true)
       {
        testtarget+=1;
        if(testtarget != global.mymid)
         if(global.playership[testtarget] = obj_mod.foundtarget)
          break;
       }
      }
 break;
 
 //Strike Mine
 case 20:
      //Check if you have mines left
      if(strikemine &gt; 0)
      {
       phan = instance_create(x, y, obj_strikemine);
       phan.mid = global.mymid;
       phan.amplified =amplified;
       //Take the mine away from your mine count
       strikemine -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 12)
         deploystock[i] -= 1;
       }
      }
 break;
 
 //Turret
 case 21:
      //Check if you have soluses left
      if(turret &lt; 1)
       exit;
      if(obj_bulletcontrol.wallposition[floor(mouse_x/32), floor(mouse_y/32)] = true)
       exit;
      //Reduce soluses
      turret -= 1;
      //Create the solus where the cursor is
      solus = instance_create(mouse_x, mouse_y, obj_turret);
      solus.mid = global.mymid;
      solus.amplified = amplified
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 13)
         deploystock[i] -= 1;
       }
 break;
 
 //Spiral
 case 22:
      //Check if you have energy for the barrier
      if(energy &lt; 20)
       exit;
      energygain = 0.2;
      //Reduce Energy
      energy -= 20;
      //Crete and send the initial shot at the cursor
      form = instance_create(x, y, obj_spiral);
      form.direction = point_direction(x, y, mouse_x, mouse_y);
      form.targetx = mouse_x;
      form.targety = mouse_y;
      form.mid = global.mymid;
      form.amplified = amplified;
 break;

 //Whip
 case 23:
      //Check to see if you have enough energy to use it
      if(energy &lt; 20 || whips &gt; 0)
       exit;
      //Initialize the attack
      energygain = 0.2;
      alarm[8] = 1;
      if(amplified = 0)
       whips = 15;
      else
       whips = 20;
      //Set the targetted coordinates
      hitx = mouse_x;
      hity = mouse_y;
      //Reduce energy
      energy -= 20;
 break;

 //Trail
 case 24:
      //Check if you have energy for the barrier
      if(energy &lt; 30)
       exit;
      energygain = 0.2;
      //Reduce Energy
      energy -= 30;
      //Crete and send the initial shot at the cursor
      form = instance_create(x, y, obj_trail);
      form.direction = point_direction(x, y, mouse_x, mouse_y);
      form.mid = global.mymid;
      form.amplified = amplified;
 break;

 //Serpent
 case 25:
      //Check if you have energy
      if(energy &lt; 25)
       exit;
      energygain = 0.2*global.framerate;
      //Reduce Energy
      energy -= 25;
      //Create and send the shot at the cursor
      form = instance_create(x, y, obj_serpent);
      form.direction = point_direction(x, y, mouse_x, mouse_y);
      form.mid = global.mymid;
      form.target = 1;
      form.amplified = amplified;
 break;

 //Storm
 case 26:
      //Check if you have energy
      if(energy &lt; 20)
       exit;
      energygain = 0.2*global.framerate;
      //Reduce Energy
      energy -= 20;
      with(obj_storm)
      {
        if(mid = global.mymid)
            age += 1;
        if(age = 4)
            instance_destroy();
      }
      with(obj_storm_wall)
      {
        if(mid = global.mymid)
            age += 1;
        if(age = 4)
            instance_destroy();
      }
        sfx_play(snd_storm, x, y);
      //Create and send shots at the cursor
      if(amplified = 0)
      {
       storm = instance_create(x, y, obj_storm);
       storm.direction = point_direction(x, y, mouse_x, mouse_y);
       storm.mid = global.mymid;
       storm = instance_create(x, y, obj_storm);
       storm.direction = point_direction(x, y, mouse_x, mouse_y)-30;
       storm.mid = global.mymid;
       storm = instance_create(x, y, obj_storm);
       storm.direction = point_direction(x, y, mouse_x, mouse_y)+30;
       storm.mid = global.mymid;
       storm = instance_create(x, y, obj_storm);
       storm.direction = point_direction(x, y, mouse_x, mouse_y)-15;
       storm.mid = global.mymid;
       storm = instance_create(x, y, obj_storm);
       storm.direction = point_direction(x, y, mouse_x, mouse_y)+15;
       storm.mid = global.mymid;
       storm = instance_create(mouse_x, mouse_y, obj_storm_wall);
       storm.direction = point_direction(x, y, mouse_x, mouse_y)-180;
       storm.x += lengthdir_x(point_distance(x, y, mouse_x, mouse_y), storm.direction-180);
       storm.y += lengthdir_y(point_distance(x, y, mouse_x, mouse_y), storm.direction-180);       
       storm.image_angle = storm.direction;
       storm.mid = global.mymid;
      }
      else
      {
       storm = instance_create(x, y, obj_storm);
       storm.direction = point_direction(x, y, mouse_x, mouse_y)+5;
       storm.mid = global.mymid;
       storm = instance_create(x, y, obj_storm);
       storm.direction = point_direction(x, y, mouse_x, mouse_y)-5;
       storm.mid = global.mymid;
       storm = instance_create(x, y, obj_storm);
       storm.direction = point_direction(x, y, mouse_x, mouse_y)-15;
       storm.mid = global.mymid;
       storm = instance_create(x, y, obj_storm);
       storm.direction = point_direction(x, y, mouse_x, mouse_y)+15;
       storm.mid = global.mymid;
       storm = instance_create(x, y, obj_storm);
       storm.direction = point_direction(x, y, mouse_x, mouse_y)-25;
       storm.mid = global.mymid;
       storm = instance_create(x, y, obj_storm);
       storm.direction = point_direction(x, y, mouse_x, mouse_y)+25;
       storm.mid = global.mymid;
       storm = instance_create(x, y, obj_storm);
       storm.direction = point_direction(x, y, mouse_x, mouse_y)-35;
       storm.mid = global.mymid;
       storm = instance_create(x, y, obj_storm);
       storm.direction = point_direction(x, y, mouse_x, mouse_y)+35;
       storm.mid = global.mymid;
       storm = instance_create(mouse_x, mouse_y, obj_storm_wall);
       storm.direction = point_direction(x, y, mouse_x, mouse_y)-180;
       storm.x += lengthdir_x(point_distance(x, y, mouse_x, mouse_y), storm.direction-180);
       storm.y += lengthdir_y(point_distance(x, y, mouse_x, mouse_y), storm.direction-180);       
       storm.image_angle = storm.direction;
       storm.mid = global.mymid;
      }

 break;
 
 //Trigger
 case 27:
      //Check if you have energy for the barrier
      if(energy &lt; 15)
       exit;
      energygain = 0.2;
      //Reduce Energy
      energy -= 15;
        //Destroy an old trigger
        var direct;
        direct = 0;
        if(instance_exists(obj_trigger))
            if(instance_exists(directthis))
                direct = 1;
        if(direct = 0)
        {
            //Crete and send the initial shot at the cursor
            form = instance_create(x, y, obj_trigger);
            form.direction = point_direction(x, y, mouse_x, mouse_y);
            form.targetx = mouse_x;
            form.targety = mouse_y;
            form.mid = global.mymid;
            form.amplified = amplified;
            directthis = form;
        }
        else
        {
            sfx_play(snd_wave, directthis.x, directthis.y);
            directthis.targetx = mouse_x;
            directthis.targety = mouse_y;
            directthis.speed = 13;
            directthis.direction = point_direction(directthis.x, directthis.y, mouse_x, mouse_y);
            directthis.alarm[0] = 5;
        }
 break;

 //Split Missile
 case 28:
      //Check if an existing hermit missile belongs to you
      with(obj_splitmissile)
       if(mid = global.mymid)
        exit;
      //Check if you have missiles left
      if(splitmissile &gt; 0)
      {
       //Create the first missile and give it its properties
       missile = instance_create(x, y, obj_splitmissile);
       missile.direction = aim_limit(facedir, point_direction(x, y, mouse_x, mouse_y), 30);
       missile.speed = 13*global.framerate;
       missile.mid = global.mymid;
       missile.oldmid = -1;
       missile.damage = 11;
       missile.amplified = amplified;
       //Take the missiles away from your missile count
       splitmissile -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 14)
         deploystock[i] -= 1;
       }
      }
 break;
 
 //Cluster Mine
 case 29:
      //Check if you have mines left
      if(clustermine &gt; 0)
      {
        //Destroy nearby mines
        for(i = instance_nearest(x, y, obj_clustermine); i != noone; i = instance_nearest(x, y, obj_clustermine))
        {
            if(point_distance(x, y, i.x, i.y) &lt; 400)
                with(i)
                    instance_destroy();
            else
                break;
        }
        for(i = instance_nearest(x, y, obj_clustermine_small); i != noone; i = instance_nearest(x, y, obj_clustermine_small))
        {
            if(point_distance(x, y, i.x, i.y) &lt; 400)
                with(i)
                    instance_destroy();
            else
                break;
        }
       phan = instance_create(x, y, obj_clustermine);
       phan.mid = global.mymid;
       phan.amplified = amplified;
       //Take the mine away from your mine count
       clustermine -= 1;
       //Take from the correct deploy count
       for(i = 1; i &lt;= 3; i += 1)
       {
        if(global.deploy[i] = 15)
         deploystock[i] -= 1;
       }
      }
 break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="18">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_perform(ev_keypress, vk_control);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="17">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(energy &lt;= 1)
 exit;
 
switch(global.shipselect)
{
 case 1:
     //Switch controlturn to make Alpha Drift ability
     controlturn = 0.1;
     abilityactive = 1;
 break;
 case 2:
      if(warping != -1 || cooldown = 0)
       exit;
      dist = point_distance(x, y, mouse_x, mouse_y);
      if(dist &gt; 400)
      {
       dist = 400;
       warpdir = point_direction(x, y, mouse_x, mouse_y);
       warpx = x+lengthdir_x(dist, warpdir);
       warpy = y+lengthdir_y(dist, warpdir);
      }
      else
      {
       warpx = mouse_x;
       warpy = mouse_y;
      }
      //Don't warp if you would warp into a wall
      if(collision_point(warpx, warpy, obj_wall, 1, 1))
       exit;
      warping = 40;
      heat -= 30;
      cooldown = 0;
      energygain = 0.2;
      //Change sprite to show warp
      sprite_index = spr_swiftwing_warp;
      if(global.team[global.mymid] = 2)
       sprite_index = spr_swiftwing_warp_enemy;
 break;
 case 3:
    //Create pulse
    if(shield &lt; 10 || energy &lt; 20)
     exit;
    shield -= 10;
    energy -= 20;
    abilityactive = 1;    
    energygain = 0.2;
    pulseout = instance_create(x, y, obj_shieldpulse);
    pulseout.mid = global.mymid;
 break;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="16">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_perform(ev_keypress, vk_control);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="87">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>predictspeed = 0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="83">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>predictspeed = 0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>predictturn = 0;
if(global.enableautoturn = false)
 //Take note of the last direction sent
 thisturn = 0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="65">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>predictturn = 0;
if(global.enableautoturn = false)
 //Take note of the last direction sent
 thisturn = 0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="18">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_perform(ev_keyrelease, vk_control);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="17">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>switch(global.shipselect)
{
 case 1:
     //Switch controlturn to make Alpha Drift ability
      controlturn = 0.75;
      if(global.framerate = 2)
       controlturn = 3;       
     abilityactive = 0;
 break;
 case 3:
    abilityactive = 0;    
    with(obj_shieldpulse)
        if(mid = global.mymid)
            endnow = 1;
 break;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="16">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_perform(ev_keyrelease, vk_control);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>13,11</point>
    <point>13,13</point>
  </PhysicsShapePoints>
</object>
