<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_sparkline</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1</depth>
  <persistent>0</persistent>
  <parentName>prnt_allyattack</parentName>
  <maskName>spr_empty</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Set the speed
speed = 17*global.framerate;
//Initialize variable for keeping track of a second node
second = -1;
//Initialize variable controlling drawing between nodes
drawline = 0;
//Initialize stage variable
stage = 0;
//Set damage to the base
damage = 0;
//Set auto-destroy time
alarm[0] = 660/global.framerate;
sfx_play(snd_sparkline, x, y);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//create an effect
effect_create_above(ef_ring, x, y, 0, c_aqua);
effect_create_above(ef_flare, x, y, 1, c_aqua);
part_type_color1(obj_partsystem.primarypart, c_aqua);
part_type_speed(obj_partsystem.primarypart,1.68,2.40,-0.04,0);
part_type_direction(obj_partsystem.primarypart,0,359,0,0);
part_particles_create(obj_partsystem.system, x, y, obj_partsystem.primarypart, 8);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check if a second node exists
if(instance_exists(second) &amp;&amp; second != -1)
{
 //Check if a third node exists
 if(instance_exists(second.second) &amp;&amp; second.second != -1)
  //Destroy the third node
  with(second.second)
   instance_destroy();
 //Destroy the second node
 with(second)
  instance_destroy();
}
//Destroy this node
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(x &lt; 0 || x &gt; room_width || y &lt; 0 || y &gt; room_height)
{
 instance_destroy();
 exit;
}
if(obj_bulletcontrol.wallposition[floor(x/32), floor(y/32)] = true)
 instance_destroy();
//Check if the target point has been reached
if(point_distance(x, y, targetx, targety) &lt;= 17*global.framerate &amp;&amp; speed = 17*global.framerate &amp;&amp; stage = 0)
 //Stop moving
 speed = 0;
if(final = 1 &amp;&amp; speed = 0)
{
 //Move all three nodes to the next stage
 stage = 1;
 second.stage = 1;
 second.second.stage = 1;
 //Find lengths of the sides of the triangle made
 sidea = point_distance(x, y, second.x, second.y);
 sideb = point_distance(second.x, second.y, second.second.x, second.second.y);
 sidec = point_distance(x, y, second.second.x, second.second.y);
 //Find the incenter of the triangle made
 hitx = ((sidea*x)+(sideb*second.x)+(sidec*second.second.x))/(sidea+sideb+sidec);
 hity = ((sidea*y)+(sideb*second.y)+(sidec*second.second.y))/(sidea+sideb+sidec);
 //Find the enemy closest to the incenter
 near = instance_nearest(hitx, hity, prnt_enemy);
 //Find out if the enemy is inside the triangle and target it if so
 if(point_in_triangle(near.x+lengthdir_x(10, near.direction), near.y+lengthdir_y(10, near.direction), x, y, second.x, second.y, second.second.x, second.second.y))
  hit = near;
 else
  //Create a target at the incenter if there is no enemy
  hit = instance_create(hitx, hity, obj_nodetarget);
 //Make the other two nodes target this
 second.hit = hit;
 second.second.hit = hit;
 //Set the speed for all three nodes
 speed = 17*global.framerate;
 second.speed = 17*global.framerate;
 second.second.speed = 17*global.framerate;
 //Set damage to max for all three nodes
 damage = 2;
 second.damage = 2;
 second.second.damage = 2;
}
//Check if a second node exists
if(instance_exists(second) &amp;&amp; stage = 0 &amp;&amp; second != -1)
{
 //If the second node is in place, begin drawing the connection
 if(second.speed = 0)
  drawline = 1;
 else
  exit;
 //Check for collisions in the connection
 hit = collision_line(x, y, second.x, second.y, prnt_enemy, 1, 1);
 //If there is a collision, move to the next stage
 if(hit &gt;= 0)
 {
  //Increase speed and damage
  speed = 17*global.framerate;
  damage = 1;
  stage = 1;
  //Increase the second node's speed and damage
  second.speed = 17*global.framerate;
  second.damage = 1;
  //Move the node to the next stage and tell it the collision
  second.stage = 1;
  second.hit = hit;
  //Check for a third node
  if(instance_exists(second.second) &amp;&amp; second.second != -1)
  {
   //Check if the third node is in place
   if(second.second.speed = 0)
   {
   //Increase the third node's speed and damage
   second.second.speed = 17*global.framerate;
   second.second.damage = 1;
   //Move the node to the next stage and tell it the collision
   second.second.stage = 1;
   second.second.hit = hit;
   }
   else
    //If the node isn't in place, destroy it.
    with(second.second)
     instance_destroy();
  }   
 }
}
//A collision has occured in the connection
if(stage = 1)
{
 mask_index = sprite_index;
 //Disable auto-destroy
 alarm[0] = -1;
 //Check to make sure the collision source still exists
 if(!instance_exists(hit))
  //Destroy this node if it doesn't
  instance_destroy();
 else
 //Move towards the collision source
 if(hit = obj_nodetarget)
  direction = point_direction(x, y, hit.x, hit.y); 
 else
  direction = point_direction(x, y, hit.x+lengthdir_x(10, hit.direction), hit.y+lengthdir_y(10, hit.direction));
}
 

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_nodetarget">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Destroy this node if this is the target
if(other.id = hit)
 instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check if a second sparkline node exists
if(instance_exists(second) &amp;&amp; second != -1)
{
 if((speed = 0 &amp;&amp; second.speed = 0) || stage = 1)
 {
  //Set the number of images to draw depenadant on the distance between the two nodes
  lines = ceil(point_distance(x, y, second.x, second.y)/64);
  //Set the direction to the node
  dir = point_direction(x, y, second.x, second.y);
  //Set the scale value so that all images are drawn the same
  scale = (point_distance(x, y, second.x, second.y)/64)/lines;
  for(i = 1; i &lt;= lines; i += 1)
  {
   draw_sprite_ext(spr_sparkline_line, -1, x+lengthdir_x(64*scale*(i-1), dir), y+lengthdir_y(64*scale*(i-1), dir), scale, 1, dir, c_white, 0.8);
  }
 }
}
//Draw the image. It's drawn after the sparkline image to remain on top
draw_sprite_ext(spr_sparkline, -1, x, y, 1, 1, 0, global.allycolor, 1);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>8,8</point>
    <point>8,8</point>
  </PhysicsShapePoints>
</object>
